
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anvil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/calypr/git-drs/client/anvil/anvil_client.go (0.0%)</option>
				
				<option value="file1">github.com/calypr/git-drs/client/anvil/remote.go (100.0%)</option>
				
				<option value="file2">github.com/calypr/git-drs/client/indexd/add_url.go (47.4%)</option>
				
				<option value="file3">github.com/calypr/git-drs/client/indexd/auth_handler.go (83.3%)</option>
				
				<option value="file4">github.com/calypr/git-drs/client/indexd/convert.go (86.5%)</option>
				
				<option value="file5">github.com/calypr/git-drs/client/indexd/gen3_remote.go (85.7%)</option>
				
				<option value="file6">github.com/calypr/git-drs/client/indexd/indexd_client.go (42.7%)</option>
				
				<option value="file7">github.com/calypr/git-drs/client/indexd/multipart_progress.go (71.1%)</option>
				
				<option value="file8">github.com/calypr/git-drs/client/indexd/progress.go (100.0%)</option>
				
				<option value="file9">github.com/calypr/git-drs/client/indexd/records.go (100.0%)</option>
				
				<option value="file10">github.com/calypr/git-drs/client/indexd/utils.go (81.8%)</option>
				
				<option value="file11">github.com/calypr/git-drs/cmd/addref/add-ref.go (3.3%)</option>
				
				<option value="file12">github.com/calypr/git-drs/cmd/addurl/main.go (21.2%)</option>
				
				<option value="file13">github.com/calypr/git-drs/cmd/cache/create-cache.go (0.0%)</option>
				
				<option value="file14">github.com/calypr/git-drs/cmd/delete/main.go (4.4%)</option>
				
				<option value="file15">github.com/calypr/git-drs/cmd/deleteproject/main.go (4.3%)</option>
				
				<option value="file16">github.com/calypr/git-drs/cmd/download/main.go (5.9%)</option>
				
				<option value="file17">github.com/calypr/git-drs/cmd/fetch/main.go (0.0%)</option>
				
				<option value="file18">github.com/calypr/git-drs/cmd/initialize/main.go (68.3%)</option>
				
				<option value="file19">github.com/calypr/git-drs/cmd/list/main.go (45.8%)</option>
				
				<option value="file20">github.com/calypr/git-drs/cmd/listconfig/main.go (6.2%)</option>
				
				<option value="file21">github.com/calypr/git-drs/cmd/prepush/main.go (67.1%)</option>
				
				<option value="file22">github.com/calypr/git-drs/cmd/push/main.go (0.0%)</option>
				
				<option value="file23">github.com/calypr/git-drs/cmd/query/main.go (40.3%)</option>
				
				<option value="file24">github.com/calypr/git-drs/cmd/register/main.go (1.6%)</option>
				
				<option value="file25">github.com/calypr/git-drs/cmd/remote/add/anvil.go (0.0%)</option>
				
				<option value="file26">github.com/calypr/git-drs/cmd/remote/add/gen3.go (57.1%)</option>
				
				<option value="file27">github.com/calypr/git-drs/cmd/remote/add/init.go (100.0%)</option>
				
				<option value="file28">github.com/calypr/git-drs/cmd/remote/list.go (71.4%)</option>
				
				<option value="file29">github.com/calypr/git-drs/cmd/remote/root.go (100.0%)</option>
				
				<option value="file30">github.com/calypr/git-drs/cmd/remote/set.go (0.0%)</option>
				
				<option value="file31">github.com/calypr/git-drs/cmd/root.go (100.0%)</option>
				
				<option value="file32">github.com/calypr/git-drs/cmd/transfer/main.go (46.3%)</option>
				
				<option value="file33">github.com/calypr/git-drs/cmd/transfer/progress.go (91.7%)</option>
				
				<option value="file34">github.com/calypr/git-drs/cmd/transferref/main.go (0.0%)</option>
				
				<option value="file35">github.com/calypr/git-drs/cmd/version/main.go (57.9%)</option>
				
				<option value="file36">github.com/calypr/git-drs/config/config.go (58.5%)</option>
				
				<option value="file37">github.com/calypr/git-drs/drs/hash/hash.go (97.9%)</option>
				
				<option value="file38">github.com/calypr/git-drs/drs/object.go (100.0%)</option>
				
				<option value="file39">github.com/calypr/git-drs/drs/store.go (78.9%)</option>
				
				<option value="file40">github.com/calypr/git-drs/drs/util.go (80.0%)</option>
				
				<option value="file41">github.com/calypr/git-drs/drslog/logger.go (74.6%)</option>
				
				<option value="file42">github.com/calypr/git-drs/drsmap/drs_map.go (41.0%)</option>
				
				<option value="file43">github.com/calypr/git-drs/drsmap/lfs_utils.go (94.1%)</option>
				
				<option value="file44">github.com/calypr/git-drs/git-drs.go (71.4%)</option>
				
				<option value="file45">github.com/calypr/git-drs/internal/testutils/config.go (56.8%)</option>
				
				<option value="file46">github.com/calypr/git-drs/internal/testutils/output.go (100.0%)</option>
				
				<option value="file47">github.com/calypr/git-drs/lfs/messages.go (100.0%)</option>
				
				<option value="file48">github.com/calypr/git-drs/s3_utils/download.go (66.0%)</option>
				
				<option value="file49">github.com/calypr/git-drs/s3_utils/s3.go (100.0%)</option>
				
				<option value="file50">github.com/calypr/git-drs/s3_utils/validate.go (100.0%)</option>
				
				<option value="file51">github.com/calypr/git-drs/tests/monorepos/generate-fixtures.go (0.0%)</option>
				
				<option value="file52">github.com/calypr/git-drs/utils/common.go (100.0%)</option>
				
				<option value="file53">github.com/calypr/git-drs/utils/confirmation.go (93.3%)</option>
				
				<option value="file54">github.com/calypr/git-drs/utils/lfs-track.go (78.9%)</option>
				
				<option value="file55">github.com/calypr/git-drs/utils/util.go (86.2%)</option>
				
				<option value="file56">github.com/calypr/git-drs/version/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anvil_client

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "golang.org/x/oauth2/google"
)

type AnvilClient struct {
        Endpoint string
        SConfig  sonic.API
}

func (an *AnvilClient) GetObject(objectID string) (*drs.DRSObject, error) <span class="cov0" title="0">{
        // get auth token
        token, err := GetAuthToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auth token: %w", err)
        }</span>

        <span class="cov0" title="0">reqBody := map[string]any{
                "url":    objectID,
                "fields": []string{"hashes", "size", "fileName"},
        }
        bodyBytes, err := an.SConfig.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", an.Endpoint, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, _ := io.ReadAll(resp.Body)
        if resp.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                // Try to extract error message
                var errResp map[string]any
                an.SConfig.Unmarshal(respBody, &amp;errResp)
                msg := fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(respBody))
                if m, ok := errResp["message"].(string); ok </span><span class="cov0" title="0">{
                        msg = m
                }</span>
                <span class="cov0" title="0">return &amp;drs.DRSObject{}, errors.New(msg)</span>
        }

        // Parse expected response
        // subset of ResourceMetadata
        // https://github.com/DataBiosphere/terra-drs-hub/blob/dev/common/openapi.yml#L123
        <span class="cov0" title="0">var parsed struct {
                Hashes   map[string]string `json:"hashes"`
                Size     int64             `json:"size"`
                FileName string            `json:"fileName"`
        }
        if err := an.SConfig.Unmarshal(respBody, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.DRSObject{
                SelfURI:   objectID,
                Id:        objectID,
                Checksums: hash.ConvertStringMapToHashInfo(parsed.Hashes),
                Size:      parsed.Size,
                Name:      parsed.FileName,
        }, nil</span>
}

// GetAuthToken fetches a Google Cloud authentication token using Application Default Credentials.
// The user must run `gcloud auth application-default login` before using this.
func GetAuthToken() (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        creds, err := google.FindDefaultCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">ts := creds.TokenSource
        token, err := ts.Token()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid() || token.AccessToken == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no token retrieved")
        }</span>

        <span class="cov0" title="0">return token.AccessToken, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package anvil_client

import (
        "fmt"
        "log"

        "github.com/calypr/git-drs/client"
)

// AnvilAuth holds authentication info for Anvil
type AnvilAuth struct {
        TerraProject string `yaml:"terra_project"`
}

// AnvilRemote holds Anvil remote config
type AnvilRemote struct {
        Endpoint string    `yaml:"endpoint"`
        Auth     AnvilAuth `yaml:",inline"`
}

func (s AnvilRemote) GetProjectId() string <span class="cov8" title="1">{
        return s.Auth.TerraProject
}</span>

func (s AnvilRemote) GetEndpoint() string <span class="cov8" title="1">{
        return s.Endpoint
}</span>

func (s AnvilRemote) GetBucketName() string <span class="cov8" title="1">{
        return ""
}</span>

func (s AnvilRemote) GetClient(params map[string]string, logger *log.Logger) (client.DRSClient, error) <span class="cov8" title="1">{
        return nil, fmt.Errorf(("AnVIL Client needs to be implemented"))
        // return NewAnvilClient(s, logger)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package indexd_client

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net/http"
        "path/filepath"
        "slices"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/messages"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
)

// getBucketDetails fetches bucket details from Gen3, loading config and auth.
// This is the production version that includes all config/auth dependencies.
func (inc *IndexDClient) getBucketDetails(ctx context.Context, bucket string, httpClient *http.Client) (*s3_utils.S3Bucket, error) <span class="cov0" title="0">{
        // get all buckets
        baseURL := *inc.Base // Create a copy to avoid mutating inc.Base
        baseURL.Path = filepath.Join(baseURL.Path, "user/data/buckets")
        // Use the AuthHandler pattern for cleaner auth handling
        return GetBucketDetailsWithAuth(ctx, bucket, baseURL.String(), inc.AuthHandler, httpClient)
}</span>

// FetchS3MetadataWithBucketDetails fetches S3 metadata given bucket details.
// This is the core testable logic, separated for easier unit testing.
func FetchS3MetadataWithBucketDetails(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, bucketDetails *s3_utils.S3Bucket, s3Client *s3.Client, logger *log.Logger) (int64, string, error) <span class="cov10" title="9">{

        // Parse S3 URL
        bucket, key, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov1" title="1">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        // Create s3 client if not passed as param
        <span class="cov9" title="8">var finalRegion, finalEndpoint string
        var finalCfg aws.Config
        var clientWasProvided bool = (s3Client != nil)

        if s3Client == nil </span><span class="cov7" title="5">{
                // Always load base AWS configuration first
                cfg, err := awsConfig.LoadDefaultConfig(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", fmt.Errorf("unable to load base AWS SDK config: %v. %s", err, messages.ADDURL_HELP_MSG)
                }</span>

                // Build config options to override defaults
                <span class="cov7" title="5">var configOptions []func(*awsConfig.LoadOptions) error

                // Override credentials if provided
                if awsAccessKey != "" &amp;&amp; awsSecretKey != "" </span><span class="cov6" title="4">{
                        configOptions = append(configOptions,
                                awsConfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                                        awsAccessKey,
                                        awsSecretKey,
                                        "", // session token (empty for basic credentials)
                                )),
                        )
                }</span>

                // Override region with priority: parameter &gt; bucketDetails &gt; default
                <span class="cov7" title="5">regionToUse := ""
                if region != "" </span><span class="cov3" title="2">{
                        regionToUse = region
                }</span> else<span class="cov5" title="3"> if bucketDetails.Region != "" </span><span class="cov1" title="1">{
                        regionToUse = bucketDetails.Region
                }</span>
                <span class="cov7" title="5">if regionToUse != "" </span><span class="cov5" title="3">{
                        configOptions = append(configOptions, awsConfig.WithRegion(regionToUse))
                }</span>

                // Reload config with overrides if any options were set
                <span class="cov7" title="5">if len(configOptions) &gt; 0 </span><span class="cov6" title="4">{
                        cfg, err = awsConfig.LoadDefaultConfig(ctx, configOptions...)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, "", fmt.Errorf("unable to load AWS SDK config with overrides: %v. %s", err, messages.ADDURL_HELP_MSG)
                        }</span>
                }

                // Determine endpoint with priority: parameter &gt; bucketDetails &gt; default config
                <span class="cov7" title="5">endpointToUse := ""
                if endpoint != "" </span><span class="cov3" title="2">{
                        endpointToUse = endpoint
                        finalEndpoint = endpoint
                }</span> else<span class="cov5" title="3"> if bucketDetails.EndpointURL != "" </span><span class="cov5" title="3">{
                        endpointToUse = bucketDetails.EndpointURL
                }</span>
                // Note: endpoint may also come from AWS config file, which will be loaded automatically

                // Store final values for validation
                <span class="cov7" title="5">finalRegion = cfg.Region
                finalCfg = cfg

                // Create S3 client with optional endpoint override and path-style addressing
                s3Client = s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov7" title="5">{
                        if endpointToUse != "" </span><span class="cov7" title="5">{
                                o.BaseEndpoint = aws.String(endpointToUse)
                        }</span>
                        <span class="cov7" title="5">o.UsePathStyle = true</span> // This forces path-style URLs
                })
        }

        // Validate that all required configuration is present before making the HeadObject call
        // Only validate if we created the client ourselves (not provided as parameter)
        <span class="cov9" title="8">if !clientWasProvided </span><span class="cov7" title="5">{
                var missingFields []string

                // Check credentials
                if finalCfg.Credentials != nil </span><span class="cov7" title="5">{
                        creds, err := finalCfg.Credentials.Retrieve(ctx)
                        if err != nil || creds.AccessKeyID == "" </span><span class="cov1" title="1">{
                                missingFields = append(missingFields, "AWS credentials (access key and secret key)")
                        }</span>
                }

                // Check region
                <span class="cov7" title="5">if finalRegion == "" </span><span class="cov3" title="2">{
                        missingFields = append(missingFields, "AWS region")
                }</span>

                // Check endpoint, ok if missing
                <span class="cov7" title="5">if finalEndpoint == "" </span><span class="cov5" title="3">{
                        logger.Print("Warning: S3 endpoint URL is not provided. If supplied, using default AWS endpoint in configuration.")
                }</span>

                // Note: We don't validate endpoint here because:
                // 1. It may be configured in AWS config file (which we can't easily inspect)
                // 2. For standard AWS S3, the endpoint is optional and determined by region

                // If any required fields are missing, return a clear error
                <span class="cov7" title="5">if len(missingFields) &gt; 0 </span><span class="cov3" title="2">{
                        var errorMsg strings.Builder
                        errorMsg.WriteString("Missing required AWS configuration:\n")
                        for i, field := range missingFields </span><span class="cov5" title="3">{
                                errorMsg.WriteString(fmt.Sprintf("  %d. %s\n", i+1, field))
                        }</span>
                        <span class="cov3" title="2">errorMsg.WriteString("\nPlease provide these values via:\n")
                        errorMsg.WriteString("  - Command-line flags (--" + s3_utils.AWS_KEY_FLAG_NAME + ", --" + s3_utils.AWS_SECRET_FLAG_NAME + ", --" + s3_utils.AWS_REGION_FLAG_NAME + ", --" + s3_utils.AWS_ENDPOINT_URL_FLAG_NAME + ")\n")
                        errorMsg.WriteString("  - Environment variables (" + s3_utils.AWS_KEY_ENV_VAR + ", " + s3_utils.AWS_SECRET_ENV_VAR + ", " + s3_utils.AWS_REGION_ENV_VAR + ", " + s3_utils.AWS_ENDPOINT_URL_ENV_VAR + ")\n")
                        errorMsg.WriteString("  - AWS credentials file (~/.aws/credentials)\n")
                        errorMsg.WriteString("  - Gen3 bucket registration (if bucket can be registered in Gen3)\n")
                        errorMsg.WriteString("\n")
                        errorMsg.WriteString(messages.ADDURL_HELP_MSG)
                        return 0, "", errors.New(errorMsg.String())</span>
                }
        }

        // Ensure client was initialized (safety check)
        <span class="cov8" title="6">if s3Client == nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("S3 client was not initialized. %s", messages.ADDURL_HELP_MSG)
        }</span>

        <span class="cov8" title="6">input := &amp;s3.HeadObjectInput{
                Bucket: &amp;bucket,
                Key:    aws.String(key),
        }

        resp, err := s3Client.HeadObject(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                return 0, "", fmt.Errorf("failed to head object, %v", err)
        }</span>

        <span class="cov7" title="5">var contentLength int64
        if resp.ContentLength != nil </span><span class="cov7" title="5">{
                contentLength = *resp.ContentLength
        }</span> else<span class="cov0" title="0"> {
                contentLength = 0
        }</span>

        <span class="cov7" title="5">return contentLength, resp.LastModified.Format(time.RFC3339), nil</span>
}

// fetchS3Metadata fetches S3 metadata (size, modified date) for a given S3 URL.
// This is the production version that fetches bucket details from Gen3.
func (inc *IndexDClient) fetchS3Metadata(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, s3Client *s3.Client, httpClient *http.Client, logger *log.Logger) (int64, string, error) <span class="cov0" title="0">{

        // Fetch AWS bucket region and endpoint from /data/buckets (fence in gen3)
        bucket, _, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">bucketDetails, err := inc.getBucketDetails(ctx, bucket, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("unable to get bucket details: %w. Please ensure you've specified the correct AWS region and AWS bucket endpoint URL via flags or environment variables. %s", err, messages.ADDURL_HELP_MSG)
        }</span>
        <span class="cov0" title="0">if bucketDetails == nil </span><span class="cov0" title="0">{
                logger.Println("WARNING: no matching bucket found in CALYPR")
                bucketDetails = &amp;s3_utils.S3Bucket{}
        }</span>

        <span class="cov0" title="0">return FetchS3MetadataWithBucketDetails(ctx, s3URL, awsAccessKey, awsSecretKey, region, endpoint, bucketDetails, s3Client, logger)</span>
}

// // upserts index record, so that if...
// // 1. the record exists for the project, it updates the URL
// // 2. the record for the project does not exist, it creates a new one
func (inc *IndexDClient) upsertIndexdRecord(url string, sha256 string, fileSize int64, logger *log.Logger) (*drs.DRSObject, error) <span class="cov0" title="0">{
        projectId := inc.GetProjectId()
        uuid := drsmap.DrsUUID(projectId, sha256)

        // handle if record already exists
        records, err := inc.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: sha256})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying indexd server for matches to hash %s: %v", sha256, err)
        }</span>

        <span class="cov0" title="0">matchingRecord, err := drsmap.FindMatchingRecord(records, projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
        }</span>

        <span class="cov0" title="0">if matchingRecord != nil &amp;&amp; matchingRecord.Id == uuid </span><span class="cov0" title="0">{
                // if record exists and contains requested url, nothing to do
                if slices.Contains(indexdURLFromDrsAccessURLs(matchingRecord.AccessMethods), url) </span><span class="cov0" title="0">{
                        logger.Print("Nothing to do: file already registered")
                        return matchingRecord, nil
                }</span>

                // if record exists with different url, update via index/{guid}
                <span class="cov0" title="0">if matchingRecord.Id == uuid &amp;&amp; !slices.Contains(indexdURLFromDrsAccessURLs(matchingRecord.AccessMethods), url) </span><span class="cov0" title="0">{
                        logger.Print("updating existing record with new url")

                        updatedRecord := drs.DRSObject{AccessMethods: []drs.AccessMethod{{AccessURL: drs.AccessURL{URL: url}}}}
                        drsObj, err := inc.UpdateRecord(&amp;updatedRecord, matchingRecord.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update indexd record: %w", err)
                        }</span>
                        <span class="cov0" title="0">return drsObj, nil</span>
                }
        }

        // If no record exists, create indexd record
        <span class="cov0" title="0">logger.Print("creating new record")
        authzStr, err := utils.ProjectToResource(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, relPath, err := utils.ParseS3URL(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get relative S3 path from URL: %s", url)
        }</span>

        <span class="cov0" title="0">indexdObject := &amp;IndexdRecord{
                Did:      uuid,
                FileName: relPath,
                Hashes:   hash.HashInfo{SHA256: sha256},
                Size:     fileSize,
                URLs:     []string{url},
                Authz:    []string{authzStr},
                // NOTE: that this isn't being carried over atm cause we're registering via DRS Object
                Metadata: map[string]string{"remote": "true"},
        }

        inputDrsObj, err := indexdObject.ToDrsObject()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert indexd record to DRS object: %w", err)
        }</span>

        <span class="cov0" title="0">drsObj, err := inc.RegisterRecord(inputDrsObj)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register indexd record: %w", err)
        }</span>
        <span class="cov0" title="0">return drsObj, nil</span>
}

// AddURL adds a file to the Git DRS repo using an S3 URL
func (inc *IndexDClient) AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, regionFlag, endpointFlag string, opts ...s3_utils.AddURLOption) (s3_utils.S3Meta, error) <span class="cov3" title="2">{
        // Create context with 10-second timeout
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // Apply options
        cfg := &amp;s3_utils.AddURLConfig{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        // Use NoOpLogger if no logger provided
        <span class="cov3" title="2">if inc.Logger == nil </span><span class="cov0" title="0">{
                inc.Logger = drslog.NewNoOpLogger()
        }</span>

        // Validate inputs
        <span class="cov3" title="2">if err := s3_utils.ValidateInputs(s3URL, sha256); err != nil </span><span class="cov3" title="2">{
                return s3_utils.S3Meta{}, err
        }</span>

        // check that lfs is tracking the file
        <span class="cov0" title="0">_, relPath, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        // confirm file is tracked
        <span class="cov0" title="0">isLFS, err := utils.IsLFSTracked(".gitattributes", relPath)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("unable to determine if file is tracked by LFS: %w", err)
        }</span>
        <span class="cov0" title="0">if !isLFS </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("file is not tracked by LFS. Please run `git lfs track %s &amp;&amp; git add .gitattributes` before proceeding", relPath)
        }</span>

        // Fetch S3 metadata (size, modified date)
        <span class="cov0" title="0">inc.Logger.Print("Fetching S3 metadata...")
        fileSize, modifiedDate, err := inc.fetchS3Metadata(ctx, s3URL, awsAccessKey, awsSecretKey, regionFlag, endpointFlag, cfg.S3Client, cfg.HttpClient, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                // if err contains 403, probably misconfigured credentials
                if strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        return s3_utils.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w. Double check your configured AWS credentials and endpoint url", err)
                }</span>
                <span class="cov0" title="0">return s3_utils.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w", err)</span>
        }

        // logging
        <span class="cov0" title="0">inc.Logger.Print("Fetched S3 metadata successfully:")
        inc.Logger.Printf(" - File Size: %d bytes", fileSize)
        inc.Logger.Printf(" - Last Modified: %s", modifiedDate)

        // Create indexd record
        inc.Logger.Print("Processing indexd record...")
        drsObj, err := inc.upsertIndexdRecord(s3URL, sha256, fileSize, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to create indexd record: %w", err)
        }</span>

        // write to file so push has that file available
        <span class="cov0" title="0">drsObjPath, err := drsmap.GetObjectPath(projectdir.DRS_OBJS_PATH, drsObj.Checksums.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to get object path: %w", err)
        }</span>
        <span class="cov0" title="0">if err := drsmap.WriteDrsObj(drsObj, sha256, drsObjPath); err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to write DRS object: %w", err)
        }</span>

        <span class="cov0" title="0">inc.Logger.Print("Indexd updated")

        return s3_utils.S3Meta{
                Size:         fileSize,
                LastModified: modifiedDate,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package indexd_client

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/calypr/data-client/client/api"
        "github.com/calypr/data-client/client/conf"
        "github.com/calypr/data-client/client/logs"
        "github.com/calypr/data-client/client/request"
        GoJwt "github.com/golang-jwt/jwt/v5"
)

// RealAuthHandler uses actual Gen3 authentication
type RealAuthHandler struct {
        Cred conf.Credential
}

func (rh *RealAuthHandler) AddAuthHeader(req *http.Request) error <span class="cov9" title="573">{
        return rh.addGen3AuthHeader(req.Context(), req)
}</span>

// Moved this function out of bmeg/grip-graphql/middleware into this repo to simplify deps.
func GetExpiration(tokenString string) (time.Time, error) <span class="cov10" title="575">{
        // Also consider trimming the 'Bearer ' prefix too
        tokenString = strings.TrimPrefix(tokenString, "bearer ")
        token, _, err := new(GoJwt.Parser).ParseUnverified(tokenString, GoJwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        // Parse and convert from float64 epoch time to time.Time
        <span class="cov10" title="575">if claims, ok := token.Claims.(GoJwt.MapClaims); ok </span><span class="cov10" title="575">{
                if exp, ok := claims["exp"].(float64); ok </span><span class="cov9" title="574">{
                        temp := int64(exp)
                        exp := time.Unix(temp, 0)
                        return exp, nil
                }</span>
        }
        <span class="cov1" title="1">return time.Time{}, fmt.Errorf("expiration field 'exp' type float64 not found in token %v", token)</span>
}

// Kindof hackish. There exists logic to do this deeper in gen3-client but it is not exported
func RefreshToken(ctx context.Context, cred *conf.Credential) error <span class="cov9" title="573">{
        expiration, err := GetExpiration(cred.AccessToken)

        // Update AccessToken if token is old or there was an error getting the expiration
        needRefresh := false
        if err != nil </span><span class="cov0" title="0">{
                needRefresh = true
        }</span> else<span class="cov9" title="573"> if expiration.Before(time.Now()) </span><span class="cov2" title="3">{
                needRefresh = true
        }</span>

        <span class="cov9" title="573">if needRefresh </span><span class="cov2" title="3">{
                logger, closer := logs.New(cred.Profile)
                defer closer()

                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("failed to get access token expiration, attempting token refresh: %v", err)
                }</span>
                <span class="cov2" title="3">conf := conf.NewConfigure(logger)
                r := api.NewFunctions(conf, request.NewRequestInterface(logger, cred, conf), cred, logger)
                f, ok := r.(*api.Functions)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("Function interface is not of type api.Functions")
                }</span>
                <span class="cov2" title="3">err = f.NewAccessToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="3">cred.AccessToken = f.Cred.AccessToken
                err = conf.Save(cred)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov9" title="573">return nil</span>
}

func (rh *RealAuthHandler) refreshToken(ctx context.Context) error <span class="cov9" title="573">{
        return RefreshToken(ctx, &amp;rh.Cred)
}</span>

func (rh *RealAuthHandler) addGen3AuthHeader(ctx context.Context, req *http.Request) error <span class="cov9" title="573">{
        err := rh.refreshToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Add headers to the request
        <span class="cov9" title="573">authStr := "Bearer " + rh.Cred.AccessToken
        req.Header.Set("Authorization", authStr)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package indexd_client

// Conversion functions between DRSObject and IndexdRecord

import (
        "fmt"
        "net/url"

        "github.com/calypr/git-drs/drs"
)

// IndexdRecord represents a simplified version of an indexd record for conversion purposes
func indexdRecordFromDrsObject(drsObj *drs.DRSObject) (*IndexdRecord, error) <span class="cov8" title="105">{
        indexdObj := &amp;IndexdRecord{
                Did:      drsObj.Id,
                Size:     drsObj.Size,
                FileName: drsObj.Name,
                URLs:     indexdURLFromDrsAccessURLs(drsObj.AccessMethods),
                Authz:    indexdAuthzFromDrsAccessMethods(drsObj.AccessMethods),
                Hashes:   drsObj.Checksums,
                //Metadata: drsObj.Metadata,
                //Form:     drsObj.Form,
        }
        return indexdObj, nil
}</span>

func indexdRecordToDrsObject(indexdObj *IndexdRecord) (*drs.DRSObject, error) <span class="cov9" title="216">{
        accessMethods, err := drsAccessMethodsFromIndexdURLs(indexdObj.URLs, indexdObj.Authz)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="216">for _, am := range accessMethods </span><span class="cov9" title="216">{
                if am.Authorizations == nil || am.Authorizations.Value == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("access method missing authorization %v, %v", indexdObj, indexdObj.Authz)
                }</span>
        }

        <span class="cov9" title="216">return &amp;drs.DRSObject{
                Id:   indexdObj.Did,
                Size: indexdObj.Size,
                //Form:  indexdObj.Form,
                Name:          indexdObj.FileName,
                AccessMethods: accessMethods,
                Checksums:     indexdObj.Hashes,
                //Metadata: indexdObj.Metadata,
        }, nil</span>
}

func drsAccessMethodsFromIndexdURLs(urls []string, authz []string) ([]drs.AccessMethod, error) <span class="cov10" title="217">{
        var accessMethods []drs.AccessMethod
        for _, urlString := range urls </span><span class="cov10" title="217">{
                var method drs.AccessMethod
                method.AccessURL = drs.AccessURL{URL: urlString}

                parsed, err := url.Parse(urlString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse url %q: %v", urlString, err)
                }</span>
                <span class="cov10" title="217">if parsed.Scheme == "" </span><span class="cov0" title="0">{
                        // default to https if no scheme or parse error
                        method.Type = "https"
                }</span> else<span class="cov10" title="217"> {
                        method.Type = parsed.Scheme
                }</span>

                // check if authz is null or 0-length, then error
                <span class="cov10" title="217">if authz == nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("authz is required")
                }</span>

                // NOTE: a record can only have 1 authz entry atm
                // this is fine since rn we're creating UUIDs based on project ID
                <span class="cov9" title="216">method.Authorizations = &amp;drs.Authorizations{Value: authz[0]}
                accessMethods = append(accessMethods, method)</span>
        }
        <span class="cov9" title="216">return accessMethods, nil</span>
}

// extract authz values from DRS access methods
func indexdAuthzFromDrsAccessMethods(accessMethods []drs.AccessMethod) []string <span class="cov8" title="106">{
        var authz []string
        for _, drsURL := range accessMethods </span><span class="cov8" title="106">{
                if drsURL.Authorizations != nil </span><span class="cov8" title="106">{
                        authz = append(authz, drsURL.Authorizations.Value)
                }</span>
        }
        <span class="cov8" title="106">return authz</span>
}

func indexdURLFromDrsAccessURLs(accessMethods []drs.AccessMethod) []string <span class="cov8" title="105">{
        var urls []string
        for _, drsURL := range accessMethods </span><span class="cov8" title="105">{
                urls = append(urls, drsURL.AccessURL.URL)
        }</span>
        <span class="cov8" title="105">return urls</span>
}

func (inr *IndexdRecord) ToDrsObject() (*drs.DRSObject, error) <span class="cov4" title="10">{
        o, err := indexdRecordToDrsObject(inr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="10">return o, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package indexd_client

import (
        "log"

        "github.com/calypr/data-client/client/conf"
        "github.com/calypr/git-drs/client"
)

// Gen3Server holds Gen3 server config
type Gen3Remote struct {
        Endpoint  string `yaml:"endpoint"`
        ProjectID string `yaml:"project_id"`
        Bucket    string `yaml:"bucket"`
}

func (s Gen3Remote) GetProjectId() string <span class="cov10" title="931">{
        return s.ProjectID
}</span>

func (s Gen3Remote) GetEndpoint() string <span class="cov1" title="2">{
        return s.Endpoint
}</span>

func (s Gen3Remote) GetBucketName() string <span class="cov10" title="931">{
        return s.Bucket
}</span>

func (s Gen3Remote) GetClient(params map[string]string, logger *log.Logger) (client.DRSClient, error) <span class="cov9" title="930">{
        cred, err := conf.NewConfigure(logger).Load(params["remote_name"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="930">return NewIndexDClient(*cred, s, logger)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package indexd_client

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/client/common"
        "github.com/calypr/data-client/client/conf"
        "github.com/calypr/data-client/client/logs"
        "github.com/calypr/data-client/client/request"
        "github.com/calypr/data-client/client/upload"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
        "github.com/hashicorp/go-multierror"
        "github.com/hashicorp/go-retryablehttp"

        dataClient "github.com/calypr/data-client/client/client"
)

type IndexDClient struct {
        Base        *url.URL
        ProjectId   string
        BucketName  string
        Logger      *log.Logger
        AuthHandler s3_utils.AuthHandler // Injected for testing/flexibility

        HttpClient *retryablehttp.Client
        SConfig    sonic.API

        Upsert             bool  // whether to force push (upsert) indexd records and file uploads
        MultiPartThreshold int64 // threshold for multipart uploads
}

////////////////////
// CLIENT METHODS //
////////////////////

// load repo-level config and return a new IndexDClient
func NewIndexDClient(profileConfig conf.Credential, remote Gen3Remote, logger *log.Logger) (client.DRSClient, error) {

        baseUrl, err := url.Parse(profileConfig.APIEndpoint)
        // get the gen3Project and gen3Bucket from the config
        projectId := remote</span>.GetProjectId()
        if projectId == "" </span>{
                </span>return nil, fmt.Errorf("no gen3 project specified. Run 'git drs init', use the '--help' flag for more info")
        }</span>

        bucketName := remote</span>.GetBucketName()
        if bucketName == "" </span>{
                </span>logger.Println("WARNING: no gen3 bucket specified. To add a bucket, run 'git remote add gen3', use the '--help' flag for more info")
        }</span>

        transport := &amp;http.Transport{
                MaxIdleConns:        100, // Default pool size (across all hosts)
                MaxIdleConnsPerHost: 100, // Important: Pool size per *single host* (your Indexd server)
                IdleConnTimeout:     90 * time.Second,
        }
        httpClient := &amp;http.Client{
                Timeout:   30 * time.Second,
                Transport: transport,
        }
        retryClient := retryablehttp.NewClient()
        retryClient.HTTPClient = httpClient

        // Custom CheckRetry: do not retry when response body contains "already exists"
</span>        retryClient.CheckRetry = func(ctx context.Context, resp *http.Response, err error) (bool, error) </span>{
</span>                if resp != nil &amp;&amp; resp.StatusCode &lt; 500 &amp;&amp; resp.StatusCode &gt;= 400 {
                        // do not retry on 4xx
                        // 400 =&gt; "The request could not be understood by the
                        // server due to malformed syntax".
                        </span></span>return false, nil
                }</span>
</span>                if resp != nil &amp;&amp; resp.Body != nil {
                        bodyBytes, readErr := io.ReadAll(resp.Body)
                        // restore body for downstream consumers
                        resp.Body = io.Nop</span></span>Closer(bytes.NewBuffer(bodyBytes))
                        if readErr == nil </span>{
</span>                                if strings.Contains(string(bodyBytes), "already exists") </span>{
                                        // do not retry on "already exists" messages
                                        </span>return false, nil
                                }</span>
                        }
                }
                <span class="cov9" title="328">// fallback to default policy
</span>                <span class="cov8" title="189">return retryablehttp.DefaultRetryPolicy(ctx, resp, err)</span>
        }

        retryClient.Logger = logger
        // TODO - make these configurable?
        retryClient.RetryMax = 5
        retryClient.RetryWaitMin = 5 * time.Second
        retryClient.RetryWaitMax = 15 * time.Second

        upsert, err :=</span> getLfsCustomTransferBool("lfs.customtransfer.drs.upsert", false)
        if err != nil </span>{
                </span>return nil, err
        }</span>

        multiPartThresholdInt, err := getLfsCustomTransferInt("lfs.customtransfer.drs.multipart-threshold", 500)
        var multiPartThreshold int64 = multiPartThresholdInt * common.MB // default 100 MB

        return &amp;IndexDClient{
                Base:               baseUrl,
                ProjectId:          projectId,
                BucketName:         bucketName,
                Logger:             logger,
                AuthHandler:        &amp;RealAuthHandler{profileConfig}, // Use real auth in production
                HttpClient:         retryClient,
                SConfig:            sonic.ConfigFastest,
                Upsert:             upsert,
                Multi</span>PartThreshold: multiPartThreshold,
        }, nil</span>
}

func (cl *IndexDClient) GetProjectId() string {
        </span>return cl.ProjectId
}</span>

func getLfsCustomTransferBool(key string, defaultValue bool) (bool, error) {
        defaultText := strconv.FormatBool(defaultValue)
        // TODO cache or get all the configs at once?
        cmd := exec.Command("git", "config", "--get", "--default", defaultText, key)
        output, err :=</span> cmd.Output()
        if err != nil </span>{
                </span>return defaultValue, fmt.Errorf("error reading git config %s: %v", key, err)
        }</span>

        value := strings.TrimSpace(string(output))

        parsed, err :=</span> strconv.ParseBool(value)
        if err != nil </span>{
                </span>return defaultValue, fmt.Errorf("invalid boolean value for %s: &gt;%q&lt;", key, value)
        }</span>
</span>        <span class="cov9" title="337">return parsed, nil</span>
}

func getLfsCustomTransferInt(key string, defaultValue int64) (int64, error) {
        defaultText := strconv.FormatInt(defaultValue, 10)
        // TODO cache or get all the configs at once?
        cmd := exec.Command("git", "config", "--get", "--default", defaultText, key)
        output, err :=</span> cmd.Output()
        if err != nil </span>{
                </span>return defaultValue, fmt.Errorf("error reading git config %s: %v", key, err)
        }</span>

        value := strings.TrimSpace(string(output))

        parsed, err :=</span> strconv.ParseInt(value, 10, 64)
        if err != nil </span>{
                </span>return defaultValue, fmt.Errorf("invalid int value for %s: &gt;%q&lt;", key, value)
        }</span>

</span>        if parsed &lt; 1 || parsed &gt; 500 {
                </span></span>return defaultValue, fmt.Errorf("invalid int value for %s: %d. Must be between 1 and 500", key, parsed)
        }</span>

</span>        <span class="cov9" title="335">return parsed, nil</span>
}

// GetProfile extracts the profile from the auth handler if available
// This is only needed for external APIs like g3cmd t<span class="cov6" title="36">hat require it
func (cl *IndexDClient) GetProfile() (string, error)</span><span class="cov6" title="36"> {
        if rh, ok := cl.AuthHandler.(*RealAuthHandler); ok {
                </span></span>return rh.Cred.Profile, nil
        }</span>
</span>        <span class="cov1" title="1">return "", fmt.Errorf("AuthHandler is not RealAuthHandler, cannot extract profile")</span>
}

func (cl *IndexDClient) DeleteRecordsByProject(projectId string) error {
        recs, err := c</span>l.ListObjectsByProject(projectId)
        if err != nil </span>{
                </span>return err
        }</span>
</span>        for rec := range recs {
</span></span>                for sumType, sum := range hash.ConvertHashInfoToMap(rec.Object.Checksums) </span>{
</span>                        if sumType == string(hash.ChecksumTypeSHA256) {
                                err := cl.Dele</span></span>teRecord(sum)
                                if err != nil </span>{
                                        cl.Logge</span>r.Println("DeleteRecordsByProject Error: ", err)
                                        continue</span>
                                }
                        }
                }
        <span class="cov0" title="0">}
</span>        <span class="cov0" title="0">return nil</span>
}

func (cl *IndexDClient) DeleteRecord(oid string) error {
        // get records by hash
        record, err :=</span> cl.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
        if err != nil </span>{
                </span>return fmt.Errorf("error getting records for OID %s: %v", oid, err)
        }</span>
</span>        if len(record) == 0 {
                </span></span>return fmt.Errorf("no records found for OID %s", oid)
        }</span>

        <span class="cov0" title="0">// Find a record that matches the project ID
        matchingRecord</span>, err := drsmap.FindMatchingRecord(record, cl.GetProjectId())
        if err != nil </span>{
                </span>return fmt.Errorf("error finding matching record for project %s: %v", cl.GetProjectId(), err)
        }</span>
</span>        if matchingRecord == nil {
                </span></span>return fmt.Errorf("no matching record found for project %s", cl.GetProjectId())
        }</span>

        <span class="cov0" title="0">// call helper to do the delete for a gen3 GUID</span>
        <span class="cov0" title="0">return cl.deleteIndexdRecord(matchingRecord.Id)</span>
}

func (cl *IndexDClient) deleteIndexdRecord(did string) error {
        // get the indexd record, can't use GetObject cause the DRS object doesn't contain the rev
        record, err :=</span> cl.getIndexdRecordByDID(did)
        if err != nil </span>{
                </span>return fmt.Errorf("could not query index record for did %s: %v", did, err)
        }</span>

        <span class="cov5" title="32">// delete indexd record using did and rev
        url := fmt.Sprintf("%s/index/index/%s?rev=%s", cl.Base.String(), did, record.Rev)
        delReq, err :=</span> retryablehttp.NewRequest("DELETE", url, nil)
        if err != nil </span>{
                </span>return err
        }</span>

        err = cl.AuthH</span>andler.AddAuthHeader(delReq.Request)
        if err != nil </span>{
                </span>return fmt.Errorf("error adding Gen3 auth header to delete record: %v", err)
        }</span>
        <span class="cov5" title="32">// set Content-Type header for JSON
        delReq.Header.Set("accept", "application/json")

        delResp, err :</span>= cl.HttpClient.Do(delReq)
        if err != nil </span>{
                </span>return err
        }</span>
        defer delResp.Body.Close()

        // response error handling
</span>        if delResp.StatusCode &gt;= 400 </span>{
                bodyBytes, readErr</span> := io.ReadAll(delResp.Body)
                if readErr != nil </span>{
                        </span>return fmt.Errorf("delete failed with status %s: could not read response body: %v", delResp.Status, readErr)
                }</span>
                bodyString := string(bodyBytes)
</span>                return fmt.Errorf("delete failed with status %s. Response body: %s", delResp.Status, bodyString)</span>
        <span class="cov5" title="32">}
</span>        <span class="cov5" title="18">return nil</span>
}

func (cl *IndexDClient) RegisterRecord(record *drs.DRSObject) (*drs.DRSObject, error) {
        // prolly could do cleanup but use register record
        indexdRecord, </span>err := indexdRecordFromDrsObject(record)
        if err != nil </span>{
                </span>return nil, fmt.Errorf("error converting DRS object to indexd record: %v", err)
        }</span>

</span>        <span class="cov0" title="0">return cl.RegisterIndexdRecord(indexdRecord)</span>
}

// GetDownloadURL implements DRSClient
func (cl *IndexDClient) GetDownloadURL(oid string) (*drs.AccessURL, error) {

        cl.Logger.Printf("Try to get download url for file OID %s", oid)

        // get the DRS object using the OID
        records, err :</span>= cl.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
        if err != nil </span>{
                cl.Logger.Printf("error getting DRS object for OID %s: %s", oid, err)
                </span>return nil, fmt.Errorf("error getting DRS object for OID %s: %v", oid, err)
        }</span>
</span>        <span class="cov6" title="36">return cl.getDownloadURLFromRecords(oid, records)</span>
}

func (cl *IndexDClient</span><span class="cov0" title="0">) getDownloadURLFromRecords(oid string, records []drs.DRSObject) (*drs.AccessURL, error) {
        if len(records) == 0 {
                cl.Logger.Printf("no DRS object found for OID %s", oid)
                </span></span>return nil, fmt.Errorf("no DRS object found for OID %s", oid)
        }</span>

        <span class="cov6" title="64">// Find a record that matches the client's project ID
        matchingRecord</span>, err := drsmap.FindMatchingRecord(records, cl.ProjectId)
        if err != nil </span>{
                cl.Logger.Printf("error finding matching record for project %s: %s", cl.ProjectId, err)
                </span>return nil, fmt.Errorf("error finding matching record for project %s: %v", cl.ProjectId, err)
        }</span>
</span>        if matchingRecord == nil {
                cl.Logger.Printf("no matching record found for project %s", cl.ProjectId)
                </span></span>return nil, fmt.Errorf("no matching record found for project %s", cl.ProjectId)
        }</span>

        cl.Logger.Printf("Matching record: %#v for oid %s", matchingRecord, oid)
        drsObj := matchingRecord

        // Check if access methods exist
</span>        if len(drsObj.AccessMethods) == 0 </span>{
                cl.Logger.Printf("no access methods available for DRS object %s", drsObj.Id)
                </span>return nil, fmt.Errorf("no access methods available for DRS object %s", drsObj.Id)
        }</span>

        <span class="cov6" title="64">// naively get access ID from splitting first path into :
        accessType := drsObj</span>.AccessMethods[0].Type
        if accessType == "" </span>{
                cl.Logger.Printf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0])
                </span>return nil, fmt.Errorf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0])
        }</span>
        did := drsObj.Id

        accessUrl, err</span> := cl.getDownloadURL(did, accessType)
        if err != nil </span>{
                </span>return nil, err
        }</span>

</span>        <span class="cov6" title="36">return &amp;accessUrl, nil</span>
}

// getDownloadURL gets a signed URL for the given DRS ID and accessType (eg s3)
func (cl *IndexDClient) getDownloadURL(did string, accessType string) (drs.AccessURL, error) {
        // get signed url
        a := *cl.Base
        a.Path = filepath.Join(a.Path, "ga4gh/drs/v1/objects", did, "access", accessType)

        req, err := re</span>tryablehttp.NewRequest("GET", a.String(), nil)
        if err != nil </span>{
                </span>return drs.AccessURL{}, err
        }</span>

        err = cl.AuthH</span>andler.AddAuthHeader(req.Request)
        if err != nil </span>{
                </span>return drs.AccessURL{}, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

        response, err </span>:= cl.HttpClient.Do(req)
        if err != nil </span>{
                </span>return drs.AccessURL{}, fmt.Errorf("error getting signed URL: %v", err)
        }</span>
</span>        defer func() {
</span></span>                if closeErr := response.Body.Close(); closeErr != nil </span>{
                        </span>log.Printf("error closing response body: %v", closeErr)
                }</span>
        }()

        accessUrl := drs.AccessURL{}

        // read full body so we can both decode and include it in any error
        bodyBytes, readErr</span> := io.ReadAll(response.Body)
        if readErr != nil </span>{
                </span>return drs.AccessURL{}, fmt.Errorf("unable to read response body: %v", readErr)
        }</span>

</span>        if err := cl.SConfig.Unmarshal(bodyBytes, &amp;accessUrl); err != nil {
                </span></span>return drs.AccessURL{}, fmt.Errorf("unable to decode response into drs.AccessURL: %v; body: %s", err, string(bodyBytes))
        }</span>

        <span class="cov7" title="132">// check if empty
</span>        if accessUrl.URL == "" {
                </span></span>return drs.AccessURL{}, fmt.Errorf("signed url is empty %#v %s", accessUrl, response.Status)
        }</span>

        cl.Logger.Printf("signed url retrieved: %s", response.Status)

</span>        return accessUrl, nil</span>
}

// RegisterFile implements DRSClient.
// It registers (or reuses) an indexd record for the oid, uploads the object if it
// is not already available in the bucket, and returns the resulting DRS object.
// When registration fails without force push, it retries once with force push
// enabled to reuse existing records and avoid duplicate uploads.
func (cl *IndexDClient) RegisterFile(oid string) (*drs.DRSObject, error) {
        return cl.registerFileWithUploader(oid, func(drsObject *drs.DRSObject, filePath string, file *os.File, g3 dataClient.Gen3Interface) error {
                if drsObject.Size &lt; cl.MultiPartThreshold {
                        cl.Logger.Printf("UploadSingle size: %d path: %s", drsObject.Size, filePath)
                        err := uploa</span></span></span>d.UploadSingle(context.Background(), g3.GetCredential().Profile, drsObject.Id, filePath, cl.BucketName, false)
                        if err != nil </span>{
                </span>                return fmt.Errorf("UploadSingle error: %s", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
        <span class="cov6" title="68">        }
                cl.Logger.Pri</span>ntf("MultipartUpload size: %d path: %s", drsObject.Size, filePath)
                err := upload.MultipartUpload(
                        context.TODO(),
                        g3,
                        common.FileUploadRequestObject{
                                FilePath:     filePath,
                                Filename:     filepath.Base(filePath),
                                GUID:         drsObject.Id,
                                FileMetadata: common.FileMetadata{},
                                Bucket:       cl.BucketName,
                        },
                        file, false,
                )
                if err != nil </span></span></span></span></span></span>{
                        return fmt.Erro</span>rf("MultipartUpload error: %s", err)
                }</span>
                ret</span>urn nil</span>
        })
}
</span>
// Re</span>gisterFileWithProgress registers and uploads a file while reporting bytes transferred.
func (cl *IndexDClient) RegisterFileWithProgress(oid string, reportBytes func(int64)) (*drs.DRSObject, error) <span class="cov6" title="36">{
        return cl.registerFileWithUploader(oid, func(drsObject *drs.DRSObject, filePath string, file *os.File, g3 dataClient.Gen3Interface) error </span><span class="cov5" title="18">{
                if drsObject.Size &lt; cl.MultiPartThreshold </span>{
                        cl.Logger.Printf("UploadSingle size: %d path: %s", drsObject.Size, filePath)
                        </span>if err := cl.uploadSingleWithProgress(context.Background(), g3, file, filePath, drsObject.Id, reportBytes); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov4" title="9">return nil</span>
        <span class="cov6" title="68">        }
                cl.Logger.Pri</span>ntf("MultipartUpload size: %d path: %s", drsObject.Size, filePath)
                err := multipartUploadWithProgress(
                        context.TODO(),
                        g3,
                        common.FileUploadRequestObject{
                                FilePath:     filePath,
                                Filename:     filepath.Base(filePath),
                                GUID:         drsObject.Id,
                                FileMetadata: common.FileMetadata{},
                                Bucket:       cl.BucketName,
                        },
                        file,
                        reportBytes,
                )
                if err != nil </span>{
                        return fmt.Er</span></span></span></span></span></span>rorf("MultipartUpload error: %s", err)
                }</span>
                return nil
        })
}

func (cl *Index</span></span></span></span><span class="cov0" title="0">DClient) registerFileWithUploader(oid string, uploadFile func(drsObject *drs.DRSObject, filePath string, file *os.File, g3 dataClient.Gen3Interface) error) (*drs.DRSObject, error) {
        cl.Logger.Printf("register file started for oid: %s", oid)

</span>        // load the DRS object from oid created by prepush
        drsObject, err := drsmap.DrsInfoFromOid(oid)
        if err != nil </span>{
                return nil, f</span></span>mt.Errorf("error getting drs object for oid %s: %v", oid, err)
        }</span>

</span>        // convert to </span><span class="cov0" title="0">indexd record
        indexdObj, err := indexdRecordFromDrsObject(drsObject)
        i</span>f err != nil </span>{
                return nil, f</span>mt.Errorf("error converting DRS object oid %s to indexd record: %v", oid, err)
        }</span></span>

</span></span>        // save the indexd record
        _,</span> err = cl.RegisterIndexdRecord(indexdObj)
        if err != nil </span>{
                // handle "al</span>ready exists" error ie upsert behavior
                if strings.Contains(err.Error(), "already exists") </span>{
                        if !cl.Upsert {
</span></span>                                cl.Logger.Printf("indexd record already exists, proceeding for oid %s: did: %s err: %v", oid, indexdObj.Did, err)
                        } else {
</span></span></span></span>                                </span>cl.Logger.Printf("indexd record already exists, deleting and re-adding for oid %s: did: %s err: %v", oid, indexdObj.Did, err)
                                err = cl.deleteIndexdRecord(indexdObj.Did)
                                if err != nil </span></span>{
                                        return nil, f</span>mt.Errorf("error deleting existing indexd record oid %s: did: %s err: %v", oid, indexdObj.Did, err)
                                }
                                _, err = cl.RegisterIndexdRecord(indexdObj)
                                if err != nil {
                                        return nil, fmt.Errorf("error re-saving indexd record after deletion: oid %s: did: %s err: %v", oid, indexdObj.Did, err)
                                }
                        }

                } else {
                        return nil, fmt.Errorf("error saving oid %s indexd record: %v", oid, err)
                }
        }

        // Now attempt </span></span></span></span></span></span></span></span></span><span class="cov0" title="0">to upload the file if not already available
        downloadable, err := cl.isFileDownloadable(drsObject)
        if</span> err != nil </span>{
                return nil, f</span>mt.Errorf("error checking if file is downloadable: oid %s %v", oid, err)
        }</span>
        i</span></span>f downloadable </span><span class="cov4" title="14">{
                cl.Logger.Printf("file %s is already available for download, skipping upload", oid)
                return drsObject, nil
        }</span></span>

</span></span>        // Proceed to upload the file -------------------
        p</span>rofile, err := cl.GetProfile()
        if err != nil </span>{
</span>                return nil, f</span>mt.Errorf("error getting profile for upload: %v", err)
        }</span>
        /</span></span>/ TODO - should we deprecate this gen3-client style logger in favor of drslog.Logger?
        <span class="cov6" title="68">// TODO - or can we "wrap it" so both work together?
        logger, closer := logs.New(profile, logs.WithBaseLogger(cl.Logger))
        defer closer()</span>
        // Instantiate interface to Gen3
        // TODO - Can we reuse this interface to avoid repeated config parsing and most likely repeated token refresh?
        // TODO - Can we reuse Auth to ensure we are not repeatedly refreshing tokens?
        g3, err := dataClient.NewGen3Interface(profile, logger)
        if err != nil </span>{
                return nil, f</span></span></span>mt.Errorf("error creating Gen3 interface: %v", err)
</span>        }</span>

</span>        filePath, err </span>:= drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, oid)
        if err != nil </span>{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span></span></span>
        f</span>ile, err := os.Open(filePath)
        if err != nil </span>{
</span>                return nil, f</span>mt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        d</span>efer func(file *os.File) </span><span class="cov4" title="14">{
                err := file.Close()
                if err != nil </span>{
                        cl.Logger.Printf("warning: error closing file %s: %v", filePath, err)
                }
        }(file)

</span></span></span></span></span>        if err := uploadFile(drsObject, filePath, file, g3); err != nil {
                </span></span>return nil, err
        }</span></span>
        r</span>eturn drsObject, nil</span>

</span></span>}

</span>func (cl *IndexDClient) uploadSingleWithProgress(ctx context.Context, g3 dataClient.Gen3Interface, file *os.File, filePath string, guid string, reportBytes func(int64)) error <span class="cov3" title="7">{
        filename := filepath.Base(filePath)
        uploadURL, err := cl.getUploadURL(ctx, g3, guid, filename)
        if err != nil </span></span>{
                return err
</span></span>        }</span>

</span>        stat, err := file.Stat()
</span>        if err != nil </span>{
                </span>return fmt.Er</span>rorf("failed to stat file: %w", err)
        }</span>

</span>        req, err := http.NewRequestWithContext(ctx, http.MethodPut, uploadURL, </span>&amp;progressReadCloser{ReadCloser: file, report: reportBytes})
        if err != nil </span>{
                </span>return err
</span>        }</span>
        r</span></span>eq.ContentLength = stat.Size()

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span>{
                return err
</span>        }</span>
        defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK {
                body, _ := io</span></span></span>.ReadAll(io.LimitReade</span>r(resp.Body, 1024))
                return fmt.Errorf("single-part upload failed (%d): %s", resp.StatusCode, body)
        }</span></span>
        r</span>eturn nil</span>
}<span class="cov1" title="2">
</span>
func (cl *IndexDClient) getUploadURL(ctx context.Context, g3 dataClient.Gen3Interface, guid string, filename string) (string, error) {
        endPointPostfix := common.FenceDataUploadEndpoint + "/" + guid + "?file_name=" + url.QueryEscape(filename)
        if cl.BucketName != "" {
                endPointP</span></span>ostfix += "&amp;b</span>ucket=" + url.QueryEscape(cl.BucketName)
        }</span>

        cred := g3.GetCredential()
        resp, err := g3.Do(
                ctx,
                &amp;request.RequestBuilder{
                        Url:     c</span></span>red.APIEndpoint + endPointPostfix,
                        Headers: map[string]string{common.HeaderContentType: common.MIMEApplicationJSON},
                        Token:   cred.AccessToken,
                        Method:  http.MethodGet,
                },
        )
        if err != nil </span>{
                return "", fm</span></span></span>t.Errorf("upload error: %w", err)
        }</span>

        msg, err := g3.ParseFenceURLResponse(resp)
        if err != nil {
                return "", fmt.Errorf("upload error: %w", err)
        }
</span></span></span></span></span>        i</span>f msg.URL == "" {
                return </span></span>"", fmt.Errorf("upload error: error in generating presigned URL for %s", filename)
        }</span></span>
        r</span>eturn msg.URL, nil</span>
}<span class="cov1" title="2">
</span>
</span>func (cl *IndexDClient) isFileDownloadable(drsObject *drs.DRSObject) (bool, error) {
        if drsOb</span>ject == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("drsObject is nil")
        }</span></span>
        i</span>f len(drsObject.AccessMethods) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Printf("DRS object %s has no access methods; proceeding to upload", drsObject.Id)
                return false, nil
        }</span></span>
        cl.Logger.Printf</span>("checking if %s file is downloadable %v %v %v", drsObject.Id, drsObject.AccessMethods[0].AccessID, drsObject.AccessMethods[0].Type, drsObject.AccessMethods[0].AccessURL)
</span>        signedUrl, err := cl.getDownloadURL(drsObject.Id, drsObject.AccessMethods[0].Type)
        if err != nil </span>{
</span>                cl.Logger.Pri</span>ntf("error getting signed URL for file with oid %s: %s", drsObject.Id, err)
                return false, fmt.Errorf("error getting signed URL for file with oid %s: %s", drsObject.Id, err)
        }</span>
        i</span></span>f signedUrl.URL == "" {
                return </span></span>false, nil
        }</span></span>

</span>        <span class="cov5" title="28">err = utils.CanDownloadFile(signedUrl.URL)
        if err != nil </span>{
</span>                cl.Logger.Pri</span>ntf("file with oid %s does not exist in bucket: %s", drsObject.Id, err)
                return false, nil
        }</span></span>
        c</span>l.Logger.Printf("file with oid %s exists in bucket", drsObject.Id)
        return true, nil</span>
}
</span></span>
</span>func (cl *IndexDClient) GetObject(id string) (*drs.DRSObject, error) <span class="cov3" title="5">{

        a := *cl.Base
        a.Path = filepath.Join(a.Path, "ga4gh/drs/v1/objects", id)

        req, err := retryablehttp.NewRequest("GET", a.String(), nil)
        if err != nil </span></span></span>{
                return nil, e</span></span>rr
        }</span>

</span></span>        <span class="cov3" title="5">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span></span>{
                return nil, f</span>mt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

</span></span>        response, err := cl.HttpClient.Do(req)
        if</span> err != nil </span>{
                return nil, e</span>rr
        }</span>
        d</span>efer response.</span>Body.Close()

        if response.Status == "404" </span>{
                return nil, fmt.Errorf("%s </span>not found", id)
        }</span>

</span>        in := drs.OutputObject{}
        if err := cl.SConfig.NewDecoder(response.Body).Decode(&amp;in); err != nil {
                return nil, err
        }
        return drs.ConvertOutputObjectToDRSObject(&amp;in), nil

}
</span></span></span></span></span></span></span>
fu</span>nc (cl *IndexDClient) ListObjectsByProject(projectId string) (chan drs.DRSObjectResult, error) <span class="cov3" title="5">{
        const PAGESIZE = 50
        pageNum := 0

        cl.Logger.Print("Getting DRS objects from indexd")
        resourcePath, err := utils.ProjectToResource(projectId)
        if err != nil </span>{
                return nil, e</span>rr
        }

        a := *cl.Base
</span></span></span>        a.Path = filepath.Join(a.Path, "index/index")

        out := make(chan drs.DRSObjectResult, PAGESIZE)

        go func() </span></span>{
                defer clo</span>se(out)

                // This will hold all errors encountered during the loop
                var resultErr</span>ors *multierror.Error
                active := true

                for active </span>{
                        req, err :</span></span>= retryablehttp.NewRequest("GET", a.String(), nil)
                        if err != nil </span>{
                                resultError</span>s </span>= multierror.Append(resultErrors, fmt.Errorf("request creation: %w", err))
                                break</span>
                </span>        }
</span>
                        q := req.URL.Query()
                        q.Add("authz", resourcePath)
                        q.Add("limit", fmt.Sprintf("%d", PAGESIZE))
                        q.Add("page", fmt.Sprintf("%d", pageNu</span>m))
                        req.URL.RawQuery = q.Encode()

                        if err := cl.AuthHandler.AddAuthHeader(req.Request); err != nil </span>{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("auth</span></span>: %w", err))
                                break</span>
                        }

                        response, er</span></span>r := cl.HttpClient.Do(req)
                        if err != nil </span>{
                </span>                resultErrors </span>= multierror.Append(resultErrors, fmt.Errorf("http call: %w", err))
                                break</span>
                        }
</span></span>
                        // Read body and close immediately
                        <span class="cov4" title="9">body, err := io.ReadAll(response.Body)
                        response.Body.Close()

                        if err != nil </span>{
</span>                                resultErrors </span>= multierror.Append(resultErrors, fmt.Errorf("read body: %w", err))
                </span>                break</span>
                        }
</span>
        <span class="cov0" title="0">                if response.StatusCode != http.StatusOK {
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("api error %d: %s", response.StatusCode, string(body)))
                                break
</span></span></span></span>                        }
</span>
</span>                        <span class="cov3" title="8">page := &amp;ListRecords{}
                        if err := cl.SConfig.Unmarshal(body, &amp;page); err != nil </span>{
                                resultError</span>s = multierror.Append(resultErrors, fmt.Erro</span>rf("unmarshal: %w", err))
                                break</span>
                </span>        }
</span>
        <span class="cov0" title="0">                if len(page.Records) == 0 {
                                active = false
                        }
</span></span></span></span>
</span>                </span>        <span class="cov3" title="8">for _, elem := range page.Records </span><span class="cov3" title="8">{
                                drsObj, err := elem.ToIndexdRecord().ToDrsObject()
                                if err != nil </span>{
                                        // Append and keep going,</span></span> or break if this is fatal
</span>                                        resultErrors = multierror.Append(resultErrors, err)
                                        continue</span>
                                }
</span></span>                        </span>        <span class="cov3" title="8">out &lt;- drs.DRSObjectResult{Object: drsObj}</span>
                <span class="cov0" title="0">        }
                        pageNum++
</span></span></span>                }<span class="cov0" title="0">
</span>
</span>                // If we accumulated any errors, send the final concatenated result
                <span class="cov3" title="5">if resultErrors != nil </span><span class="cov1" title="1">{
                        out &lt;- drs.DRSObjectResult{Error: resultErrors.ErrorOrNil()}
                }</span></span>
        }(</span>)

        return out, nil
}

</span></span></span>// given indexd record, constructs a new indexd record
// implements /index/index POST
fu</span>nc (cl *IndexDClient) RegisterIndexdRecord(indexdObj *IndexdRecord) (*drs.DRSObject, error) <span class="cov6" title="42">{
        indexdObjForm := IndexdRecordForm{
                IndexdRecord: *indexdObj,
                Form:         "object",
        }

        jsonBytes, err := sonic.Marshal(indexdObjForm)
        if err != nil </span></span>{
                return nil, e</span></span>rr
        }

        cl.Logger.Prin</span></span></span>tf("writing IndexdObj: %s", string(jsonBytes))

        // register DRS object via /index POST
        // (setup post request to indexd)
        endpt := *cl.Base
        endpt.Path = filepath.Join(endpt.Path, "index", "index")

        req, err := retryablehttp.NewRequest("POST", endpt.String(), bytes.NewBuffer(jsonBytes))
        if err != nil </span></span>{
                return nil, e</span></span></span>rr
        }</span>
        /</span>/ set Content-Type header for JSON
        req.Header.Set("accept", "application/json")
        req.Header.Set</span>("Content-Type", "application/json")

        // add auth token
        err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span>{
                return nil, f</span></span>mt.Errorf("error adding Gen3 auth header: %v", err)
        }

        cl.Logger.Printf("POST request created for indexd: %s", endpt.String())
        response, err := cl.HttpClien</span></span></span>t.Do(req)
        if err != nil </span>{
                return nil, e</span>rr
</span>        }</span>
        d</span>efer response.Body.Close()

        // check and see if the response status</span> is OK
        drsId := indexdObjForm.Did
        if response.StatusCode != http.StatusOK </span>{
                body, _ := io.ReadAll(response.Body)
</span></span>                return nil, fmt.Errorf("failed to register DRS ID %s: %s", drsId, body)
        }</span></span>
        c</span>l.Logge</span>r.Printf("POST successful: %s", response.Status)

        // removed re-query return DRS object (was missing access method authorization anyway)
        drsObj, err := indexdRecordToDrsObject(indexdObj)
        if err != nil </span>{
                return nil, f</span></span></span>mt.Errorf("error converting indexd record to DRS object: %w %v", err, indexdObj)
        }</span>
        r</span>eturn drsObj, nil</span>
}
</span></span>
// </span>implements /index{did}?rev={rev} DELETE
fu<span class="cov6" title="64">nc (cl *IndexDClient) Dele</span>teIndexdRecord(did string) error <span class="cov0" title="0">{
        // get the indexd record, can't use GetObject cause the DRS object doesn't contain the rev
        record, err := cl.GetIndexdRecordByDID(did)
        if err != nil </span>{
                return fmt.Er</span></span>rorf("could not query index record for did %s: %v", did, err)
        }</span>

</span>        // delete indexd record using did and rev
        <span class="cov0" title="0">url := fmt.Sprintf("%s/index/index/%s?rev=%s", cl.Base.String(), did, record.Rev)
        delReq, err := retryablehttp.NewRequest("DELETE", url, nil)
        if err != nil </span></span>{
                return err
</span></span>        }</span>

</span>        err = cl.AuthHandler.AddAuthHeader(delReq.Request)
        if err != nil {
                return fmt.Errorf("error adding Gen3 auth header to delete record: %v", err)
        }
</span></span></span></span>        /</span>/ set Content-Type header for JSON
        d</span>elReq.Header.Set("accept", "application/json")
        delResp, err := cl.HttpClient.Do(delReq)
        if err != nil </span>{
                return err
</span></span>        }</span>
        d</span></span>efer delResp.Body.Close()

</span>        if delResp.StatusCode &gt;= 400 </span>{
                bodyBytes, readErr := io.Rea</span>dAll(delResp.Body)
                if readErr != nil {
                        return fmt.Errorf("dele</span></span>te failed with status %s: could not read response body: %v", delResp.Status, readErr)
</span>                }</span>
                b</span>odyString </span>:= string(bodyBytes)
                return fmt.Errorf("delete failed with status %s. Response body: %s", delResp.Status, bodyString)</span>
</span>        }
</span></span>        <span class="cov0" title="0">return nil</span>
}<span class="cov0" title="0">
</span></span>
// implements /index/index?hash={hashType}:{hash} GET
func (cl *IndexDClient) GetObjectByHash(sum *hash.Checksum) ([]drs.DRSObject, error) <span class="cov5" title="28">{
        // setup get request to indexd
        url := fmt.Sprintf("%s/index/index?hash=%s:%s", cl.Base.String(), sum.Type, sum.Checksum)
        cl.Logger.Printf("Querying indexd at %s", url)
        req, err := retryablehttp.NewRequest("GET", url, nil)
        if err != nil </span></span>{
                cl.Logger.Pri</span>ntf("http.NewRequest Error: %s", err)
                return nil, err
        }</span>
        c</span>l.Logger.Printf("Looking for files with hash %s:%s", sum.Type, sum.Checksum)

        err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil {
                return nil, fmt.Errorf("unable to add authentication when searching for object: %s:%s. More on the error: %v", sum.Type, sum.Checksum, err)
        }
        req.Header.Set("accept", "application/json")

        // run request and do checks
        resp, err </span></span></span></span></span>:= cl.HttpClient.Do(req)
        if err != nil </span>{
                return nil, f</span>mt.Errorf("unable to check if server has files with hash %s:%s: %v", sum.Type, sum.Checksum, err)
        }
</span></span>        d</span>efer resp.Body.Close()

        if resp.StatusCo</span>de != http.StatusOK </span>{
                body, _ := io.ReadAll(resp.Body)
</span>                return nil, fmt.Errorf("failed to query indexd for %s:%s. Error: %s, %s", sum.Type, sum.Checksum, resp.Status, string(body))
        }

</span></span></span>        // unmarshal response body
        <span class="cov5" title="28">records := ListRecords{}
        err = cl.SConfig.NewDecoder(resp.Body).Decode(&amp;records)
        if err != nil </span>{
                return nil, fmt.Errorf("error unmarshaling (%s:%s): %v", sum.Type, sum.Checksum, err)
        }
        // log how many records were found
        cl.Logger.Printf</span></span></span></span>("Found %d indexd record(s) matching the hash %v", len(records.Records), records)

        out := make([]drs.DRSObject, 0, len(records.Records))

        // if no records found, return empty slice
        if len(records.Records) == 0 </span></span>{
                return out, nil
</span>        }</span>

</span>        resourcePath, _ </span>:= utils.ProjectToResource(cl.GetProjectId())

        for _, record := range records.Records </span>{
                // skip records that do not authorize this client/project
                fo</span></span>und := false
                for _, a := range record.Authz </span>{
                        if a == resourcePath {
</span></span>                                found = true
                                break
</span></span></span>                        }
</span>                }
                if !found {
                        c</span></span>ontinue</span>
</span>                }
</span></span>
                drsObj, err := indexdRecordToDrsObject(record.ToIndexdRecord())
                if err != nil {
                        r</span></span>eturn nil, f</span>mt.Errorf("error converting indexd record to DRS object: %w", err)
                }</span>
                o</span>ut = append(out, *drsObj)</span>
        }<span class="cov3" title="8">
</span>
        return out, nil
</span></span>}

// GetProjectSample retrieves a sample of DRS objects for a given project (limit: 1 by default)
// R</span></span>eturns up to 'limit' records for preview purposes before destructive operations
fun<span class="cov0" title="0">c (cl *IndexDClient) GetProjectSample</span><span class="cov0" title="0">(projectId string, limit int) ([]drs.DRSObject, error) {
        if limit &lt;= 0 {
                li</span></span>mit = 1
        }</span></span>

</span></span>        cl.</span>Logger.Printf("Getting sample DRS objects from indexd for project %s (limit: %d)", projectId, limit)

        // Reuse ListObjectsByProject and collect first 'limit' results
        objChan, err := cl.ListObjectsByProject(projectId)
        if err != nil </span>{
                return nil, e</span></span></span>rr
        }</span>

</span></span>        <span class="cov0" title="0">result := make([]drs.DRSObject, 0, limit)
        for objResult := range objChan </span>{
                if objResult.Error != nil {
</span></span>                        return nil, objResult.Error
                }</span></span>
                r</span>esult = append(result, *objResult.Object)

</span>                // Stop after collecting enough samples
                if len(result) &gt;= limit </span>{
                        // Drain remaining resu</span></span>lts to avoid goroutine leak
                        go func() </span>{
                                for range</span> objChan </span>{
                                }
                        }()
                        break
                }
        }

        cl.Logger.Printf("Retrieved %d sample record(s)", len(result))
        return result, nil
}

// implements /index/index?authz={reso</span></span></span></span></span></span></span></span><span class="cov0" title="0">urce_path}&amp;start={start}&amp;limit={limit} GET
func (cl *IndexDClient) ListObjects() (chan drs.DRSObjectResult, error) {

        cl.Logger.Print("Getting DRS objects from in</span>dexd")

        a := *cl.Base
        a.Path = filepath.Join(a.Path, "ga4gh/drs/v1/objects")

        out := make(chan drs.DRSObjectResult, 10)

        LIMIT := 50
        pageNum := 0

        go func() </span>{
                defer clo</span></span></span>se(out)
                active := true
                for active </span></span>{
                        // setup r</span></span>equest
                        req, err := retryablehttp.NewRequest("GET", a.String(), nil)
                        if err != nil </span>{
                                cl.Logger.Pri</span></span>ntf("error: %s", err)
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span></span>

</span></span>                        q := req.URL.Query()
</span>                        q.Add("limit", fmt.Sprintf("%d", LIMIT))
                        q.Add("page", fmt.Sprintf("%d", pageNum))
                        req.URL.RawQuery = q.Encode()

                        err = cl.AuthHandler.AddAuthHeader(req.Request)
                        if err != nil </span></span>{
                                cl.Logger.Pri</span></span>ntf("error contacting %s : %s", req.URL, err)
</span>                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span></span>

</span>                        // execute request with error checking
                        response, err := cl.HttpClient.Do(req)

                        if err != nil {
                                cl.Logger.Printf("error: %s", err)
                                out &lt;- drs.</span></span></span>DRSObjectResult{Error: err}
                                return
                        }</span>

</span></span>                        <span class="cov0" title="0">defer response.Body.Close()
                        body, err := io.ReadAll(response.Body)
                        if err != nil </span>{
                                cl.Logger.Printf("error: %s", err)
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
</span></span>                        }</span>
                        i</span>f response.StatusCode != http.StatusOK {
</span></span>                                cl.Logger.Printf("%d: check that your credentials are valid \nfull message: %s", response.StatusCode, body)
                                out &lt;- drs.DRSObjectResult{Error: fmt.Errorf("%d: check your credentials are valid, \nfull message: %s", response.StatusCode, body)}
                                return
                        }</span></span>

</span>                        // return pa</span><span class="cov0" title="0">ge of DRS objects
                        page := &amp;drs.DRSPage{}
                </span>        err = cl.SConfig.Unmarshal(body, &amp;page)
                        if err != nil </span>{
                                cl.Logger.Pri</span>ntf("error: %s (%s)", err, body)
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
</span>                        }</span>
                        f</span>or _, elem := range page.DRSObjects {
                </span></span>                out &lt;- drs.DRSObjectResult{Object: &amp;elem}
                        }</span></span>
                        i</span>f len(page.DRSObjects) == 0 {
                                active = false
                        }
                        pageNum++
                }
</span></span></span></span></span></span></span>
                </span><span class="cov0" title="0">cl.Logger.Printf("total pages retrieved: %d", pageNum)</span>
        }<span class="cov0" title="0">()
</span>        <span class="cov0" title="0">return out, nil</span>
}
</span></span>
// UpdateRecord updates an existing indexd record by GUID using the PUT /index/index/{guid} endpoint
// Supports updating: URLs, name (file_name), description (metadata), version, and authz
func (cl *IndexDClient) UpdateRecord(updateInfo *drs.DRSObject, did string) (*<span class="cov0" title="0">drs.DRSObject, error) {
        // Get current revision from existing record
        record, err := cl.GetIndexdRecordByDID(did)
        if err != nil {
                return nil, f</span></span></span>mt.Errorf("could not retrieve existing record for DID %s: %v", did, err)
        }</span>

</span>        // Build update payload starting with existing record values
        <span class="cov0" title="0">updatePayload := UpdateInputInfo{
                URLs:     rec</span>ord.URLs,
                FileName: record.FileName,
                Version:  record.Version,
                Authz:    record.Authz,
                ACL:      record.ACL,
                Metadata: record.Metadata,
        }

        // Apply updates from updateInfo
        // Update URLs by appending new access methods (deduplicated)
        if len(updateInfo.AccessMethods) &gt; 0 </span>{
                // Collect new URLs from access meth</span></span></span></span>ods
</span>                newURLs := make([]string, 0, len(updateInfo.AccessMethods))
                for _, a := range updateInfo.AccessMethods </span>{
                </span>        newURLs = append(newURLs, a.AccessURL.URL)</span>
                }</span>
                u</span>pdatePayload.URLs = utils.AddUnique(updatePayload.URLs, newURLs)

</span>                // Append authz from access methods (deduplicated)
                authz := indexdAuthzFromDrsAccessMethods(updateInfo.AccessMethods)
                updatePayload.Authz = utils.AddUnique(updatePayload.Authz, authz)</span>
        }
</span></span></span>
        // Update name (maps to file_name in indexd)
        <span class="cov0" title="0">if updateInfo.Name != "" </span><span class="cov0" title="0">{
                updatePayload.FileName = updateInfo.Name
        }</span>
</span></span>
</span>        /</span>/ Update version
        <span class="cov0" title="0">if updateInfo.Version != "" </span><span class="cov0" title="0">{
                updatePayload.Version = updateInfo.Version
        }</span></span>

</span>        // Update description (stored in metadata)
        if updateInfo.</span>Description != "" </span>{
                if updatePayload.Metadata == nil {
                </span></span></span>        updatePayload.Metadata = make(ma</span>p[string]any)
                }</span>
                u</span>pdatePayload.Metadata["description"] = updateInfo.Description
        }

        jsonBytes, err := cl.SConfig.Marshal(updatePayload)
        if err != nil {
                return nil, fmt.Errorf("error marshaling indexd object form: %v", err)
        }

        cl.Logger.Printf("Prepared updated indexd object for DID %s: %s", did, string(jsonBytes))

        // prepare URL
        updateURL := fmt.Sprintf("%s/index/index/%s?rev=%s", cl.Base.String(), did, record.Rev)

        req, err := retryab</span></span></span></span></span></span></span>lehttp.NewRequest("PUT", updateURL, bytes.NewBuffer(jsonBytes))
        if err != nil </span>{
                return nil, f</span>mt.Errorf("error creating PUT request: %v", err)
        }</span>

</span>        // Set required headers
        req.Header.Set("accept", "application/json")
        req.Header.Set("Content-Type", "application/json")

</span>        err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span>{
                return nil, f</span></span>mt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

</span></span>        cl.Logger.Printf("PUT request created for indexd update: %s", updateURL)

</span>        // Execute the request
        response, err := cl.HttpClient.Do(req)
        if err != nil </span>{
                return nil, f</span></span>mt.Errorf("error executing PUT request: %v", err)
        }</span>
        d</span>efer response.Body.Close()

        // Check response status
        if response.StatusCode != http.StatusOK </span>{
</span>                body, _ := io.ReadAll(response.Body)
</span>                return nil, fmt.Errorf("failed to update indexd record %s: status %d, body: %s", did, response.StatusCode, string(body))
        }</span></span>

</span>        <span class="cov5" title="32">cl.Logger.Printf("PUT request successful: %s", response.Status)

</span>        // Query and return the updated DRS object
        updatedDrsObj, err := cl.GetObject(did)
        if err != nil </span>{
                return nil, f</span></span>mt.Errorf("error retrieving updated DRS object: %v", err)
        }</span></span>

</span>        <span class="cov0" title="0">cl.Logger.Printf("Successfully updated and retrieved DRS object: %s", did)
        return updatedDrsObj, nil</span>
}
</span>
// Helper function to get indexd record by DID (similar to existing pattern in DeleteIndexdRecord)
func (cl *IndexDClient) GetIndexdRecordByDID(did string) (*OutputInfo, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/index/%s", cl.Base.String(), did)

        req, err := retryablehttp.NewRequest("GET", url, nil)
        if err != nil </span>{
                return nil, e</span>rr
        }</span>

</span>        <span class="cov0" title="0">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span>{
                return nil, f</span>mt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>
        r</span>eq.Request.Header.Set("accept", "application/json")

        resp, err := cl.HttpClient.Do(req)
        if err != nil </span>{
                return nil, e</span>rr
        }</span>
        d</span>efer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span>{
                body, _ := io.ReadAll(resp.Body)
</span>                return nil, fmt.Errorf("failed to get record: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

</span>        <span class="cov0" title="0">record := &amp;OutputInfo{}
        if err := cl.SConfig.NewDecoder(resp.Body).Decode(record); err != nil </span>{
                return nil, fmt.Errorf("error decoding response body: %v", err)
</span>        }</span>

</span>        <span class="cov0" title="0">return record, nil</span>
}<span class="cov0" title="0">
</span>
func (cl *IndexDClient) BuildDrsObj(fileName string, checksum string, size int64, drsId string) (*drs.DRSObject, error) <span class="cov5" title="28">{
        bucket := cl.BucketName
        if bucket == "" </span>{
                return nil, fmt</span>.Errorf("error: bucket name is empty in config file")
        }</span>

</span>        //TODO: support other storage backends
        <span class="cov5" title="28">fileURL := fmt.Sprintf("s3://%s", filepath.Join(bucket, drsId, checksum))

        authzStr, err := utils.ProjectToResource(cl.GetProjectId())
        if err != nil </span>{
                return nil, e</span>rr
        }</span>
        a</span>uthorizations := drs.Authorizations{
                Value: authzStr,
        }

        // create DrsObj
        DrsObj := drs.DRSObject{
                Id:   drsId,
                Name: fileName,
                // TODO: ensure that we can retrieve the access method during submission (happens in transfer)
                AccessMethods: []drs.AccessMethod{{Type: "s3", AccessURL: drs.AccessURL{URL: fileURL}, Authorizations: &amp;authorizations}},
                Checksums:     hash.HashInfo{SHA256: checksum},
                Size:          size,
        }

        return &amp;DrsObj, nil</span>
}
</span>
// Helper function to get indexd record by DID (similar to existing pattern in DeleteIndexdRecord)
func (cl *IndexDClient) getIndexdRecordByDID(did string) (*OutputInfo, error) <span class="cov4" title="14">{
        url := fmt.Sprintf("%s/index/%s", cl.Base.String(), did)

        req, err := retryablehttp.NewRequest("GET", url, nil)
        if err != nil </span>{
                return nil, e</span>rr
        }</span>

</span>        <span class="cov4" title="14">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span>{
                return nil, f</span>mt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>
        r</span>eq.Header.Set("accept", "application/json")

        resp, err := cl.HttpClient.Do(req)
        if err != nil </span>{
                return nil, e</span>rr
        }</span>
        d</span>efer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span>{
                body, _ := io.ReadAll(resp.Body)
</span>                return nil, fmt.Errorf("failed to get record: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

</span>        <span class="cov4" title="14">record := &amp;OutputInfo{}
        if err := cl.SConfig.NewDecoder(resp.Body).Decode(record); err != nil </span>{
                return nil, fmt.Errorf("error decoding response body: %v", err)
</span>        }</span>

</span>        <span class="cov4" title="14">return record, nil</span>
}<span class="cov2" title="4">
</pre>
		
		<pre class="file" id="file7" style="display: none">package indexd_client

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "sort"
        "strings"
        "sync"

        dataClient "github.com/calypr/data-client/client/client"
        "github.com/calypr/data-client/client/common"
        req "github.com/calypr/data-client/client/request"
        "github.com/calypr/data-client/client/upload"
)

type progressReader struct {
        reader io.Reader
        report func(int64)
}

func (p *progressReader) Read(buf []byte) (int, error) <span class="cov10" title="4522">{
        n, err := p.reader.Read(buf)
        if n &gt; 0 &amp;&amp; p.report != nil </span><span class="cov9" title="4515">{
                p.report(int64(n))
        }</span>
        <span class="cov10" title="4522">return n, err</span>
}

func multipartUploadWithProgress(ctx context.Context, g3 dataClient.Gen3Interface, request common.FileUploadRequestObject, file *os.File, reportBytes func(int64)) error <span class="cov3" title="7">{
        g3.Logger().Printf("File Upload Request: %#v\n", request)

        stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot stat file: %w", err)
        }</span>

        <span class="cov3" title="7">fileSize := stat.Size()
        if fileSize == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("file is empty: %s", request.Filename)
        }</span>

        <span class="cov3" title="7">uploadID, finalGUID, err := initMultipartUpload(ctx, g3, request, request.Bucket)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initiate multipart upload: %w", err)
        }</span>

        <span class="cov3" title="7">key := fmt.Sprintf("%s/%s", finalGUID, request.Filename)
        g3.Logger().Printf("Initialized Upload: ID=%s, Key=%s\n", uploadID, key)

        optimalChunkSize := func(fSize int64) int64 </span><span class="cov3" title="7">{
                if fSize &lt;= 512*common.MB </span><span class="cov3" title="7">{
                        return 32 * common.MB
                }</span>
                <span class="cov0" title="0">chunkSize := fSize / common.MaxMultipartParts
                if chunkSize &lt; common.MinChunkSize </span><span class="cov0" title="0">{
                        chunkSize = common.MinChunkSize
                }</span>
                <span class="cov0" title="0">return ((chunkSize + common.MB - 1) / common.MB) * common.MB</span>
        }

        <span class="cov3" title="7">chunkSize := optimalChunkSize(fileSize)
        numChunks := int((fileSize + chunkSize - 1) / chunkSize)

        chunks := make(chan int, numChunks)
        for i := 1; i &lt;= numChunks; i++ </span><span class="cov3" title="7">{
                chunks &lt;- i
        }</span>
        <span class="cov3" title="7">close(chunks)

        var (
                wg           sync.WaitGroup
                mu           sync.Mutex
                parts        []upload.MultipartPartObject
                uploadErrors []error
        )

        httpClient := &amp;http.Client{Transport: http.DefaultTransport}

        worker := func() </span><span class="cov5" title="70">{
                defer wg.Done()

                for partNum := range chunks </span><span class="cov3" title="7">{
                        offset := int64(partNum-1) * chunkSize
                        size := chunkSize
                        if offset+size &gt; fileSize </span><span class="cov3" title="7">{
                                size = fileSize - offset
                        }</span>

                        <span class="cov3" title="7">section := io.NewSectionReader(file, offset, size)

                        url, err := generateMultipartPresignedURL(ctx, g3, key, uploadID, partNum, request.Bucket)
                        if err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                uploadErrors = append(uploadErrors, fmt.Errorf("URL generation failed part %d: %w", partNum, err))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov3" title="7">reader := &amp;progressReader{reader: section, report: reportBytes}
                        etag, err := uploadPartWithClient(ctx, httpClient, url, reader, size)
                        if err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                uploadErrors = append(uploadErrors, fmt.Errorf("upload failed part %d: %w", partNum, err))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov3" title="7">mu.Lock()
                        parts = append(parts, upload.MultipartPartObject{
                                PartNumber: partNum,
                                ETag:       etag,
                        })
                        mu.Unlock()</span>
                }
        }

        <span class="cov3" title="7">for range common.MaxConcurrentUploads </span><span class="cov5" title="70">{
                wg.Add(1)
                go worker()
        }</span>
        <span class="cov3" title="7">wg.Wait()

        if len(uploadErrors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("multipart upload failed with %d errors: %v", len(uploadErrors), uploadErrors)
        }</span>

        <span class="cov3" title="7">sort.Slice(parts, func(i, j int) bool </span><span class="cov0" title="0">{
                return parts[i].PartNumber &lt; parts[j].PartNumber
        }</span>)

        <span class="cov3" title="7">if err := completeMultipartUpload(ctx, g3, key, uploadID, parts, request.Bucket); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to complete multipart upload: %w", err)
        }</span>

        <span class="cov3" title="7">g3.Logger().Printf("Successfully uploaded %s to %s", request.Filename, key)
        g3.Logger().Succeeded(request.FilePath, request.GUID)
        return nil</span>
}

func initMultipartUpload(ctx context.Context, g3 dataClient.Gen3Interface, request common.FileUploadRequestObject, bucketName string) (string, string, error) <span class="cov3" title="7">{
        reader, err := common.ToJSONReader(
                upload.InitRequestObject{
                        Filename: request.Filename,
                        Bucket:   bucketName,
                        GUID:     request.GUID,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov3" title="7">cred := g3.GetCredential()
        resp, err := g3.Do(
                ctx,
                &amp;req.RequestBuilder{
                        Method:  http.MethodPost,
                        Url:     cred.APIEndpoint + common.FenceDataMultipartInitEndpoint,
                        Headers: map[string]string{common.HeaderContentType: common.MIMEApplicationJSON},
                        Body:    reader,
                        Token:   cred.AccessToken,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "404") </span><span class="cov0" title="0">{
                        return "", "", errors.New(err.Error() + "\nPlease check to ensure FENCE version is at 2.8.0 or beyond")
                }</span>
                <span class="cov0" title="0">return "", "", errors.New("Error has occurred during multipart upload initialization, detailed error message: " + err.Error())</span>
        }

        <span class="cov3" title="7">msg, err := g3.ParseFenceURLResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New("Error has occurred during multipart upload initialization, detailed error message: " + err.Error())
        }</span>

        <span class="cov3" title="7">if msg.UploadID == "" || msg.GUID == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("unknown error has occurred during multipart upload initialization. Please check logs from Gen3 services")
        }</span>
        <span class="cov3" title="7">return msg.UploadID, msg.GUID, err</span>
}

func generateMultipartPresignedURL(ctx context.Context, g3 dataClient.Gen3Interface, key string, uploadID string, partNumber int, bucketName string) (string, error) <span class="cov3" title="7">{
        reader, err := common.ToJSONReader(
                upload.MultipartUploadRequestObject{
                        Key:        key,
                        UploadID:   uploadID,
                        PartNumber: partNumber,
                        Bucket:     bucketName,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="7">cred := g3.GetCredential()
        resp, err := g3.Do(
                ctx,
                &amp;req.RequestBuilder{
                        Url:     cred.APIEndpoint + common.FenceDataMultipartUploadEndpoint,
                        Headers: map[string]string{common.HeaderContentType: common.MIMEApplicationJSON},
                        Method:  http.MethodPost,
                        Body:    reader,
                        Token:   cred.AccessToken,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("Error has occurred during multipart upload presigned url generation, detailed error message: " + err.Error())
        }</span>

        <span class="cov3" title="7">msg, err := g3.ParseFenceURLResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("Error has occurred during multipart upload initialization, detailed error message: " + err.Error())
        }</span>

        <span class="cov3" title="7">if msg.PresignedURL == "" </span><span class="cov0" title="0">{
                return "", errors.New("unknown error has occurred during multipart upload presigned url generation. Please check logs from Gen3 services")
        }</span>
        <span class="cov3" title="7">return msg.PresignedURL, err</span>
}

func completeMultipartUpload(ctx context.Context, g3 dataClient.Gen3Interface, key string, uploadID string, parts []upload.MultipartPartObject, bucketName string) error <span class="cov3" title="7">{
        multipartCompleteObject := upload.MultipartCompleteRequestObject{Key: key, UploadID: uploadID, Parts: parts, Bucket: bucketName}

        var buf bytes.Buffer
        err := json.NewEncoder(&amp;buf).Encode(multipartCompleteObject)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Error occurred during encoding multipart upload data: " + err.Error())
        }</span>

        <span class="cov3" title="7">cred := g3.GetCredential()
        _, err = g3.Do(
                ctx,
                &amp;req.RequestBuilder{
                        Url:     cred.APIEndpoint + common.FenceDataMultipartCompleteEndpoint,
                        Headers: map[string]string{common.HeaderContentType: common.MIMEApplicationJSON},
                        Body:    &amp;buf,
                        Method:  http.MethodPost,
                        Token:   cred.AccessToken,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Error has occurred during completing multipart upload, detailed error message: " + err.Error())
        }</span>
        <span class="cov3" title="7">return nil</span>
}

func uploadPartWithClient(ctx context.Context, httpClient *http.Client, url string, data io.Reader, partSize int64) (string, error) <span class="cov3" title="7">{
        req, err := http.NewRequestWithContext(ctx, http.MethodPut, url, data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="7">req.ContentLength = partSize

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="7">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
                return "", fmt.Errorf("upload failed (%d): %s", resp.StatusCode, body)
        }</span>

        <span class="cov3" title="7">etag := resp.Header.Get("ETag")
        if etag == "" </span><span class="cov0" title="0">{
                return "", errors.New("no ETag returned")
        }</span>

        <span class="cov3" title="7">return strings.Trim(etag, `"`), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package indexd_client

import "io"

type progressReadCloser struct {
        io.ReadCloser
        report func(int64)
}

func (p *progressReadCloser) Read(buf []byte) (int, error) <span class="cov4" title="14">{
        n, err := p.ReadCloser.Read(buf)
        if n &gt; 0 &amp;&amp; p.report != nil </span><span class="cov3" title="7">{
                p.report(int64(n))
        }</span>
        return n, err
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package indexd_client

import "github.com/calypr/git-drs/drs/hash"

// Based on OpenAPI specification
// https://github.com/uc-cdis/indexd/blob/master/openapis/swagger.yaml

// subset of the OpenAPI spec for the InputInfo object in indexd
// TODO: make another object based on VersionInputInfo that has content_created_date and so can handle a POST of dates via indexd/&lt;GUID&gt;
type IndexdRecord struct {
        // Unique identifier for the record (UUID)
        Did string `json:"did"`

        // Human-readable file name
        FileName string `json:"file_name,omitempty"`

        // List of URLs where the file can be accessed
        URLs []string `json:"urls"`

        // Hashes of the file (e.g., md5, sha256)
        Size int64 `json:"size"`

        // List of access control lists (ACLs)
        ACL []string `json:"acl,omitempty"`

        // List of authorization policies
        Authz []string `json:"authz,omitempty"`

        Hashes hash.HashInfo `json:"hashes,omitzero"`

        // Additional metadata as key-value pairs
        Metadata map[string]string `json:"metadata,omitempty"`

        // Version of the record (optional)
        Version string `json:"version,omitempty"`

        // // Created timestamp (RFC3339 format)
        // ContentCreatedDate string `json:"content_created_date,omitempty"`

        // // Updated timestamp (RFC3339 format)
        // ContentUpdatedDate string `json:"content_updated_date,omitempty"`
}

// create indexd record struct used for POSTs that is IndexdRecord with form field
type IndexdRecordForm struct {
        IndexdRecord
        Form string `json:"form"`
        Rev  string `json:"rev,omitempty"`
}

type ListRecordsResult struct {
        Record *OutputInfo
        Error  error
}

type ListRecords struct {
        IDs      []string       `json:"ids"`
        Records  []OutputInfo   `json:"records"`
        Size     int64          `json:"size"`
        Start    int64          `json:"start"`
        Limit    int64          `json:"limit"`
        FileName string         `json:"file_name"`
        URLs     []string       `json:"urls"`
        ACL      []string       `json:"acl"`
        Authz    []string       `json:"authz"`
        Hashes   hash.HashInfo  `json:"hashes"`
        Metadata map[string]any `json:"metadata"`
        Version  string         `json:"version"`
}

type OutputInfo struct {
        Did          string         `json:"did"`
        BaseID       string         `json:"baseid"`
        Rev          string         `json:"rev"`
        Form         string         `json:"form"`
        Size         int64          `json:"size"`
        FileName     string         `json:"file_name"`
        Version      string         `json:"version"`
        Uploader     string         `json:"uploader"`
        URLs         []string       `json:"urls"`
        ACL          []string       `json:"acl"`
        Authz        []string       `json:"authz"`
        Hashes       hash.HashInfo  `json:"hashes"`
        UpdatedDate  string         `json:"updated_date"`
        CreatedDate  string         `json:"created_date"`
        Metadata     map[string]any `json:"metadata"`
        URLsMetadata map[string]any `json:"urls_metadata"`
}

func (outputInfo *OutputInfo) ToIndexdRecord() *IndexdRecord <span class="cov10" title="110">{
        return &amp;IndexdRecord{
                Did:      outputInfo.Did,
                Size:     outputInfo.Size,
                FileName: outputInfo.FileName,
                URLs:     outputInfo.URLs,
                ACL:      outputInfo.ACL,
                Authz:    outputInfo.Authz,
                Hashes:   outputInfo.Hashes,
                //Metadata: outputInfo.Metadata, //TODO: re-enable metadata. One is map[string]string, the other is map[string]interface{}
                Version: outputInfo.Version,
        }
}</span>

// UpdateInputInfo is the put object for index records
type UpdateInputInfo struct {
        // Human-readable file name
        FileName string `json:"file_name,omitempty"`

        // Additional metadata as key-value pairs
        Metadata map[string]any `json:"metadata,omitempty"`

        // URL-specific metadata as key-value pairs
        URLsMetadata map[string]any `json:"urls_metadata,omitempty"`

        // Version of the record
        Version string `json:"version,omitempty"`

        // List of URLs where the file can be accessed
        URLs []string `json:"urls,omitempty"`

        // List of access control lists (ACLs)
        ACL []string `json:"acl,omitempty"`

        // List of authorization policies
        Authz []string `json:"authz,omitempty"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package indexd_client

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/s3_utils"
)

// getBucketDetailsWithAuth fetches bucket details from Gen3 using an AuthHandler.
// This function accepts an auth handler for dependency injection, making it testable.
// Parameters:
//   - ctx: context for the request
//   - bucket: the bucket name to look up
//   - bucketsEndpointURL: full URL to the /user/data/buckets endpoint
//   - authHandler: handler for adding authentication headers
//   - httpClient: the HTTP client to use
func GetBucketDetailsWithAuth(ctx context.Context, bucket, bucketsEndpointURL string, authHandler s3_utils.AuthHandler, httpClient *http.Client) (*s3_utils.S3Bucket, error) <span class="cov10" title="11">{
        // Use provided client or create default
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{}
        }</span>

        <span class="cov10" title="11">req, err := http.NewRequestWithContext(ctx, "GET", bucketsEndpointURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authentication using the auth handler
        <span class="cov10" title="11">if authHandler != nil </span><span class="cov6" title="4">{
                if err := authHandler.AddAuthHeader(req); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to add authentication: %w", err)
                }</span>
        }

        <span class="cov9" title="10">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch bucket information: %w", err)
        }</span>
        <span class="cov9" title="10">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        // extract bucket endpoint
        <span class="cov9" title="9">var bucketInfo s3_utils.S3BucketsResponse
        if err := sonic.ConfigFastest.NewDecoder(resp.Body).Decode(&amp;bucketInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode bucket information: %w", err)
        }</span>

        <span class="cov9" title="9">if info, exists := bucketInfo.S3Buckets[bucket]; exists </span><span class="cov8" title="7">{
                if info.EndpointURL != "" &amp;&amp; info.Region != "" </span><span class="cov6" title="4">{
                        return info, nil
                }</span>
                <span class="cov5" title="3">return nil, errors.New("endpoint_url or region not found for bucket")</span>
        }

        <span class="cov3" title="2">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package addref

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "add-ref &lt;drs_uri&gt; &lt;dst path&gt;",
        Short: "Add a reference to an existing DRS object via URI",
        Long:  "Add a reference to an existing DRS object, eg passing a DRS URI from AnVIL. Requires that the sha256 of the file is already in the cache",
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                drsUri := args[0]
                dstPath := args[1]

                logger := drslog.GetLogger()

                logger.Printf("Adding reference to DRS object %s to %s\n", drsUri, dstPath)

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Error getting remote: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">client, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">obj, err := client.GetObject(drsUri)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">objSha := ""
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                objSha = sum
                        }</span>
                }
                <span class="cov0" title="0">if objSha == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("object %s sha256 not available", drsUri)
                }</span>
                <span class="cov0" title="0">dirPath := filepath.Dir(dstPath)
                _, err = os.Stat(dirPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // The directory does not exist
                        os.MkdirAll(dirPath, os.ModePerm)
                }</span>

                <span class="cov0" title="0">err = drsmap.CreateLfsPointer(obj, dstPath)
                return err</span>
        },
}

func init() <span class="cov10" title="1129">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package addurl

import (
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

// AddURLCmd represents the add-url command
var AddURLCmd = &amp;cobra.Command{
        Use:   "add-url &lt;url&gt; &lt;sha256&gt;",
        Short: "Add a file to the Git DRS repo using an S3 URL",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 2 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 2 arguments (S3 URL and SHA256), received %d\n\nUsage: %s\n\nSee 'git drs add-url --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                myLogger := drslog.GetLogger()

                // set git config lfs.allowincompletepush = true
                configCmd := exec.Command("git", "config", "lfs.allowincompletepush", "true")
                if err := configCmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to configure git to push pointers: %v. Please change the .git/config file to include an [lfs] section with allowincompletepush = true", err)
                }</span>

                // Parse arguments
                <span class="cov0" title="0">s3URL := args[0]
                sha256 := args[1]
                awsAccessKey, _ := cmd.Flags().GetString(s3_utils.AWS_KEY_FLAG_NAME)
                awsSecretKey, _ := cmd.Flags().GetString(s3_utils.AWS_SECRET_FLAG_NAME)
                awsRegion, _ := cmd.Flags().GetString(s3_utils.AWS_REGION_FLAG_NAME)
                awsEndpoint, _ := cmd.Flags().GetString(s3_utils.AWS_ENDPOINT_URL_FLAG_NAME)
                remote, _ := cmd.Flags().GetString("remote")

                // if providing credentials, access key and secret must both be provided
                if (awsAccessKey == "" &amp;&amp; awsSecretKey != "") || (awsAccessKey != "" &amp;&amp; awsSecretKey == "") </span><span class="cov0" title="0">{
                        return errors.New("incomplete credentials provided as environment variables. Please run `export " + s3_utils.AWS_KEY_ENV_VAR + "=&lt;key&gt;` and `export " + s3_utils.AWS_SECRET_ENV_VAR + "=&lt;secret&gt;` to configure both")
                }</span>

                // if none provided, use default AWS configuration on file
                <span class="cov0" title="0">if awsAccessKey == "" &amp;&amp; awsSecretKey == "" </span><span class="cov0" title="0">{
                        myLogger.Print("No AWS credentials provided. Using default AWS configuration from file.")
                }</span>

                <span class="cov0" title="0">cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting current remote client: %v", err)
                }</span>

                // Call client.AddURL to handle Gen3 interactions
                <span class="cov0" title="0">meta, err := drsClient.AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, awsRegion, awsEndpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Generate and add pointer file
                <span class="cov0" title="0">_, relFilePath, err := utils.ParseS3URL(s3URL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse S3 URL: %w", err)
                }</span>
                <span class="cov0" title="0">if err := generatePointerFile(relFilePath, sha256, meta.Size); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate pointer file: %w", err)
                }</span>
                <span class="cov0" title="0">myLogger.Print("S3 URL successfully added to Git DRS repo.")
                return nil</span>
        },
}

func init() <span class="cov10" title="1130">{
        AddURLCmd.Flags().String(s3_utils.AWS_KEY_FLAG_NAME, os.Getenv(s3_utils.AWS_KEY_ENV_VAR), "AWS access key")
        AddURLCmd.Flags().String(s3_utils.AWS_SECRET_FLAG_NAME, os.Getenv(s3_utils.AWS_SECRET_ENV_VAR), "AWS secret key")
        AddURLCmd.Flags().String(s3_utils.AWS_REGION_FLAG_NAME, os.Getenv(s3_utils.AWS_REGION_ENV_VAR), "AWS S3 region")
        AddURLCmd.Flags().String(s3_utils.AWS_ENDPOINT_URL_FLAG_NAME, os.Getenv(s3_utils.AWS_ENDPOINT_URL_ENV_VAR), "AWS S3 endpoint")
        AddURLCmd.Flags().String("remote", "", "target remote DRS server (default: default_remote)")
}</span>

func generatePointerFile(filePath string, sha256 string, fileSize int64) error <span class="cov1" title="1">{
        // Define the pointer file content
        pointerContent := fmt.Sprintf("version https://git-lfs.github.com/spec/v1\noid sha256:%s\nsize %d\n", sha256, fileSize)

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory for pointer file: %w", err)
        }</span>

        // Write the pointer file
        <span class="cov1" title="1">if err := os.WriteFile(filePath, []byte(pointerContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write pointer file: %w", err)
        }</span>

        // Add the pointer file to Git
        <span class="cov1" title="1">cmd := exec.Command("git", "add", filePath)
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add pointer file to Git: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cache

import (
        "encoding/csv"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "create-cache &lt;manifest.tsv&gt;",
        Short: "create a local version of a file manifest containing DRS URIs",
        Long:  "create a local version of a file manifest containing DRS URIs. Enables LFS to map its file object id (sha256) back to a DRS URI by file",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                file := args[0]

                // load file
                f, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open manifest file: %w", err)
                }</span>
                <span class="cov0" title="0">defer f.Close()

                // Use encoding/csv with tab delimiter for TSV
                r := csv.NewReader(f)
                r.Comma = '\t'

                // Read header
                header, err := r.Read()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read header: %w", err)
                }</span>

                // Map column names to indices
                <span class="cov0" title="0">colIdx := make(map[string]int, len(header))
                for i, col := range header </span><span class="cov0" title="0">{
                        colIdx[col] = i
                }</span>

                // Check required columns
                <span class="cov0" title="0">shaIdx, shaOk := colIdx["files.sha256"]
                drsIdx, drsOk := colIdx["files.drs_uri"]
                if !shaOk || !drsOk </span><span class="cov0" title="0">{
                        return fmt.Errorf("manifest must contain 'files.sha256' and 'files.drs_uri' columns")
                }</span>

                // Read each row
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        row, err := r.Read()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("error reading manifest file: %w", err)</span>
                        }
                        <span class="cov0" title="0">sha := row[shaIdx]
                        drsURI := row[drsIdx]
                        fmt.Printf("Indexing DRS URI %s with sha256 %s\n", drsURI, sha)

                        // create sha to DRS URI mapping
                        objPath, err := drsmap.GetObjectPath(projectdir.DRS_REF_DIR, sha)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get object path for %s: %w", sha, err)
                        }</span>

                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(objPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", objPath, err)
                        }</span>

                        <span class="cov0" title="0">contents := fmt.Sprintf("files.drs_uri\n%s\n", drsURI)
                        if err := os.WriteFile(objPath, []byte(contents), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write DRS URI for %s: %w", sha, err)
                        }</span>

                        // Split DRS URI into a custom path and write sha to custom path
                        <span class="cov0" title="0">customPath, err := drsmap.CreateCustomPath(projectdir.DRS_REF_DIR, drsURI)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create custom path for %s: %w", drsURI, err)
                        }</span>
                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(customPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", customPath, err)
                        }</span>
                        <span class="cov0" title="0">if err := os.WriteFile(customPath, []byte(sha), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write sha for %s: %w", drsURI, err)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Cache created in %s\n", projectdir.DRS_REF_DIR)
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package delete

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag bool
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete &lt;hash-type&gt; &lt;oid&gt;",
        Short:  "Delete a file using hash and file object ID",
        Long:   "Delete a file using file object ID. Use lfs ls-files to get oid",
        Hidden: true,
        Args:   cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                hashType, oid := args[0], args[1]

                // check hash type is valid Checksum type and sha256
                if hashType != hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                        return fmt.Errorf("only sha256 supported, you requested to remove: %s", hashType)
                }</span>

                <span class="cov0" title="0">logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("error creating indexd client: %s", err)
                        return err
                }</span>

                // Get record details before deletion for confirmation
                <span class="cov0" title="0">records, err := drsClient.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting records for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no records found for OID %s", oid)
                }</span>

                // Find matching record for current project
                <span class="cov0" title="0">projectId := drsClient.GetProjectId()
                matchingRecord, err := drsmap.FindMatchingRecord(records, projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
                }</span>
                <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no matching record found for project %s and OID %s", projectId, oid)
                }</span>

                // Show details and get confirmation unless --confirm flag is set
                <span class="cov0" title="0">if !confirmFlag </span><span class="cov0" title="0">{
                        utils.DisplayWarningHeader(os.Stderr, "DELETE a DRS record")
                        utils.DisplayField(os.Stderr, "Remote", string(remoteName))
                        utils.DisplayField(os.Stderr, "Project", projectId)
                        utils.DisplayField(os.Stderr, "OID", oid)
                        utils.DisplayField(os.Stderr, "Hash Type", hashType)
                        utils.DisplayField(os.Stderr, "DID", matchingRecord.Id)
                        if matchingRecord.Name != "" </span><span class="cov0" title="0">{
                                utils.DisplayField(os.Stderr, "Filename", matchingRecord.Name)
                        }</span>
                        <span class="cov0" title="0">utils.DisplayField(os.Stderr, "Size", fmt.Sprintf("%d bytes", matchingRecord.Size))
                        utils.DisplayFooter(os.Stderr)

                        if err := utils.PromptForConfirmation(os.Stderr, "Type 'yes' to confirm deletion", utils.ConfirmationYes, false); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching record
                <span class="cov0" title="0">err = drsClient.DeleteRecord(oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting file for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">logger.Printf("Successfully deleted record for OID %s", oid)
                return nil</span>
        },
}

func init() <span class="cov10" title="1129">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVar(&amp;confirmFlag, "confirm", false, "skip interactive confirmation prompt")
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package deleteproject

import (
        "fmt"
        "os"

        indexdCl "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete-project &lt;project_id&gt;",
        Short:  "Delete all indexd records for a given project",
        Long:   "Delete all indexd records for a given project",
        Hidden: true,
        Args:   cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                projectId := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("error creating indexd client: %s", err)
                        return err
                }</span>

                // Cast to IndexDClient to access GetProjectSample
                <span class="cov0" title="0">indexdClient, ok := drsClient.(*indexdCl.IndexDClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("client is not an IndexDClient, cannot proceed with delete-project")
                }</span>

                // Get a sample record to show the user what will be deleted
                <span class="cov0" title="0">sampleRecords, err := indexdClient.GetProjectSample(projectId, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting sample records for project %s: %v", projectId, err)
                }</span>

                // Show details and get confirmation unless --confirm flag matches project_id
                <span class="cov0" title="0">if confirmFlag != "" &amp;&amp; confirmFlag != projectId </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: --confirm value '%s' does not match project ID '%s'", confirmFlag, projectId)
                }</span>
                <span class="cov0" title="0">if confirmFlag != projectId </span><span class="cov0" title="0">{
                        utils.DisplayWarningHeader(os.Stderr, "DELETE ALL RECORDS for a project")
                        utils.DisplayField(os.Stderr, "Remote", string(remoteName))
                        utils.DisplayField(os.Stderr, "Project ID", projectId)

                        if len(sampleRecords) &gt; 0 </span><span class="cov0" title="0">{
                                sample := sampleRecords[0]
                                fmt.Fprintf(os.Stderr, "\nSample record from this project:\n")
                                utils.DisplayField(os.Stderr, "  DID", sample.Id)
                                if sample.Name != "" </span><span class="cov0" title="0">{
                                        utils.DisplayField(os.Stderr, "  Filename", sample.Name)
                                }</span>
                                <span class="cov0" title="0">utils.DisplayField(os.Stderr, "  Size", fmt.Sprintf("%d bytes", sample.Size))
                                if sample.CreatedTime != "" </span><span class="cov0" title="0">{
                                        utils.DisplayField(os.Stderr, "  Created", sample.CreatedTime)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "\nNo records found for this project.\n")
                        }</span>

                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\nThis will DELETE ALL records in project '%s'.\n", projectId)
                        utils.DisplayFooter(os.Stderr)

                        if err := utils.PromptForConfirmation(os.Stderr, fmt.Sprintf("Type the project ID '%s' to confirm deletion", projectId), projectId, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching records
                <span class="cov0" title="0">logger.Printf("Deleting all records for project %s...", projectId)
                err = drsClient.DeleteRecordsByProject(projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting project %s: %v", projectId, err)
                }</span>

                <span class="cov0" title="0">logger.Printf("Successfully deleted all records for project %s", projectId)
                return nil</span>
        },
}

func init() <span class="cov10" title="1129">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVar(&amp;confirmFlag, "confirm", "", "skip interactive confirmation by providing the project_id (e.g., --confirm my-project)")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package download

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/spf13/cobra"
)

var (
        dstPath string
        remote  string
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "download &lt;oid&gt;",
        Short: "Download file using file object ID",
        Long:  "Download file using file object ID (sha256 hash). Use lfs ls-files to get oid",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (file object ID), received %d\n\nUsage: %s\n\nSee 'git drs download --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                oid := args[0]

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("\nerror creating DRS client: %s", err)
                        return err
                }</span>

                // get signed url
                <span class="cov0" title="0">accessUrl, err := drsClient.GetDownloadURL(oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error downloading file for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">if accessUrl.URL == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Unable to get access URL %s", oid)
                }</span>

                // download url to destination path or LFS objects if not specified
                <span class="cov0" title="0">if dstPath == "" </span><span class="cov0" title="0">{
                        dstPath, err = drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, oid)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error getting destination path for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">err = s3_utils.DownloadSignedUrl(accessUrl.URL, dstPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error downloading file for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("\nerror downloading file object ID %s: %s", oid, err)
                }</span>

                <span class="cov0" title="0">logger.Print("file downloaded")

                return nil</span>
        },
}

func init() <span class="cov10" title="1129">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;dstPath, "dst", "d", "", "Destination path to save the downloaded file")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package fetch

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "fetch [remote-name]",
        Short: "fetch drs objects from remote",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs fetch --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov0" title="0"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("Error getting remote: %v", err)
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("\nerror creating DRS client: %s", err)
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PullRemoteDrsObjects(drsClient, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package initialize

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var transfers int

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize repo for git-drs",
        Long: "Description:" +
                "\n  Initialize repo for git-drs",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov6" title="69">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs init --help' for more details", len(args), cmd.UseLine())
                }</span></span>
                return nil
        },</span></span>
        R<span class="cov6" title="40">unE: func(</span>cmd *cobra.Command, args []string) error <span class="cov6" title="69">{
                logg := drslog.GetLogger()

                // check if .git dir exists to ensure you're in a git repository
                _, err := utils.GitTopLevel()
                if err != nil </span>{
                        return fmt.Errorf("error: not in a git repository. Please run this command in the root of your git repository")
                }
</span></span>
                /</span>/ create config file if it doesn't exist
                <span class="cov6" title="69">err = config.CreateEmptyConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: unable to create config file: %v", err)
                }</span>
</span>
                /</span>/ load the config
                <span class="cov6" title="69">_, err = config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Printf("We should probably fix this: %v", err)
                        return fmt.Errorf("error: unable to load config file: %v", err)
                }</span></span>

                /</span>/ setup lfs custom transfer
                // TODO: may need to generalize for anvil
                <span class="cov6" title="69">err = initGitConfig()
                if err != nil </span>{
                        return fmt.Errorf("error initializing custom transfer for DRS: %v", err)
                }

                // install pre-push hook
</span></span>                err = installPrePushHook(logg)
</span>                if err != nil </span>{
                        r</span>eturn fmt.Errorf("error installing pre-push hook: %v", err)
                }</span>

                // final logs
                <span class="cov6" title="69">logg.Print("Git DRS initialized")
                logg.Printf("Using %d concurrent transfers", transfers)
                return nil</span>
</span>        },
}
</span>
</span>func initGitConfig() error {
        co</span>nfigs := [][]string{
                {"lfs.standalonetransferagent", "drs"},
                {"lfs.customtransfer.drs.path", "git-drs"},
                {"lfs.customtransfer.drs.args", "transfer"},
                // TODO: different for anvil / read-only?
                {"lfs.allowincompletepush", "false"},
                {"lfs.customtransfer.drs.concurrent", strconv.FormatBool(transfers &gt; 1)},
                {"lfs.customtransfer.drs.concurrenttransfers", strconv.Itoa(transfers)},
        }

        for _, args := range configs </span></span></span></span><span class="cov9" title="414">{
                cmd := exec.Command("git", "config", args[0], args[1])
                if cmdOut, err := cmd.Output(); err != nil </span>{
                        return fmt.Er</span>rorf("unable to set git config %s: %s", args[0], cmdOut)
                }</span>
        }
</span>
        <span class="cov6" title="69">return nil</span>
}

</span>func init() {
        Cm</span>d.Flags().IntVarP(&amp;transfers, "transfers", "t", 4, "Number of concurrent transfers")
}</span>

fu<span class="cov6" title="40">nc installPrePushHook(logger *log.Logger) error {
        cmd := exec.Command("git", "rev-parse", "--git-dir")
        cmdOut, err</span> := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to locate git directory: %w", err)
        }</span>
        <span class="cov6" title="69">gitDir := strings.TrimSpace(string(cmdOut))
        hooksDir := filepath.Join(gitDir, "hooks")
        if err := os.MkdirAll(hooksDir, 0755); err != nil </span>{
                return fmt.Errorf("unable to create hooks directory: %w", err)
        }

        hookPath := filepath.Join(hooksDir, "pre-push")
        hookBody := `
# . git/hooks/pre-push
remote="$1"
url="$2"

</span></span># Buffer stdin for both commands
TMPFILE="${TMPDIR:-/tmp}/git-drs-$$"
trap "rm -f $TMPFILE" EXIT
cat &gt; "$TMPFILE"

# Run DRS preparation
git drs pre-push-prepare "$remote" "$url" &lt; "$TMPFILE" || exit 1

# Run LFS push
exec git lfs pre-push "$remote" "$url" &lt; "$TMPFILE"
`
        hookScript := "#!/bin/sh\n" + hookBody

        existingContent, err := os.ReadFile(hookPath)
        if err == nil </span></span></span></span></span>{
                // there is an existing hook, rename it, and let the user know
                // Backup exi</span>sting hook with timestamp
                timestamp := time.Now().Format("20060102T150405")
                backupPath := hookPath + "." + timestamp
                if err := os.WriteFile(backupPath, existingContent, 0644); err != nil </span></span>{
                        return fmt.Errorf("unable to back up existing pre-push hook: %w", err)
                }
</span></span>                if err := os.Remove(hookPath); err != nil {
                </span></span>        return fmt.Errorf("unable to remove hook after backing up: %w", err)
                }</span>
        <span class="cov6" title="40">        logger.Printf("pre-push hook updated; backup written to %s", backupPath)
        }
        // If there was an error other than expected not existing, return it
        if err != nil &amp;&amp; !os.IsNotExist(err) {
                return fmt.Errorf("unable to read pre-push hook: %w", err)
        }

        err = os.WriteFile(hookPath, []byte(hookScript), 0755)
        if err != nil {
                return fmt.Errorf("unable to write pre-push hook: %w", err)
        }
        logger.Print("pre-push hook installed")
        return nil
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package list

import (
        "fmt"
        "io"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var (
        outJson     bool = false
        outFile     string
        listOutFile string
        remote      string
)

var checksumPref = []hash.ChecksumType{hash.ChecksumTypeSHA256, hash.ChecksumTypeMD5, hash.ChecksumTypeETag}

func getChecksumPos(q hash.ChecksumType, a []hash.ChecksumType) int <span class="cov2" title="4">{
        for i, s := range a </span><span class="cov3" title="7">{
                if q == s </span><span class="cov2" title="3">{
                        return i
                }</span>
        }
        <span class="cov1" title="1">return -1</span>
}

// Pick out the most preferred checksum to display
func getCheckSumStr(obj drs.DRSObject) string <span class="cov1" title="1">{
        curPos := len(checksumPref) + 1
        curVal := ""
        for checksumType, checksum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov1" title="2">{
                c := getChecksumPos(hash.ChecksumType(checksumType), checksumPref)
                if c != -1 &amp;&amp; c &lt; curPos </span><span class="cov1" title="2">{
                        curPos = c
                        curVal = checksumType + ":" + checksum
                }</span>
        }
        <span class="cov1" title="1">return curVal</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS entities from server",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                var outWriter io.Writer
                if listOutFile != "" </span><span class="cov0" title="0">{
                        f, err := os.Create(listOutFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        outWriter = f</span>
                } else<span class="cov0" title="0"> {
                        outWriter = os.Stdout
                }</span>

                <span class="cov0" title="0">conf, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := conf.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">client, err := conf.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Client failed")
                        return err
                }</span>
                <span class="cov0" title="0">objChan, err := client.ListObjects()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !outJson </span><span class="cov0" title="0">{
                        fmt.Fprintf(outWriter, "%-55s\t%-15s\t%-75s\t%s\n", "URI", "Size", "Checksum", "Name")
                }</span>

                // for each result, check for error and print
                <span class="cov0" title="0">for objResult := range objChan </span><span class="cov0" title="0">{
                        if objResult.Error != nil </span><span class="cov0" title="0">{
                                return objResult.Error
                        }</span>
                        <span class="cov0" title="0">obj := objResult.Object
                        if outJson </span><span class="cov0" title="0">{
                                out, err := sonic.ConfigFastest.Marshal(*obj)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">fmt.Fprintf(outWriter, "%s\n", string(out))</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(outWriter, "%s\t%-15d\t%-75s\t%s\n", obj.SelfURI, obj.Size, getCheckSumStr(*obj), obj.Name)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}
var ListProjectCmd = &amp;cobra.Command{
        Use:   "list-project &lt;project-id&gt;",
        Short: "List DRS entities from server",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov3" title="6">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (project ID), received %d\n\nUsage: %s\n\nSee 'git drs list-project --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov3" title="6">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov3" title="6">{
                logger := drslog.GetLogger()

                conf, err := config.LoadConfig()
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov3" title="5">remoteName, err := conf.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov3" title="5">client, err := conf.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="5">objChan, err := client.ListObjectsByProject(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="5">var f *os.File
                var outWriter io.Writer
                if outFile != "" </span><span class="cov0" title="0">{
                        f, err = os.Create(outFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        outWriter = f</span>
                } else<span class="cov3" title="5"> {
                        outWriter = os.Stdout
                }</span>
                <span class="cov3" title="5">for objResult := range objChan </span><span class="cov3" title="9">{
                        if objResult.Error != nil </span><span class="cov1" title="1">{
                                return objResult.Error
                        }</span>
                        <span class="cov3" title="8">obj := objResult.Object
                        out, err := sonic.ConfigFastest.Marshal(*obj)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="8">_, err = outWriter.Write(out)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="8">_, err = outWriter.Write([]byte("\n"))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov2" title="4">return nil</span>
        },
}

func init() <span class="cov10" title="1130">{
        ListProjectCmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        ListProjectCmd.Flags().StringVarP(&amp;outFile, "out", "o", outFile, "File path to save output to")
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;listOutFile, "out", "o", listOutFile, "File path to save output to")
        Cmd.Flags().BoolVarP(&amp;outJson, "json", "j", outJson, "Output formatted as JSON")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package listconfig

import (
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        jsonOutput bool
)

// Cmd represents the list-config command
var Cmd = &amp;cobra.Command{
        Use:   "list-config",
        Short: "Display the current configuration",
        Long:  "Pretty prints the current configuration file in YAML format",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list-config --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Load the current configuration
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                        // Output as JSON if requested
                        encoder := sonic.ConfigFastest.NewEncoder(os.Stdout)
                        encoder.SetIndent("", "  ")
                        return encoder.Encode(cfg)
                }</span> else<span class="cov0" title="0"> {
                        // Default YAML output with nice formatting
                        encoder := yaml.NewEncoder(os.Stdout)
                        encoder.SetIndent(2)
                        defer encoder.Close()

                        return encoder.Encode(cfg)
                }</span>
        },
}

func init() <span class="cov10" title="1130">{
        Cmd.Flags().BoolVarP(&amp;jsonOutput, "json", "j", false, "output in JSON format")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package prepush

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "sort"
        "strings"

        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "pre-push-prepare",
        Short: "pre-push hook to update DRS objects",
        Long:  "Pre-push hook that updates DRS objects before transfer",
        Args:  cobra.RangeArgs(0, 2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="104">{
                //myLogger := drslog.GetLogger()
                myLogger, err := drslog.NewLogger("", false)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating logger: %v", err)
                }</span>

                <span class="cov8" title="48">if drslog.TraceEnabled() </span>{
                        myLogger.Print("~~~~~~~~~~~~~ START: pre-push ~~~~~~~~~~~~~")
                }

</span></span>                cfg, err := config.LoadConfig()
                i</span>f err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting config: %v", err)
                }</span>

                //Command-line arguments: The hook receives two parameters:
                //* The name of the remote (e.g., origin).
                <span class="cov8" title="56">//* The remote's location/URL (e.g., github.com).
                // Create gitRemoteName and gitRemoteLocation from args.
                if drslog.TraceEna</span>bled() </span>{
                        myLogger.Printf("pre-push args: %v", args)
                }</span></span>
                <span class="cov8" title="56">var gitRemoteName,</span> gitRemoteLocation string
                if len(args) &gt;= 1 </span>{
                        </span>gitRemoteName = args[0]
                }</span>
</span>                if len(args) &gt;= 2 {
                        </span></span>gitRemoteLocation = args[1]
                }</span>
                if gitRemoteName == "" {
                        gitRemoteName = "origin"
                }
                if drslog.TraceEnabled() {
                        myLogger.Prin</span></span></span></span>tf("git remote name: %s, git remote location: %s", gitRemoteName, gitRemoteLocation)
                }</span>

                // get the default remote from the .git/drs/config
                var remote config.Remote
                r</span>emote, err = cfg.GetDefaultRemote()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("Warning. Error getting default remote: %v", err)
                        // Print warning to stderr and return success (exit 0)
                        fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting default remote:", err)
                        return nil
                }</span></span>

                // get the remote client
                c</span>li, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        // Print warning to stderr and return success (exit 0)
                        fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting remote client:", err)
                        myLogger.Printf("Warning. Skipping DRS preparation. Error getting remote client: %v", err)
                        return nil
                }</span></span></span>

                dc, ok := cli.(*indexd_client.IndexDClient)
                if !ok {
                        return fmt.Er</span></span>rorf("cli is not IndexdClient: %T", cli)
                }</span>
                if drslog.TraceEnabled() {
                        </span></span>myLogger.Printf("Current server: %s", dc.ProjectId)
                }</span>
</span>
                // Buffer stdin to a temp file and invoke `git lfs pre-push &lt;remote&gt; &lt;url&gt;` with same args and stdin.
                t</span>mp, err := os.CreateTemp("", "prepush-stdin-*")
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("error creating temp file for stdin: %v", err)
                        return err
                }</span></span>
                defer func() {
                        </span></span>_ = tmp.Close()
                        _ = os.Remove(tmp.Name())
                }</span>()

</span>                // Copy all of stdin into the temp file.
                if _, err := io.Copy(tmp, os.Stdin); err != nil {
                        </span></span>myLogger.Printf("error buffering stdin: %v", err)
                        return err
                }</span>

                // Rewind to s</span><span class="cov0" title="0">tart so the child process can read it.
                if _, err := tmp.Seek(0, 0); err != nil {
                        myLogger.Printf("error seeking temp stdin: %v", err)
                        </span></span>return err
                }</span>

                // read the temp file and get a list of all unique local branches being pushed
                branches, err </span>:= readPushedBranches(tmp)
                if err != nil </span>{
                        myLogger.Printf("error reading pushed branches: %v", err)
                        </span>return err
                }</span>

                if drslog.TraceEnabled() {
                        myLogger.</span></span>Printf("Preparing DRS objects for push branches: %v", branches)
                }</span>
                <span class="cov8" title="48">err = drsmap.UpdateDrsObjects(cli, gitRemoteName, gitRemoteLocation, branches, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Print("UpdateDrsObjects failed:", err)
                        return err
                }</span>
                <span class="cov8" title="48">if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                        myLogger.Printf("DRS objects prepared for push!\n")
                }</span>

                if drslog.TraceEnabled() {
</span></span>                        myLogger.Print("~~~~~~~~~~~~~ COMPLETED: pre-push ~~~~~~~~~~~~~")
                }</span>
</span>        <span class="cov8" title="56">        return nil
        },
}
</span></span>
// readPushedBranches reads git push lines from the provided temp file,
// extracts unique lo</span><span class="cov0" title="0">cal branch names for refs under `refs/heads/` and
// returns </span>them sorted. The file is rewound to the start before returning.
func readPushedBranches(f *os.File) ([]string, error) <span class="cov8" title="48">{
        // Ensure we read from start
        // example:
        // refs/heads/main 67890abcdef1234567890abcdef1234567890abcd refs/heads/main 12345abcdef67890abcdef1234567890abcdef12
        if _, err := f.Seek(0, 0); err != nil </span></span>{
                return nil, err
</span>        }</span>
        sca</span>nner := bufio.NewScanner(f)
        set := make(map[string]struct{})
        for scanner.Scan() </span><span class="cov8" title="48">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &lt; 1 </span></span>{
</span>                        continue</span>
                }
</span>                localRef := fields[0]
                </span>const prefix = "refs/heads/"
                if strings.HasPrefix(localRef, prefix) </span>{
                        branch := strings.TrimPrefix(localRef, prefix)
                        if branch != "" {
</span></span>                                set[branch] = struct{}{}
                        }</span>
</span>        <span class="cov8" title="56">        }
</span>        }
        <span class="cov8" title="48">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="48">branches := make([]string, 0, len(set))
        for b := range set </span><span class="cov8" title="48">{
                branches = append(branches, b)
        }</span>
        <span class="cov8" title="48">sort.Strings(branches)
        // Rewind so caller can reuse the file
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="48">return branches, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package push

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "push [remote-name]",
        Short: "push local objects to drs server.",
        Long:  "push local objects to drs server. Any local files that do not have drs records are written to a bucket.",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs push --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                myLogger := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("Error loading config: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov0" title="0"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Printf("Error getting default remote: %v", err)
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("Error creating indexd client: %s", err)
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PushLocalDrsObjects(drsClient, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package query

import (
        "fmt"

        "github.com/bytedance/sonic"
        conf "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

// printDRSObject marshals and prints a DRS object based on the pretty flag
func printDRSObject(obj drs.DRSObject, pretty bool) error <span class="cov3" title="5">{
        var out []byte
        var err error

        if pretty </span><span class="cov0" title="0">{
                out, err = sonic.ConfigFastest.MarshalIndent(obj, "", "  ")
        }</span></span> else {
                out, err = sonic.ConfigFastest.Marshal(obj)
        }
</span></span>
</span>        <span class="cov3" title="5">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        fmt.Printf("%s\n", string(out))
        return nil
</span></span>}

</span>var remote string
va<span class="cov0" title="0">r checksum = false
var pretty = fal</span><span class="cov0" title="0">se

type checksumClient interface {
        Ge</span>tObjectByHash(hash *hash.Checksum) ([]drs.DRSObject, error)
}

func queryByChec</span><span class="cov0" title="0">ksum(client checksumClient, checksum string) ([]drs.DRSObject, error) {
        // Auto-detect checksum type based on hash length
        ch</span>ecksumType := hash.ChecksumTypeSHA256
        switch len(checksum) </span>{
        c<span class="cov0" title="0">ase 32:
                // 128-bit / 3</span>2-hex-character checksum (e.g., MD5)
                checksumType = hash.ChecksumTypeMD5</span>
        ca</span>se 40:<span class="cov0" title="0">
                // 160-bit / 40-hex-character checksum (e.g., SHA1)
                checksumType = hash.ChecksumTypeSHA1</span>
</span>        case 64:
                /</span>/ 256-bit / 64-hex-character checksum (e.g., SHA256)
                checksumType = hash.ChecksumTypeSHA256</span>
        case 128:
</span>                // 512-bit / 128-hex-character checksum (e.g., SHA512)
                checksumType = hash.ChecksumTypeSHA512</span>
        }

        return client.GetObjectByHash(&amp;hash.Checksum{
        </span>        Checksum: checksum,
                Type:     checksumType,
        })</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "query &lt;drs_id&gt;",
        Short: "Query DRS server by DRS ID",
        Long:  "Query DRS server by DRS ID",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov3" title="5">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (DRS ID), received %d\n\nUsage: %s\n\nSee 'git drs query --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov3" title="5">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov3" title="5">{
                logger := drslog.GetLogger()

                config, err := conf.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="5">remoteName, err := config.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Error getting remote: %v", err)
                        return err
                }</span>

                <span class="cov3" title="5">client, err := config.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="5">var obj *drs.DRSObject

                if checksum </span><span class="cov0" title="0">{
                        objs, err := queryByChecksum(client, args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, drsObj := range objs </span><span class="cov0" title="0">{
                                if err := printDRSObject(drsObj, pretty); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov3" title="5"> {
                        obj, err = client.GetObject(args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="5">if err := printDRSObject(*obj, pretty); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov3" title="5">return nil</span>
        },
}

func init() <span class="cov10" title="586">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVarP(&amp;checksum, "checksum", "c", checksum, "Find by checksum")
        Cmd.Flags().BoolVarP(&amp;pretty, "pretty", "p", pretty, "Print indented JSON")
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package register

import (
        "fmt"

        indexdCl "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "register",
        Short: "Register all pending DRS objects with indexd",
        Long:  "Reads pending objects from .git/drs/lfs/objects/ and registers them with indexd (does not upload files)",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs register --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger, err := drslog.NewLogger("", true)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Error getting remote: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating indexd client: %v", err)
                }</span>
                <span class="cov0" title="0">icli, ok := cli.(*indexdCl.IndexDClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("remote client is not an *indexdCl.IndexDClient (got %T)", cli)
                }</span>

                // Get all pending objects
                <span class="cov0" title="0">pendingObjects, err := drs.GetPendingObjects(logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error reading pending objects: %v", err)
                }</span>

                <span class="cov0" title="0">if len(pendingObjects) == 0 </span><span class="cov0" title="0">{
                        logger.Println("No pending objects to register")
                        return nil
                }</span>

                <span class="cov0" title="0">logger.Printf("Found %d pending object(s) to register", len(pendingObjects))

                registeredCount := 0
                skippedCount := 0
                errorCount := 0

                // Register each pending object with indexd
                for _, obj := range pendingObjects </span><span class="cov0" title="0">{
                        logger.Printf("Processing %s (OID: %s)", obj.Path, obj.OID)

                        // Read the IndexdRecord from disk
                        indexdObj, err := drsmap.DrsInfoFromOid(obj.OID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("Error reading DRS object for %s: %v", obj.Path, err)
                                errorCount++
                                continue</span>
                        }

                        // Check if records with this hash already exist in indexd
                        <span class="cov0" title="0">records, err := cli.GetObjectByHash(&amp;hash.Checksum{Type: "sha256", Checksum: obj.OID})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("Error querying indexd for %s: %v", obj.Path, err)
                                errorCount++
                                continue</span>
                        }

                        // Check if a record with this exact DID already exists
                        <span class="cov0" title="0">alreadyExists := false
                        for _, record := range records </span><span class="cov0" title="0">{
                                if record.Id == indexdObj.Id </span><span class="cov0" title="0">{
                                        alreadyExists = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if alreadyExists </span><span class="cov0" title="0">{
                                logger.Printf("Record for %s (DID: %s) already exists in indexd, skipping", obj.Path, indexdObj.Id)
                                skippedCount++
                                continue</span>
                        }

                        // Register the indexd record
                        <span class="cov0" title="0">_, err = icli.RegisterRecord(indexdObj)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("Error registering %s with indexd: %v", obj.Path, err)
                                errorCount++
                                continue</span>
                        }

                        <span class="cov0" title="0">logger.Printf("Successfully registered %s with DID %s", obj.Path, indexdObj.Id)
                        registeredCount++</span>
                }

                // Summary
                <span class="cov0" title="0">logger.Printf("Registration complete: %d registered, %d skipped, %d errors",
                        registeredCount, skippedCount, errorCount)

                if errorCount &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("completed with %d error(s)", errorCount)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="1129">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package add

import (
        "fmt"
        "log"

        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
)

var AnvilCmd = &amp;cobra.Command{
        Use: "anvil [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add anvil --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return fmt.Errorf("error: anvil remote is not yet implemented. Use 'git drs remote add gen3' instead. See 'git drs remote add gen3 --help' for more details")
        }</span>,
}

func anvilInit(terraProject string, logger *log.Logger) error <span class="cov0" title="0">{
        // make sure terra project is provided
        if terraProject != "" </span><span class="cov0" title="0">{
                // populate anvil config
                remoteAnvil := config.RemoteSelect{
                        Anvil: &amp;anvil_client.AnvilRemote{
                                Endpoint: anvil_client.ANVIL_ENDPOINT,
                                Auth: anvil_client.AnvilAuth{
                                        TerraProject: terraProject,
                                },
                        },
                }
                // TODO: different than ORIGIN?
                remoteName := config.Remote(config.AnvilServerType)
                _, err := config.UpdateRemote(remoteName, remoteAnvil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error: unable to update config file: %v\n", err)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package add

import (
        "fmt"
        "log"

        "github.com/calypr/data-client/client/conf"
        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var Gen3Cmd = &amp;cobra.Command{
        Use: "gen3 [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="87">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add gen3 --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov10" title="87">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="87">{
                logg := drslog.GetLogger()

                // make sure at least one of the credentials params is provided
                if credFile == "" &amp;&amp; fenceToken == "" &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a credentials file or accessToken to setup project locally. Please provide either a --cred or --token flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                // When adding a new remote, bucket field is required.
                <span class="cov10" title="87">if bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a bucket name to be specified when adding a new remote. Please specify a bucket with --bucket flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                <span class="cov10" title="87">remoteName := config.ORIGIN
                if len(args) &gt; 0 </span><span class="cov10" title="87">{
                        remoteName = args[0]
                }</span>

                <span class="cov10" title="87">err := gen3Init(remoteName, credFile, fenceToken, project, bucket, logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error configuring gen3 server: %v", err)
                }</span>
                <span class="cov10" title="87">return nil</span>
        },
}

func gen3Init(remoteName, credFile, fenceToken, project, bucket string, log *log.Logger) error <span class="cov10" title="87">{
        if remoteName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote name is required")
        }</span>
        <span class="cov10" title="87">if project == "" || bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project and bucket are required for Gen3 remote")
        }</span>

        <span class="cov10" title="87">var accessToken, apiKey, keyID, apiEndpoint string
        configure := conf.NewConfigure(log)
        switch </span>{
        case fenceToken != "":<span class="cov0" title="0">
                accessToken = fenceToken
                var err error
                apiEndpoint, err = utils.ParseAPIEndpointFromToken(accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from provided access token: %w", err)
                }</span>

        case credFile != "":<span class="cov10" title="87">
                cred, err := configure.Import(credFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read credentials file %s: %w", credFile, err)
                }</span>
                <span class="cov10" title="87">accessToken = cred.AccessToken
                apiKey = cred.APIKey
                keyID = cred.KeyID

                apiEndpoint, err = utils.ParseAPIEndpointFromToken(cred.APIKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from API key in credentials file: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                existing, err := configure.Load(remoteName)
                if err == nil </span><span class="cov0" title="0">{
                        accessToken = existing.AccessToken
                        apiKey = existing.APIKey
                        keyID = existing.KeyID
                        apiEndpoint = existing.APIEndpoint
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("must provide either --cred or --token (or have existing profile %s)", remoteName)
                }</span>
        }

        <span class="cov10" title="87">if apiEndpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not determine Gen3 API endpoint")
        }</span>

        <span class="cov10" title="87">remoteGen3 := config.RemoteSelect{
                Gen3: &amp;indexd_client.Gen3Remote{
                        Endpoint:  apiEndpoint,
                        ProjectID: project,
                        Bucket:    bucket,
                },
        }

        remote := config.Remote(remoteName)
        if _, err := config.UpdateRemote(remote, remoteGen3); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update remote config: %w", err)
        }</span>
        <span class="cov10" title="87">log.Printf("Remote added/updated: %s  %s (project: %s, bucket: %s)", remoteName, apiEndpoint, project, bucket)

        // Step 3: Ensure credential profile is up-to-date (refreshes token if needed)
        cred := &amp;conf.Credential{
                Profile:            remoteName,
                APIEndpoint:        apiEndpoint,
                APIKey:             apiKey,
                KeyID:              keyID,
                AccessToken:        accessToken, // may be stale
                UseShepherd:        "false",     // or preserve from existing?
                MinShepherdVersion: "",
        }

        if err := configure.Save(cred); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure/update Gen3 profile: %w", err)
        }</span>

        <span class="cov10" title="87">log.Printf("Gen3 profile '%s' configured and token refreshed successfully", remoteName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package add

import "github.com/spf13/cobra"

var (
        server       string
        apiEndpoint  string
        bucket       string
        credFile     string
        fenceToken   string
        project      string
        terraProject string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "add",
        Short: "add server access for git-drs",
}

func init() <span class="cov10" title="1129">{
        Gen3Cmd.Flags().StringVar(&amp;server, "server", "gen3", "Options for DRS server: gen3 or anvil")
        Gen3Cmd.Flags().StringVar(&amp;apiEndpoint, "url", "", "[gen3] Specify the API endpoint of the data commons")
        Gen3Cmd.Flags().StringVar(&amp;bucket, "bucket", "", "[gen3] Specify the bucket name")
        Gen3Cmd.Flags().StringVar(&amp;credFile, "cred", "", "[gen3] Specify the gen3 credential file that you want to use")
        Gen3Cmd.Flags().StringVar(&amp;fenceToken, "token", "", "[gen3] Specify the token to be used as a replacement for a credential file for temporary access")
        Gen3Cmd.Flags().StringVar(&amp;project, "project", "", "[gen3] Specify the gen3 project ID in the format &lt;program&gt;-&lt;project&gt;")
        AnvilCmd.Flags().StringVar(&amp;terraProject, "terraProject", "", "[AnVIL] Specify the Terra project ID")

        Cmd.AddCommand(Gen3Cmd)
        Cmd.AddCommand(AnvilCmd)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS repos",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="2">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs remote list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov10" title="2">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="2">{
                logg := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Printf("Error loading config: %s", err)
                        return err
                }</span>

                <span class="cov10" title="2">for name, remoteSelect := range cfg.Remotes </span><span class="cov10" title="2">{
                        // Determine if this is the default
                        isDefault := name == cfg.DefaultRemote
                        marker := " "
                        if isDefault </span><span class="cov10" title="2">{
                                marker = "*"
                        }</span>

                        // Determine remote type and endpoint
                        <span class="cov10" title="2">var remoteType string
                        var remote config.DRSRemote
                        if remoteSelect.Gen3 != nil </span><span class="cov10" title="2">{
                                remoteType = string(config.Gen3ServerType)
                                remote = remoteSelect.Gen3
                        }</span> else<span class="cov0" title="0"> if remoteSelect.Anvil != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.AnvilServerType)
                                remote = remoteSelect.Anvil
                        }</span> else<span class="cov0" title="0"> {
                                remoteType = "unknown"
                        }</span>

                        <span class="cov10" title="2">endpoint := "N/A"
                        if remote != nil </span><span class="cov10" title="2">{
                                endpoint = remote.GetEndpoint()
                        }</span>

                        <span class="cov10" title="2">fmt.Printf("%s %-10s %-8s %s\n", marker, name, remoteType, endpoint)</span>
                }
                <span class="cov10" title="2">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package remote

import (
        "github.com/calypr/git-drs/cmd/remote/add"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "remote",
        Short: "Manage remote DRS server configs",
}

func init() <span class="cov10" title="1129">{
        Cmd.AddCommand(add.Cmd)
        Cmd.AddCommand(ListCmd)
        Cmd.AddCommand(SetCmd)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var SetCmd = &amp;cobra.Command{
        Use:   "set &lt;remote-name&gt;",
        Short: "Set the default DRS remote",
        Long:  "Set which DRS remote to use by default for all operations",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (remote name), received %d\n\nUsage: %s\n\nRun 'git drs remote list' to see available remotes or 'git drs remote set --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                remoteName := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                // validate remote exists
                <span class="cov0" title="0">remote := config.Remote(remoteName)
                if _, ok := cfg.Remotes[remote]; !ok </span><span class="cov0" title="0">{
                        availableRemotes := make([]string, 0, len(cfg.Remotes))
                        for name := range cfg.Remotes </span><span class="cov0" title="0">{
                                availableRemotes = append(availableRemotes, string(name))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf(
                                "remote '%s' not found.\nAvailable remotes: %v",
                                remoteName,
                                availableRemotes,
                        )</span>
                }

                // save new default
                <span class="cov0" title="0">cfg.DefaultRemote = remote

                if err := config.SaveConfig(cfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save config: %w", err)
                }</span>

                <span class="cov0" title="0">logger.Printf("Default remote set to: %s", remoteName)
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package cmd

import (
        "github.com/calypr/git-drs/cmd/addref"
        "github.com/calypr/git-drs/cmd/addurl"
        "github.com/calypr/git-drs/cmd/cache"
        "github.com/calypr/git-drs/cmd/delete"
        "github.com/calypr/git-drs/cmd/deleteproject"
        "github.com/calypr/git-drs/cmd/download"
        "github.com/calypr/git-drs/cmd/fetch"
        "github.com/calypr/git-drs/cmd/initialize"
        "github.com/calypr/git-drs/cmd/list"
        "github.com/calypr/git-drs/cmd/listconfig"
        "github.com/calypr/git-drs/cmd/prepush"
        "github.com/calypr/git-drs/cmd/push"
        "github.com/calypr/git-drs/cmd/query"
        "github.com/calypr/git-drs/cmd/register"
        "github.com/calypr/git-drs/cmd/remote"
        "github.com/calypr/git-drs/cmd/transfer"
        "github.com/calypr/git-drs/cmd/transferref"
        "github.com/calypr/git-drs/cmd/version"
        "github.com/spf13/cobra"
)

// RootCmd represents the root command
var RootCmd = &amp;cobra.Command{
        Use:   "git-drs",
        Short: "Git DRS - Git-LFS file management for DRS servers",
        Long:  "Git DRS provides the benefits of Git-LFS file management using DRS for seamless integration with Gen3 servers",
        PersistentPreRun: func(cmd *cobra.Command, args []string) {<span class="cov10" title="1129">
                //pre-run code can go here
        }</span>,
}

func init() <span class="cov10" title="1129">{
        RootCmd.AddCommand(addref.Cmd)
        RootCmd.AddCommand(cache.Cmd)
        RootCmd.AddCommand(delete.Cmd)
        RootCmd.AddCommand(deleteproject.Cmd)
        RootCmd.AddCommand(register.Cmd)
        RootCmd.AddCommand(download.Cmd)
        RootCmd.AddCommand(initialize.Cmd)
        RootCmd.AddCommand(list.Cmd)
        RootCmd.AddCommand(list.ListProjectCmd)
        RootCmd.AddCommand(listconfig.Cmd)
        RootCmd.AddCommand(prepush.Cmd)
        RootCmd.AddCommand(query.Cmd)
        RootCmd.AddCommand(transfer.Cmd)
        RootCmd.AddCommand(transferref.Cmd)
        RootCmd.AddCommand(version.Cmd)
        RootCmd.AddCommand(addurl.AddURLCmd)
        RootCmd.AddCommand(remote.Cmd)
        RootCmd.AddCommand(fetch.Cmd)
        RootCmd.AddCommand(push.Cmd)

        RootCmd.CompletionOptions.HiddenDefaultCmd = true
        RootCmd.SilenceUsage = true
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package transfer

import (
        "bufio"
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/spf13/cobra"
)

// TransferJob carries the raw JSON data and shared client
type TransferJob struct {
        data      []byte
        drsClient client.DRSClient
}

// TransferResult sent back to the single writer
type TransferResult struct {
        data    any
        isError bool
}

var (
        // Set once after init  determines which path all workers take
        transferOperation string    // "upload" or "download"
        sConfig           sonic.API = sonic.ConfigFastest
)

const (
        OPERATION_UPLOAD   = "upload"
        OPERATION_DOWNLOAD = "download"
)

var Cmd = &amp;cobra.Command{
        Use:   "transfer",
        Short: "[RUN VIA GIT LFS] register LFS files into gen3 during git push",
        Long:  `[RUN VIA GIT LFS] git-lfs transfer mechanism<span class="cov4" title="96"> to register LFS files up to gen3 during git push. For new files, creates an indexd record and uploads to the bucket`,
        RunE: func(cmd *cobra.Command, args []string) error {
                logger := drslog.GetLogge</span>r()
                if drslog.TraceEnabled() {
                        logger.Print("~~~~~~~~~~~~~ START: drs transfer ~~~~~~~~~~~~~")
                }

                // Gotta go fast  big buffer
                scanner := bufio.NewScanner(os.Stdin)
                const maxCapacity = 10 * 1024 * 1024 // 10 MB
                buf := make([]byte, 0, 64*1024)
                scanner.Buffer(buf, maxCapacity)
                output := bufio.New</span></span></span></span>Writer(os.Stdout)
                streamEncoder := encoder.NewStreamEncoder(output)
                flushOutput := func</span>() </span>{
                        if err := output.Flush(); err != nil {
                                logger.Printf("Error flushing stdout: %v", err)
                        </span>}
                }

</span></span></span>                // Read init message
                if !scanner.Scan() {
                        err := fmt.Errorf("failed to read initial message from stdin</span></span>")
                        logger.Printf("Error: %v", err)
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
</span>                        flushOutput()
                        return err
                }</span></span>

</span></span>                initBytes := make([]byte, len(scanner.Bytes()))
                copy(initBytes, scanner.Bytes())
                var initMsg lfs.InitMessage
                if err := sConfig.Unmarshal(initBytes, &amp;initMsg); err != nil {
                        </span></span></span>logger.Printf("Error decoding initial JSON message: %v", err)
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>flushOutput()
                        return err
                }</span>

                if initMsg.Eve</span>nt != "init" {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%s'", initMsg.Event)
                        logger.Printf</span></span>("Error: %v", err)
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>flushOutput()
                        return err
                }</span></span>

                var drsClient </span>client.DRSClient

                // Load config first
                cfg, err := config.LoadConfig()
                if err != nil </span>{
</span></span>                        logger.Printf("Error loading config: %v", err)
                        </span>lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        flushOutput()
                        return err
                }</span></span>

                /</span></span>/ Determine remote
                remote, err := cfg.GetDefaultRemote()
                i</span>f err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Error getting default remote: %v", err)
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        flushOutput()
                        return err
                }</span></span></span></span>
</span>
                drsClient, err = cfg.GetRemoteClient(remote, logger)
                if err != nil {
                        </span></span></span>logger.Printf("Error creating DRS client: %v", err)
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        flushOutput()
                        return err
                }</span></span></span></span>

</span>                // Determine if upload or download
                if initMsg.Operation == OPERATION_UPLOAD || initMsg.Operation == OPERATION_DOWNLOAD {
                        </span></span>transferOperation = initMsg.Operation
                        if drslog.Trac</span></span>eEnabled() </span>{
                                logger.Printf("Transfer operation: %s", transferOperation)
                        }
</span></span></span>                } else {
                        err := fmt.Err</span>orf("invalid or missing operation in init message: %s", initMsg.Operation)
                        logger.Print(err.Error())
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span></span></span>
                if err := streamEncoder.Encode(map[string]any{}); err != nil {
                        logger.Printf("Error sending init acknowledgment: %v", err)
                        return err
</span></span></span></span>                }</span>
                flu</span>shOutput()

                for scanner</span>.Scan() </span><span class="cov5" title="360">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span></span>{
                                logger.Printf("error decoding JSON: %s", err)
                                continue
                        }
</span></span></span>
                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" {
                                // Handle download event
                                if drslog</span></span></span>.TraceEnabled() {
</span></span>                                        logger.Printf("Download requested")
                                }</span>
</span>
                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err :=</span></span> sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil {
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v", err)
                                        logger.P</span></span>rint(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, "", 400, errMsg)
                                        flushOutput()
                                        continue</span></span>
</span>                                }
                                if drslog.TraceEnabled() {
                                        logger.P</span>rintf("Downloading file OID %s", downloadMsg.Oid)
                                }
</span></span></span>
                                <span class="cov4" title="52">// get signed url
                                accessUrl, err</span> := drsClient.GetDownloadURL(downloadMsg.Oid)
                                if err != nil </span>{
                                        errMsg := fmt.Sprintf("Error getting signed URL for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Print(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        flushOut</span>put()
                                        continue</span>
                                <span class="cov2" title="12">}
                                if accessUrl.U</span>RL == "" </span>{
                                        errMsg := fmt.Sprintf("Unable to get access URL for OID %s", downloadMsg.Oid)
                                        logger.Print(errMsg)
</span>                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        flushOut</span>put()
                                        continue</span></span>
                                }

                                // download signed url
                                dstPath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, downloadMsg.Oid)
                                if err != nil {
</span></span></span></span>                                        errMsg := fmt.Sprintf("Error getting destination path for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Print(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        flushOutput()
                                        continue</span></span></span></span>
                                }
</span>                                progress := newProgressReporter(downloadMsg.Oid, downloadMsg.Size, streamEncoder, output)
                                err = s3_utils</span>.DownloadSignedUrlWithProgress(accessUrl.URL, dstPath, func(delta int64) {
</span></span>                                        if err := progress.Report(delta); err != nil {
                                                logger.Printf("Error reporting download progress for OID %s: %v", downloadMsg.Oid, err)
                                        }
                                })
</span></span></span></span>                                if err != nil {
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Print(errMsg)
                                        lfs.Writ</span></span>eErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        flushOutput()
                                        continue</span></span>
</span></span>                                }
                                i</span>f err := progress.Finalize(); err != nil {
</span></span>                                        logger.Printf("Error finalizing download progress for OID %s: %v", downloadMsg.Oid, err)
                                }</span>
</span>
                                // send success message back
                                if drslog.TraceEnabled() {
                                        logger.P</span></span></span></span>rintf("Download for OID %s complete", downloadMsg.Oid)
                                }</span>

</span>                                <span class="cov3" title="36">lfs.WriteCompleteMessage(streamEncoder, downloadMsg.Oid, dstPath)
                                flushOutput()</span>
</span>
                        } </span>else<span class="cov5" title="324"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov3" title="36">{
                                // Handle upload event
                                if drslog.TraceEnabled() </span>{
</span>                                        logger.Printf("Upload requested")
                                }</span></span>

</span>                                // create UploadMessage from the received message
                                <span class="cov3" title="36">var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v", err)
                                        logger.Print(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 400, errMsg)
                                        flushOutput()
                                        continue</span></span></span>
</span>                                }
                        </span>        <span class="cov3" title="36">if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                                        logger.Printf("Uploading file OID %s", uploadMsg.Oid)
                                }</span></span>
                                <span class="cov3" title="36">progress := newProgressReporter(uploadMsg.Oid, uploadMsg.Size, streamEncoder, output)
                                type progressCapableClient interface {
                                        RegisterFileWithProgress(oid string, reportBytes func(int64)) (*drs.DRSObject, error)
                                }
                                var drsObj *drs.DRSObject
                                if progressClient, ok := drsClient.(progressCapableClient); ok </span><span class="cov3" title="36">{
                                        drsObj, err = progressClient.RegisterFileWithProgress(uploadMsg.Oid, func(delta int64) </span><span class="cov7" title="5814">{
                                                if err := progress.Report(delta); err != nil </span><span class="cov0" title="0">{
                                                        logger.Printf("Error reporting upload progress for OID %s: %v", uploadMsg.Oid, err)
                                                }</span>
                                        })
                                } else<span class="cov0" title="0"> {
                                        drsObj, err = drsClient.RegisterFile(uploadMsg.Oid)
                                }</span>
                                <span class="cov3" title="36">if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error registering file: %v\n", err)
                                        logger.Print(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 502, errMsg)
                                        flushOutput()
                                        continue</span>
                                }
                                <span class="cov3" title="36">if err := progress.Finalize(); err != nil </span><span class="cov0" title="0">{
                                        logger.Printf("Error finalizing upload progress for OID %s: %v", uploadMsg.Oid, err)
                                }</span>
                                // send success message back
                                <span class="cov3" title="36">lfs.WriteCompleteMessage(streamEncoder, uploadMsg.Oid, drsObj.Name)
                                flushOutput()
                                if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                                        logger.Printf("Upload for OID %s complete", uploadMsg.Oid)
                                }</span>

                        } else<span class="cov5" title="288"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov5" title="288">{
                                if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                                        logger.Printf("LFS transfer complete")
                                }</span>
                        }
                }

                <span class="cov5" title="288">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        logger.Printf("stdin error: %s", err)
                }</span>

                <span class="cov5" title="288">if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                        logger.Print("~~~~~~~~~~~~~ COMPLETED: custom transfer ~~~~~~~~~~~~~")
                }</span>
                <span class="cov5" title="288">return nil</span>

        },
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package transfer

import (
        "bufio"
        "sync"
        "sync/atomic"
        "time"

        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/lfs"
)

type progressReporter struct {
        oid            string
        size           int64
        encoder        *encoder.StreamEncoder
        output         *bufio.Writer
        lastEmit       time.Time
        lastReported   int64
        bytesSoFar     int64
        minInterval    time.Duration
        minBytesToEmit int64
        mu             sync.Mutex
}

func newProgressReporter(oid string, size int64, encoder *encoder.StreamEncoder, output *bufio.Writer) *progressReporter <span class="cov4" title="74">{
        return &amp;progressReporter{
                oid:            oid,
                size:           size,
                encoder:        encoder,
                output:         output,
                minInterval:    200 * time.Millisecond,
                minBytesToEmit: 256 * 1024,
        }
}</span>

func (p *progressReporter) Report(delta int64) error <span class="cov9" title="97457">{
        if delta &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov9" title="97457">bytesSoFar := atomic.AddInt64(&amp;p.bytesSoFar, delta)
        return p.maybeEmit(bytesSoFar, false)</span>
}

func (p *progressReporter) Finalize() error <span class="cov4" title="73">{
        bytesSoFar := atomic.LoadInt64(&amp;p.bytesSoFar)
        if p.size &gt; 0 </span><span class="cov4" title="73">{
                bytesSoFar = p.size
                atomic.StoreInt64(&amp;p.bytesSoFar, bytesSoFar)
        }</span>
        <span class="cov4" title="73">return p.maybeEmit(bytesSoFar, true)</span>
}

func (p *progressReporter) maybeEmit(bytesSoFar int64, force bool) error <span class="cov10" title="97530">{
        p.mu.Lock()
        defer p.mu.Unlock()

        bytesSinceLast := bytesSoFar - p.lastReported
        if bytesSinceLast &lt;= 0 </span><span class="cov4" title="54">{
                return nil
        }</span>

        <span class="cov9" title="97476">if !force </span><span class="cov9" title="97457">{
                if time.Since(p.lastEmit) &lt; p.minInterval &amp;&amp; bytesSinceLast &lt; p.minBytesToEmit &amp;&amp; (p.size &lt;= 0 || bytesSoFar &lt; p.size) </span><span class="cov9" title="95208">{
                        return nil
                }</span>
        }

        <span class="cov7" title="2268">lfs.WriteProgressMessage(p.encoder, p.oid, bytesSoFar, bytesSinceLast)
        if err := p.output.Flush(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="2268">p.lastReported = bytesSoFar
        p.lastEmit = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package transferref

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var (
        drsClient client.DRSClient
        sConfig   sonic.API = sonic.ConfigFastest
)

// TODO: used for AnvIL use case, requires implementation
var Cmd = &amp;cobra.Command{
        Use:   "transfer-ref",
        Short: "[RUN VIA GIT LFS] handle transfers of existing DRS object into git during git push",
        Long:  "[RUN VIA GIT LFS] custom transfer mechanism to pull LFS files during git lfs pull. Does nothing on push.",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                //setup logging to file for debugging
                myLogger := drslog.GetLogger()

                myLogger.Print("~~~~~~~~~~~~~ START: custom anvil transfer ~~~~~~~~~~~~~")

                scanner := bufio.NewScanner(os.Stdin)
                encoder := encoder.NewStreamEncoder(os.Stdout)

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("Error loading config: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">var remoteName string

                // Read the first (init) message outside the main loop
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        myLogger.Printf("Error: %s", err)
                        // No OID yet, so pass empty string
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">var initMsg map[string]any
                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("error decoding initial JSON message: %s", err)
                        return err
                }</span>

                // Handle "init" event and extract remote
                <span class="cov0" title="0">if evt, ok := initMsg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                        // if no remote name specified, use default remote
                        defaultRemote, err := cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Printf("Error getting default remote: %v", err)
                                lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">remoteName = string(defaultRemote)
                        myLogger.Printf("Initializing connection, remote not specified  using default: %s", remoteName)

                        // Respond with an empty json object via stdout
                        encoder.Encode(struct{}{})</span>
                } else<span class="cov0" title="0"> {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%v'", initMsg["event"])
                        myLogger.Printf("Error: %s", err)
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">drsClient, err = cfg.GetRemoteClient(config.Remote(remoteName), myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("Error creating indexd client: %s", err)
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Printf("error decoding JSON: %s", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">myLogger.Printf("Received message: %s", msg)

                        // Example: handle only "init" event
                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                                // Log for debugging
                                myLogger.Printf("Handling init: %s", msg)

                                // Respond with an empty json object via stdout
                                encoder.Encode(struct{}{})
                                myLogger.Print("Responding to init with empty object")
                        }</span> else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov0" title="0">{
                                // Handle download event
                                myLogger.Printf("Handling download event: %s", msg)

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v\n", err)
                                        myLogger.Print(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                // call DRS Downloader via downloadFile
                                <span class="cov0" title="0">dstPath, err := downloadFile(config.Remote(remoteName), downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v\n", downloadMsg.Oid, err)
                                        myLogger.Print(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 500, errMsg)
                                        continue</span>
                                }

                                <span class="cov0" title="0">myLogger.Printf("Downloaded file for OID %s", downloadMsg.Oid)

                                // send success message back
                                myLogger.Printf("Download for OID %s complete", downloadMsg.Oid)
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   downloadMsg.Oid,
                                        Path:  dstPath,
                                }
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov0" title="0">{
                                // Handle upload event
                                myLogger.Printf("Handling upload event: %s", msg)
                                myLogger.Printf("skipping upload, just registering existing DRS object")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v\n", err)
                                        myLogger.Print(errMsg)
                                        lfs.WriteErrorMessage(encoder, uploadMsg.Oid, 400, errMsg)
                                }</span>
                                <span class="cov0" title="0">myLogger.Printf("Got UploadMessage: %+v\n", uploadMsg)

                                // send success message back
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   uploadMsg.Oid,
                                }
                                myLogger.Printf("Complete message: %+v", completeMsg)
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov0" title="0">{
                                // Handle terminate event
                                myLogger.Printf("terminate event received: %s", msg)
                        }</span>
                }

                <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        myLogger.Printf("stdin error: %s", err)
                }</span>

                <span class="cov0" title="0">myLogger.Print("~~~~~~~~~~~~~ COMPLETED: custom anvil transfer ~~~~~~~~~~~~~")

                return nil</span>
        },
}

func downloadFile(remote config.Remote, sha string) (string, error) <span class="cov0" title="0">{
        myLogger := drslog.GetLogger()

        myLogger.Printf("Downloading file for sha %s", sha)

        // get terra project
        cfg, err := config.LoadConfig() // should this be handled only via indexd client?
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>

        <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remote, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">terraProject := cli.GetProjectId()

        filePath, err := drsmap.GetObjectPath(projectdir.DRS_REF_DIR, sha)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting object path for sha %s: %v", sha, err)
        }</span>
        <span class="cov0" title="0">myLogger.Printf("File path for sha %s: %s", sha, filePath)

        // get DRS URI in the second line of the file
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        myLogger.Printf("Opened file %s for reading", filePath)

        scanner := bufio.NewScanner(file)
        var drsUri string
        lineNum := 0
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNum++
                line := scanner.Text()
                myLogger.Printf("Reading line %d: %s", lineNum, line)
                if lineNum == 2 </span><span class="cov0" title="0">{
                        // second line should be the DRS URI
                        drsUri = strings.TrimSpace(line)
                        myLogger.Printf("DRS URI found: %s", drsUri)
                        break</span>
                }
        }

        <span class="cov0" title="0">myLogger.Printf("DRS URI found: %s", drsUri)
        if drsUri == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error: file %s does not contain a valid DRS URI in the second line", filePath)
        }</span>
        <span class="cov0" title="0">drsObj, err := drsClient.GetObject(drsUri)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error fetching DRS object for URI %s: %v", drsUri, err)
        }</span>
        <span class="cov0" title="0">if drsObj == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no DRS object found for URI %s", drsUri)
        }</span>

        <span class="cov0" title="0">myLogger.Printf("DRS Object fetched: %+v", drsObj)

        // call DRS downloader as a binary, redirect output to log file
        logFile, err := os.OpenFile(projectdir.DRS_LOG_FILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        //TODO: This should be done in the DRSClient code
        // download file, make sure its name is the sha
        dstPath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, sha)
        dstDir := filepath.Dir(dstPath)
        cmd := exec.Command("drs_downloader", "terra", "--user-project", terraProject, "--manifest-path", filePath, "--destination-dir", dstDir)

        // write command to log file
        logFile.WriteString(fmt.Sprintf("Running command: %s\n", cmd.String()))

        cmd.Stdout = logFile
        cmd.Stderr = logFile
        cmdOut, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error running drs_downloader for sha %s: %s", sha, cmdOut)
        }</span>

        //rename file to sha
        <span class="cov0" title="0">tmpPath := filepath.Join(dstDir, drsObj.Name)
        err = os.Rename(tmpPath, dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error renaming downloaded file from %s to %s: %v", tmpPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return dstPath, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package version

import (
        "fmt"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Cmd represents the "version" command
var Cmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Get version",
        Long:  ``,
        Run: func(cmd *cobra.Command, args []string) <span class="cov4" title="5">{
                fmt.Println("git-drs", buildVersion())
        }</span>,
}

func buildVersion() string <span class="cov4" title="6">{
        tag := ""
        commit := ""
        if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov4" title="6">{
                if info.Main.Version != "" &amp;&amp; info.Main.Version != "(devel)" </span><span class="cov0" title="0">{
                        tag = info.Main.Version
                }</span>
                <span class="cov4" title="6">for _, setting := range info.Settings </span><span class="cov10" title="72">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                commit = setting.Value</span>
                        case "vcs.tag":<span class="cov0" title="0">
                                if tag == "" </span><span class="cov0" title="0">{
                                        tag = setting.Value
                                }</span>
                        }
                }
        }

        <span class="cov4" title="6">commitShort := commit
        if len(commitShort) &gt; 7 </span><span class="cov0" title="0">{
                commitShort = commitShort[:7]
        }</span>

        <span class="cov4" title="6">switch </span>{
        case tag != "" &amp;&amp; commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s", tag, commitShort)</span>
        case tag != "":<span class="cov0" title="0">
                return tag</span>
        case commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("dev-%s", commitShort)</span>
        default:<span class="cov4" title="6">
                return "dev-unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package config

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strings"

        "github.com/calypr/git-drs/client"
        anvil_client "github.com/calypr/git-drs/client/anvil"
        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "gopkg.in/yaml.v3"
)

// RemoteType represents the type of server being initialized
type RemoteType string
type Remote string

const (
        ORIGIN = "origin"

        Gen3ServerType  RemoteType = "gen3"
        AnvilServerType RemoteType = "anvil"
)

func AllRemoteTypes() []RemoteType <span class="cov0" title="0">{
        return []RemoteType{Gen3ServerType, AnvilServerType}
}</span>

func IsValidRemoteType(mode string) error <span class="cov0" title="0">{
        modeOptions := make([]string, len(AllRemoteTypes()))
        for i, m := range AllRemoteTypes() </span><span class="cov0" title="0">{
                modeOptions[i] = string(m)
        }</span>

        <span class="cov0" title="0">for _, validMode := range modeOptions </span><span class="cov0" title="0">{
                if mode == string(validMode) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid mode '%s'. Valid options are: %s", mode, strings.Join(modeOptions, ", "))</span>
}

// DRSRemote holds pointers to remote types
type DRSRemote interface {
        GetProjectId() string
        GetEndpoint() string
        GetBucketName() string
        GetClient(params map[string]string, logger *log.Logger) (client.DRSClient, error)
}

type RemoteSelect struct {
        Gen3  *indexd_client.Gen3Remote `yaml:"gen3,omitempty"`
        Anvil *anvil_client.AnvilRemote `yaml:"anvil,omitempty"`
}

// Config holds the overall config structure
type Config struct {
        DefaultRemote Remote                  `yaml:"default_remote,omitempty"`
        Remotes       map[Remote]RemoteSelect `yaml:"remotes"`
}

func (c Config) GetRemoteClient(remote Remote, logger *log.Logger) (client.DRSClient, error) <span class="cov9" title="930">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GetRemoteClient no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov9" title="930">if x.Gen3 != nil </span><span class="cov9" title="930">{
                configText, _ := yaml.Marshal(x.Gen3)
                configParams := make(map[string]string)
                yaml.Unmarshal(configText, configParams)
                configParams["remote_name"] = string(remote)
                return x.Gen3.GetClient(configParams, logger)
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil.GetClient(nil, logger)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("no valid remote configuration found for current remote: %s", remote)</span>
}

func (c Config) GetRemote(remote Remote) DRSRemote <span class="cov0" title="0">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if x.Gen3 != nil </span><span class="cov0" title="0">{
                return x.Gen3
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDefaultRemote returns the configured default remote with validation
func (c Config) GetDefaultRemote() (Remote, error) <span class="cov9" title="931">{
        if c.DefaultRemote == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "no default remote configured.\n"+
                                "Set one with: git drs remote set &lt;name&gt;\n"+
                                "Available remotes: %v",
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov9" title="931">if _, ok := c.Remotes[c.DefaultRemote]; !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "default remote '%s' not found in configuration.\n"+
                                "Available remotes: %v",
                        c.DefaultRemote,
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov9" title="931">return c.DefaultRemote, nil</span>
}

// GetRemoteOrDefault returns the specified remote if provided, otherwise returns the default remote
// This is a common pattern used across many commands that accept an optional --remote flag
func (c Config) GetRemoteOrDefault(remote string) (Remote, error) <span class="cov4" title="12">{
        if remote != "" </span><span class="cov1" title="1">{
                return Remote(remote), nil
        }</span>
        <span class="cov4" title="11">return c.GetDefaultRemote()</span>
}

// listRemoteNames returns a slice of all remote names for error messages
func (c Config) listRemoteNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(c.Remotes))
        for name := range c.Remotes </span><span class="cov0" title="0">{
                names = append(names, string(name))
        }</span>
        <span class="cov0" title="0">return names</span>
}

func getConfigPath() (string, error) <span class="cov10" title="1245">{
        topLevel, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="1245">configPath := filepath.Join(topLevel, projectdir.DRS_DIR, projectdir.CONFIG_YAML)
        return configPath, nil</span>
}

// updates and git adds a Git DRS config file
// this should handle three cases:
// 1. create a new config file if it does not exist / is empty
// 2. return an error if the config file is invalid
// 3. update the existing config file, making sure to combine the new serversMap with the existing one
func UpdateRemote(name Remote, remote RemoteSelect) (*Config, error) <span class="cov6" title="88">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check if file exists, if not create parent directory
        <span class="cov6" title="88">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // if file doesn't exist, create file. Otherwise, open the file for writing
        <span class="cov6" title="88">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="88">defer file.Close()

        // if file is not empty, unmarshal into Config
        var cfg Config
        if err := yaml.NewDecoder(file).Decode(&amp;cfg); err != nil </span><span class="cov6" title="88">{
                // if the file is empty, we can just create a new config
                cfg = Config{
                        Remotes: map[Remote]RemoteSelect{},
                }
        }</span>

        <span class="cov6" title="88">if cfg.Remotes == nil </span><span class="cov0" title="0">{
                cfg.Remotes = make(map[Remote]RemoteSelect)
        }</span>

        // Set as default if this is the first remote
        <span class="cov6" title="88">if len(cfg.Remotes) == 0 &amp;&amp; cfg.DefaultRemote == "" </span><span class="cov6" title="88">{
                cfg.DefaultRemote = name
        }</span>

        <span class="cov6" title="88">cfg.Remotes[name] = remote

        // overwrite the file using config
        file.Seek(0, 0)
        file.Truncate(0)
        if err := yaml.NewEncoder(file).Encode(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write config file: %w", err)
        }</span>
        <span class="cov6" title="88">return &amp;cfg, nil</span>
}

// load an existing config
func LoadConfig() (*Config, error) <span class="cov9" title="1046">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="1046">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("config file does not exist. Please run 'git drs init', see 'git drs init --help' for more details")
        }</span>

        <span class="cov9" title="1044">reader, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open config file at %s", configPath)
        }</span>
        <span class="cov9" title="1044">defer reader.Close()

        b, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read config file at %s", configPath)
        }</span>

        <span class="cov9" title="1044">conf := Config{}
        err = yaml.Unmarshal(b, &amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config file at %s is invalid: %w", configPath, err)
        }</span>

        // Validate: if remotes exist but no default, error with migration instructions
        // FIXME: can be deleted after internal dev team ports over
        <span class="cov9" title="1044">if len(conf.Remotes) &gt; 0 &amp;&amp; conf.DefaultRemote == "" </span><span class="cov1" title="1">{
                remoteNames := make([]string, 0, len(conf.Remotes))
                for name := range conf.Remotes </span><span class="cov1" title="1">{
                        remoteNames = append(remoteNames, string(name))
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf(
                        "configuration migration required.\n\n" +
                                "Your config has remotes but no default_remote field.\n" +
                                "Add this line to .git/drs/config.yaml:\n\n" +
                                "  default_remote: &lt;remote-name&gt;\n\n" +
                                "or delete and recreate the config file by re-running\n\n" +
                                "  git drs remote add \n\n",
                )</span>
        }

        <span class="cov9" title="1043">return &amp;conf, nil</span>
}

func CreateEmptyConfig() error <span class="cov6" title="110">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="110">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov6" title="90">{
                if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // create empty config file
        <span class="cov6" title="110">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="110">defer file.Close()

        return nil</span>
}

func GetProjectId(remote Remote) (string, error) <span class="cov0" title="0">{
        cfg, err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>
        <span class="cov0" title="0">rmt := cfg.GetRemote(remote)
        if rmt == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov0" title="0">return rmt.GetProjectId(), nil</span>
}

// SaveConfig writes the configuration to disk
func SaveConfig(cfg *Config) error <span class="cov1" title="1">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        if err := yaml.NewEncoder(file).Encode(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package hash

import (
        "encoding/json"
        "fmt"
)

// ChecksumType represents the digest method used to create the checksum
type ChecksumType string

// IANA Named Information Hash Algorithm Registry values and other common types
const (
        ChecksumTypeSHA1     ChecksumType = "sha1"
        ChecksumTypeSHA256   ChecksumType = "sha256"
        ChecksumTypeSHA512   ChecksumType = "sha512"
        ChecksumTypeMD5      ChecksumType = "md5"
        ChecksumTypeETag     ChecksumType = "etag"
        ChecksumTypeCRC32C   ChecksumType = "crc32c"
        ChecksumTypeTrunc512 ChecksumType = "trunc512"
)

var SupportedChecksums = map[string]bool{
        string(ChecksumTypeSHA1):     true,
        string(ChecksumTypeSHA256):   true,
        string(ChecksumTypeSHA512):   true,
        string(ChecksumTypeMD5):      true,
        string(ChecksumTypeETag):     true,
        string(ChecksumTypeCRC32C):   true,
        string(ChecksumTypeTrunc512): true,
}

// IsValid checks if the checksum type is a known/recommended value
func (ct ChecksumType) IsValid() bool <span class="cov4" title="10">{
        switch ct </span>{
        case ChecksumTypeSHA256, ChecksumTypeSHA512, ChecksumTypeSHA1, ChecksumTypeMD5,
                ChecksumTypeETag, ChecksumTypeCRC32C, ChecksumTypeTrunc512:<span class="cov3" title="7">
                return true</span>
        default:<span class="cov2" title="3">
                return false</span>
        }
}

// String returns the string representation of the checksum type
func (ct ChecksumType) String() string <span class="cov8" title="206">{
        return string(ct)
}</span>

type Checksum struct {
        Checksum string       `json:"checksum"`
        Type     ChecksumType `json:"type"`
}

// HashInfo represents file hash information as per OpenAPI spec
// Patterns are documented for reference, but not enforced at struct level
// md5:    ^[0-9a-f]{32}$
// sha:    ^[0-9a-f]{40}$
// sha256: ^[0-9a-f]{64}$
// sha512: ^[0-9a-f]{128}$
// crc:    ^[0-9a-f]{8}$
// etag:   ^[0-9a-f]{32}(-\d+)?$
type HashInfo struct {
        MD5    string `json:"md5,omitempty"`
        SHA    string `json:"sha,omitempty"`
        SHA256 string `json:"sha256,omitempty"`
        SHA512 string `json:"sha512,omitempty"`
        CRC    string `json:"crc,omitempty"`
        ETag   string `json:"etag,omitempty"`
}

// UnmarshalJSON accepts both the DRS map-based schema and the array-of-checksums schema.
func (h *HashInfo) UnmarshalJSON(data []byte) error <span class="cov9" title="584">{
        if string(data) == "null" </span><span class="cov3" title="8">{
                *h = HashInfo{}
                return nil
        }</span>

        <span class="cov9" title="576">var mapPayload map[string]string
        if err := json.Unmarshal(data, &amp;mapPayload); err == nil </span><span class="cov9" title="575">{
                *h = ConvertStringMapToHashInfo(mapPayload)
                return nil
        }</span>

        <span class="cov1" title="1">var checksumPayload []Checksum
        if err := json.Unmarshal(data, &amp;checksumPayload); err == nil </span><span class="cov1" title="1">{
                *h = ConvertChecksumsToHashInfo(checksumPayload)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("unsupported HashInfo payload: %s", string(data))</span>
}

func ConvertStringMapToHashInfo(inputHashes map[string]string) HashInfo <span class="cov9" title="590">{
        hashInfo := HashInfo{}

        for key, value := range inputHashes </span><span class="cov10" title="597">{
                if !SupportedChecksums[key] </span><span class="cov2" title="4">{
                        continue</span> // Disregard unsupported types
                }
                // We use the string key directly in the switch statement.
                <span class="cov9" title="593">switch key </span>{
                case string(ChecksumTypeMD5):<span class="cov3" title="5">
                        hashInfo.MD5 = value</span>
                case string(ChecksumTypeSHA1):<span class="cov1" title="2">
                        hashInfo.SHA = value</span> // Maps to SHA field
                case string(ChecksumTypeSHA256):<span class="cov9" title="579">
                        hashInfo.SHA256 = value</span>
                case string(ChecksumTypeSHA512):<span class="cov1" title="2">
                        hashInfo.SHA512 = value</span>
                case string(ChecksumTypeCRC32C):<span class="cov1" title="2">
                        hashInfo.CRC = value</span> // Maps to CRC field
                case string(ChecksumTypeETag):<span class="cov1" title="2">
                        hashInfo.ETag = value</span>
                default:<span class="cov1" title="1"></span>
                }
        }

        <span class="cov9" title="590">return hashInfo</span>
}

// convertHashInfoToMap converts HashInfo struct to map[string]string
func ConvertHashInfoToMap(hashes HashInfo) map[string]string <span class="cov3" title="7">{
        result := make(map[string]string)
        if hashes.MD5 != "" </span><span class="cov2" title="4">{
                result["md5"] = hashes.MD5
        }</span>
        <span class="cov3" title="7">if hashes.SHA != "" </span><span class="cov1" title="1">{
                result["sha"] = hashes.SHA
        }</span>
        <span class="cov3" title="7">if hashes.SHA256 != "" </span><span class="cov2" title="4">{
                result["sha256"] = hashes.SHA256
        }</span>
        <span class="cov3" title="7">if hashes.SHA512 != "" </span><span class="cov1" title="1">{
                result["sha512"] = hashes.SHA512
        }</span>
        <span class="cov3" title="7">if hashes.CRC != "" </span><span class="cov1" title="1">{
                result["crc"] = hashes.CRC
        }</span>
        <span class="cov3" title="7">if hashes.ETag != "" </span><span class="cov1" title="1">{
                result["etag"] = hashes.ETag
        }</span>
        <span class="cov3" title="7">return result</span>
}

func ConvertChecksumsToMap(checksums []Checksum) map[string]string <span class="cov4" title="14">{
        result := make(map[string]string, len(checksums))
        for _, c := range checksums </span><span class="cov5" title="19">{
                // Uses the Checksum's Type (e.g., "sha256") as the key
                // and the Checksum's Checksum value as the map value.
                result[string(c.Type)] = c.Checksum
        }</span>
        <span class="cov4" title="14">return result</span>
}

// convertChecksumsToHashInfo is the main conversion logic needed for the structs.
// It converts the []Checksum slice to the HashInfo struct.
func ConvertChecksumsToHashInfo(checksums []Checksum) HashInfo <span class="cov4" title="11">{
        // 1. Convert the slice of Checksums into a map[string]string
        checksumMap := ConvertChecksumsToMap(checksums)

        // 2. Use the existing utility function to convert the map to HashInfo
        return ConvertStringMapToHashInfo(checksumMap)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package drs

import "github.com/calypr/git-drs/drs/hash"

type AccessURL struct {
        URL     string   `json:"url"`
        Headers []string `json:"headers"`
}

type Authorizations struct {
        //This structure is not stored in the file system
        Value string `json:"value"`
}

type AccessMethod struct {
        Type           string          `json:"type"`
        AccessURL      AccessURL       `json:"access_url"`
        AccessID       string          `json:"access_id,omitempty"`
        Cloud          string          `json:"cloud,omitempty"`
        Region         string          `json:"region,omitempty"`
        Available      string          `json:"available,omitempty"`
        Authorizations *Authorizations `json:"Authorizations,omitempty"`
}

type Contents struct {
}

type DRSPage struct {
        DRSObjects []DRSObject `json:"drs_objects"`
}

type DRSObjectResult struct {
        Object *DRSObject
        Error  error
}

type OutputObject struct {
        Id            string          `json:"id"`
        Name          string          `json:"name"`
        SelfURI       string          `json:"self_uri,omitempty"`
        Size          int64           `json:"size"`
        CreatedTime   string          `json:"created_time,omitempty"`
        UpdatedTime   string          `json:"updated_time,omitempty"`
        Version       string          `json:"version,omitempty"`
        MimeType      string          `json:"mime_type,omitempty"`
        Checksums     []hash.Checksum `json:"checksums"`
        AccessMethods []AccessMethod  `json:"access_methods"`
        Contents      []Contents      `json:"contents,omitempty"`
        Description   string          `json:"description,omitempty"`
        Aliases       []string        `json:"aliases,omitempty"`
}

type DRSObject struct {
        Id            string         `json:"id"`
        Name          string         `json:"name"`
        SelfURI       string         `json:"self_uri,omitempty"`
        Size          int64          `json:"size"`
        CreatedTime   string         `json:"created_time,omitempty"`
        UpdatedTime   string         `json:"updated_time,omitempty"`
        Version       string         `json:"version,omitempty"`
        MimeType      string         `json:"mime_type,omitempty"`
        Checksums     hash.HashInfo  `json:"checksums"`
        AccessMethods []AccessMethod `json:"access_methods"`
        Contents      []Contents     `json:"contents,omitempty"`
        Description   string         `json:"description,omitempty"`
        Aliases       []string       `json:"aliases,omitempty"`
}

// ConvertOutputObjectToDRSObject converts the OutputObject struct to a DRSObject struct.
func ConvertOutputObjectToDRSObject(in *OutputObject) *DRSObject <span class="cov10" title="8">{
        if in == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // 1. Convert the slice of Checksum structs to the HashInfo struct.
        <span class="cov9" title="7">hashInfo := hash.ConvertChecksumsToHashInfo(in.Checksums)

        // 2. Map all fields directly.
        return &amp;DRSObject{
                Id:          in.Id,
                Name:        in.Name,
                SelfURI:     in.SelfURI,
                Size:        in.Size,
                CreatedTime: in.CreatedTime,
                UpdatedTime: in.UpdatedTime,
                Version:     in.Version,
                MimeType:    in.MimeType,
                // The key conversion:
                Checksums: hashInfo,
                // Direct mapping for other fields:
                AccessMethods: in.AccessMethods,
                Contents:      in.Contents,
                Description:   in.Description,
                Aliases:       in.Aliases,
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package drs

import (
        "log"
        "os"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/projectdir"
)

// This file contains functions that pertain to .git/drs/lfs/objects directory walk
type PendingObject struct {
        OID  string
        Path string
}

// getPendingObjects walks .git/drs/lfs/objects/ to find all pending records
func GetPendingObjects(logger *log.Logger) ([]*PendingObject, error) <span class="cov1" title="1">{
        var objects []*PendingObject
        objectsDir := projectdir.DRS_OBJS_PATH

        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov9" title="5">if info.IsDir() </span><span class="cov6" title="3">{
                        return nil
                }</span>
                <span class="cov4" title="2">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Printf("Skipping malformed path: %s", path)
                        return nil
                }</span>
                <span class="cov1" title="1">oid := parts[2] // GetObjectPath stores full OID in the 3rd directory level
                objects = append(objects, &amp;PendingObject{
                        OID: oid,
                })
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Printf("Found %d pending objects in %s", len(objects), objectsDir)
        return objects, nil</span>
}

func GetDrsLfsObjects(logger *log.Logger) (map[string]*DRSObject, error) <span class="cov1" title="1">{
        objects := map[string]*DRSObject{}
        objectsDir := projectdir.DRS_OBJS_PATH
        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Printf("DRS objects directory not found: %s", objectsDir)
                return nil, nil
        }</span>

        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Error accessing path %s: %v", path, err)
                        return err
                }</span>
                <span class="cov10" title="6">if info.IsDir() </span><span class="cov6" title="3">{
                        return nil
                }</span>
                <span class="cov6" title="3">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="3">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Printf("Skipping malformed path: %s", path)
                        return nil
                }</span>
                <span class="cov4" title="2">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Error reading file %s: %v", path, err)
                        return err
                }</span>
                <span class="cov4" title="2">var drsObject DRSObject
                if err := sonic.ConfigFastest.Unmarshal(data, &amp;drsObject); err != nil </span><span class="cov1" title="1">{
                        logger.Printf("Error unmarshalling JSON from %s: %v", path, err)
                        return nil
                }</span>

                // This could be problematic
                <span class="cov1" title="1">if drsObject.Checksums.SHA256 != "" </span><span class="cov1" title="1">{
                        objects[drsObject.Checksums.SHA256] = &amp;drsObject
                }</span>

                <span class="cov1" title="1">logger.Printf("Successfully unmarshaled DRSObject from %s:\n%+v", path, drsObject)
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Printf("Found and unmarshaled %d DRS objects.", len(objects))
        return objects, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package drs

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/utils"
)

const DRS_DIR = ".git/drs"

type DrsWalkFunc func(path string, d *DRSObject) error

func BaseDir() (string, error) <span class="cov1" title="1">{
        gitTopLevel, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(gitTopLevel, DRS_DIR), nil</span>
}

type dirWalker struct {
        baseDir  string
        userFunc DrsWalkFunc
}

func (d *dirWalker) call(path string, dir fs.DirEntry, cErr error) error <span class="cov10" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov6" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">obj := DRSObject{}
        err = sonic.ConfigFastest.Unmarshal(data, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">relPath, err := filepath.Rel(d.baseDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return d.userFunc(relPath, &amp;obj)</span>
}

func ObjectWalk(f DrsWalkFunc) error <span class="cov1" title="1">{
        baseDir, err := BaseDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">ud := dirWalker{baseDir, f}
        return filepath.WalkDir(baseDir, ud.call)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package drslog

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strconv"
        "sync"

        "github.com/calypr/git-drs/projectdir"
)

var globalLogger *log.Logger
var globalLogFile io.Closer
var globalLoggerOnce sync.Once
var globalLoggerMu sync.RWMutex
var GIT_TRANSFER_TRACE int

func init() <span class="cov8" title="556">{
        GIT_TRANSFER_TRACE = 0
        if envValue := os.Getenv("GIT_TRANSFER_TRACE"); envValue != "" </span>{
                if parsed, err :=</span> strconv.Atoi(envValue); err == nil </span>{
                        GIT_TRANSFER_TRACE = parsed
                }
</span></span>        }
}
</span>
fu<span class="cov8" title="644">nc TraceEnabled() bool {
</span>        return GIT_TRANSFER_TRACE == 1
}</span>

// NewLogger cr</span><span class="cov0" title="0">eates a new Logger that writes to the specified file and optionally stderr.
// It is safe to call this multiple times; only the first successful call sets the global logger.
fu</span>nc NewLogger(filename string, logToStderr bool) (*log.Logger, error) <span class="cov8" title="590">{
        var writers []io.Writer

        if filename == "" </span>{
</span>                //create drs dir if it doesn't exist
                </span>if err := os.MkdirAll(projectdir.DRS_DIR, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                filename = filepath.Join(projectdir.DRS_DIR, "git-drs.log") // Assuming transfer.log is a variable
        }

        file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil {
                return nil, err
        }
        writers = append(writers, file)

        if logToStderr {
                writers = append(writer</span></span></span></span></span>s, os.Stderr)
        }</span>

        <span class="cov8" title="590">multiWriter := io.MultiWriter(writers...)

        // Create the core logger with Lshortfile for better debugging
        // Prefix log entries with PID for easier tracing in multi-process scenarios
        prefix := fmt.Sprintf("[%d] ", os.Getpid())
        core := log.New(multiWriter, prefix, log.LstdFlags|log.Lshortfile)

        globalLoggerMu.Lock()
        globalLogFile = file
        globalLogger = core
        globalLoggerMu.Unlock()

        return globalLogger, nil</span></span></span></span></span>
}
</span>
func GetLogger() *log.Logger {
        globalLoggerOnce.Do(func() {
                if globalLogger == nil {
                </span></span></span>        globalLogger = NewNoOpLogger()
                }</span>
</span>        })
        <span class="cov8" title="494">return globalLogger</span>
}

// Close closes the log file if open.
f</span>unc Close() error <span class="cov2" title="3">{
        globalLoggerMu.Lock()
        defer globalLoggerMu.Unlock()
        if globalLogFile != nil </span><span class="cov2" title="3">{
                err := globalLogFile.Close()

                globalLogFile = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewNoOpLogger returns a logger that discards all output (useful for testing or fallback).
func NewNoOpLogger() *log.Logger <span class="cov3" title="13">{
        return log.New(io.Discard, "", 0)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package drsmap

// Utilities to map between Git LFS files and DRS objects

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "github.com/google/uuid"
)

// NAMESPACE is the UUID namespace used for generating DRS UUIDs
var NAMESPACE = uuid.NewMD5(uuid.NameSpaceURL, []byte("calypr.org"))

type LfsDryRunSpec struct {
        Remote string // e.g. "origin"
        Ref    string // e.g. "refs/heads/main" or "HEAD"
}

// RunLfsPushDryRun executes: git lfs push --dry-run &lt;remote&gt; &lt;ref&gt;
func RunLfsPushDryRun(ctx context.Contex</span><span class="cov0" title="0">t, repoDir string, spec LfsDryRunSpec, logger *log.Logger) (string, error) {
        if spec.Remote == "" || spec.Ref == "" {
                </span></span>return "", errors.New("missing remote or ref")
        }</span>

        <span class="cov7" title="56">// Debug-print the command to stderr
        fullCmd := []string{"git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref}
        if drslog.TraceEnabled() {
                logger.Printf("running command: %v", fullCmd)
        }

        cmd := exec.CommandContext(ctx, "git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref)
        cmd.Dir = repoDir

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

</span></span></span>        err := cmd.Run()
        out := stdout.String()
        if err != nil </span></span>{
                m</span>sg := strings.TrimSpace(stderr.String())
                if msg == "" </span>{
</span>                        msg = err.Error()
                }</span>
</span>                <span class="cov0" title="0">return out, fmt.Errorf("git lfs push --dry-run failed: %s", msg)</span>
        }
        <span class="cov7" title="48">return out, nil</span>
}

// output of git lfs ls-files
type LfsLsOutput struct {
        Files []LfsFileInfo `json:"files"`
}

// LfsFileInfo represents the information about an LFS file
type LfsFileInfo struct {
        Name       string `json:"name"`
        Size       int64  `json:"size"`
        Checkout   bool   `json:"checkout"`
        Downloaded bool   `json:"downloaded"`
        OidType    string `json:"oid_type"`
        Oid        string `json:"oid"`
        Version    string `json:"version"`
}

func PushLocalD</span><span class="cov0" title="0">rsObjects(drsClient client.DRSClient, myLogger *log.Logger) error {
        // Gather all objects in .git/drs/lfs/objects store
        d</span>rsLfsObjs, err := drs.GetDrsLfsObjects(myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

</span>        // Make this a map if it does not exist when hitting the server
</span>        sums := make([]*hash.Checksum, 0)
</span>        for _, obj := range drsLfsObjs </span>{
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) {
                        if sumType == hash.ChecksumTypeSHA256.String() {
                                sums = append(sums, &amp;hash.Checksum{
                                </span></span></span>        Checksum: sum,
                                        Type:     hash.ChecksumTypeSHA256,
                                })
                        }</span>
        <span class="cov0" title="0">        }
        }
</span>
        outobjs := map[</span>string]*drs.DRSObject{}
        for _, sum := range sums </span>{
                r</span>ecords, err := drsClient.GetObjectByHash(sum)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span></span>

</span>                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                        continue</span>
                }
                found := false
</span>                // Warning: The loop overwrites map entries if multiple records have the same SHA256 hash.
                // If there are multiple records with SHA256 checksums, only the last one will be stored in the map
                for i, rec := range records </span></span>{
                        i</span>f rec.Checksums.SHA256 != "" </span><span class="cov0" title="0">{
                                found = true
                                outobjs[rec.Checksums.SHA256] = &amp;records[i]
                        }</span></span>
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                }</span>
</span>        }

</span>        for drsObjKey := range outobjs {
                v</span></span>al, ok := drsLfsObjs[drsObjKey]
                if !ok </span>{
</span>                        if drslog.TraceEnabled() </span>{
                                myLogger.Printf("Drs record not found in sha256 map %s", drsObjKey)
                        }
</span></span>                }
                if</span> _, statErr := os.Stat(val.Name); os.IsNotExist(statErr) </span><span class="cov0" title="0">{
                        if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                                myLogger.Printf("Error: Object record found locally, but file does not exist locally. Registering Record %s", val.Name)
                        }</span>
                        _, err = drsCl</span>ient.RegisterRecord(val)
                        if err != nil </span>{
                                </span>return err
                        }</span>

        <span class="cov0" title="0">        } else {
</span>                        _, err = drsClient.RegisterFile(drsObjKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
</span>        }
        r</span>eturn nil</span>
}<span class="cov0" title="0">

</span>func PullRemoteDrsObjects(</span><span class="cov0" title="0">drsClient client.DRSClient, logger *log.Logger) error {
        objChan, err := drsClient.ListObjectsByProject(drsClient.GetProjectId())
        if err != </span>nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0">
        writtenObjs := 0
</span>        for drsObj := range objChan </span>{
                i</span>f drsObj.Object == nil </span><span class="cov0" title="0">{
                        if drslog.TraceEnabled() </span>{
                                logger.Printf("OBJ is nil: %#v,</span> continuing...", drsObj)
                        }</span>
</span>                        continue
                }
                sumMap := hash.C</span></span>onvertHashInfoToMap(drsObj.Object.Checksums)
                if len(sumMap) == 0 </span>{
                        re</span>turn fmt.Errorf("error: drs Object '%s' does not contain a checksum", drsObj.Object.Id)
                }</span>
                <span class="cov0" title="0">var drsObjPath, oid string = "", ""
                for sumType, sum := range sumMap </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span>{
</span>                                oid = sum
                                drsObjPath, err = GetObjectPath(projectdir.DRS_OBJS_PATH, oid)
                                if err != nil {
                                        return fmt.E</span></span>rrorf("error getting object path for oid %s: %v", oid, err)
                                }</span>
                        }</span>
                }
                // Only write a record if there exists a proper checksum to use. Checksums besides sha256 are not used
        <span class="cov0" title="0">        if drsObjPath != "" &amp;&amp; oid != "" {
                        writtenO</span></span>bjs++
                        // write drs objects to DRS_OBJS_PATH
                        err = WriteDrsObj(drsObj.Object, oid, drsObjPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error writing DRS object for oid %s: %v", oid, err)
                        }</span>
                }
        }
        if drslog.TraceEnabled() {
                logger.Printf</span></span>("Wrote %d new objs to object store", writtenObjs)
        }</span>
        r</span>eturn nil</span>
}

f<span class="cov7" title="56">unc UpdateDrsObjects(drsClient client.DRSClient, gitRemoteName, gitRemoteLocation string, branches []string, logger *log.Logger) error {

</span>        if drslog.TraceEnabled() </span>{
                </span>logger.Print("Update to DRS objects started")
        }</span>

        // get all lfs files
        <span class="cov7" title="56">lfsFiles, err := GetAllLfsFile</span>s(gitRemoteName, gitRemoteLocation, branches, logger)
        if err != nil </span>{
                return fmt.Errorf("error getting all LFS files: %v", err)
        }
</span></span>
        //</span> get project
        <span class="cov7" title="48">projectId := drsClient.GetProjectId()
        if projectId == "" </span></span>{
                return fm</span>t.Errorf("no project configured: %v", err)
        }</span>

        // create a DRS object for each LFS file
        // which will be used at push-time
        <span class="cov7" title="48">for _, file := range lfsFiles </span><span class="cov7" title="48">{
                // check if indexd object already prepared, skip if so
                drsObjPath, err := GetObjectPath(projectdir.DRS_OBJS_PATH, file.Oid)
                if err != nil </span>{
                        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
                }
                if _, err := o</span></span>s.Stat(drsObjPath); err == nil </span>{
                        if drslog.TraceEnabled() {
                        </span></span>        logger.Printf("Skipping record creation, file %s with OID %s already exists in DRS objects path %s", file.Name, file.Oid, drsObjPath)
                        }</span>
</span>                        continue
                }</span></span>

                <span class="cov7" title="56">// if file is in cache, hasn't been committed to git or pushed to indexd
                // create a lo</span><span class="cov0" title="0">cal DRS object for it
                // TODO: determine git to gen3 project hierarchy mapping (eg repo name to project ID)
                d</span>rsId := DrsUUID(projectId, file.Oid)
                // logger.Printf("File: %s, OID: %s, DRS ID: %s\n", file.Name, file.Oid, drsId)

                // get file info needed to create indexd record
                path, err := GetObjectPath(projectdir.LFS_OBJS_PATH, file.Oid)
                if err != nil </span></span>{
                        </span>return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
                }</span>
</span>                <span class="cov7" title="48">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: File %s does not exist in LFS objects path %s. Aborting", file.Name, path)
                }</span>
</span>
                <span class="cov7" title="48">drsObj, err := drsClient.BuildDrsObj(file.Name, file.Oid, file.Size, drsId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error building DRS object for oid %s: %v", file.Oid, err)
                }</span>

</span>                // write drs objects to DRS_OBJS_PATH
                </span><span class="cov7" title="48">err = WriteDrsObj(drsObj, file.Oid, drsObjPath)
                if err != nil </span>{
</span>                        return fmt.Errorf("error writing DRS object for oid %s: %v", file.Oid, err)
                }</span>
</span>                <span class="cov7" title="48">if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                        logger.Printf("Prepared File %s OID %s with DRS ID %s for commit", file.Name, file.Oid, drsObj.Id)
                }</span>
        }
</span>
        r</span>eturn nil</span>
}<span class="cov7" title="56">
</span>
func WriteDrsObj(drsObj *drs.DRSObject, oid string, drsObjPath string) error <span class="cov7" title="48">{
        // get object bytes
        indexdObjBytes, err := sonic.ConfigFastest.Marshal(drsObj)
        if err != nil </span>{
                return fmt.Errorf("error marshalling indexd object for oid %s: %v", oid, err)
        </span>}</span>
        <span class="cov7" title="48">if err := os.MkdirAll(filepath.Dir(drsObjPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating directory for %s: %v", drsObjPath, err)
        }</span>

        // write indexd obj to file as json
        err = os.Write</span>File(drsObjPath, indexdObjBytes, 0644)
        if err != nil </span>{
                </span>return fmt.Errorf("error writing %s: %v", drsObjPath, err)
        }</span>
        <span class="cov7" title="48">return nil</span>
}
</span>
fu</span>nc DrsUUID(projectId string, hash string) string <span class="cov7" title="48">{
        // create UUID based on project ID and hash
        hashStr := fmt.Sprintf("%s:%s", projectId, hash)
        return uuid.NewSHA1(NAMESPACE, []byte(hashStr)).String()
}</span>
</span>
//</span> creates drsObject record from file
func DrsInfoFromOid(oid string) (*drs.DRSObject, error) <span class="cov7" title="48">{
        // unmarshal the DRS object
        path, err := GetObjectPath(projectdir.DRS_OBJS_PATH, oid)
        if err != nil </span></span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span>

</span>        drsObjBytes, err := os.ReadFile(path)
        i</span>f err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading DRS object for oid %s: %v", oid, err)
        }</span>
</span>
        <span class="cov7" title="48">var drsObject drs.DRSObject
        err = sonic.ConfigFastest.Unmarshal(drsObjBytes, &amp;drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov7" title="48">return &amp;drsObject, nil</span>
}

func GetObjectPath(basePath string, oid string) (string, error) {
        // check that oid is a valid sha256 hash
        if len(oid) !=</span> 64 </span>{
                return "", fmt.Errorf("error: %s is not a valid sha256 hash", oid)
        }

</span></span>        <span class="cov9" title="216">return filepath.Join(basePath, oid[:2], oid[2:4], oid), nil</span>
}

</span>////////////////
//</span> LFS HELPERS /
////////////////

/<span class="cov0" title="0">/ checkIfLfsFile checks if a given file is tracked by Git LFS
// Returns true and file info if it's an LFS file, false otherwise
func CheckIfLfs</span><span class="cov0" title="0">File(fileName string) (bool, *LfsFileInfo, error) {
        // Use git lfs ls-files -I to check if specific file is LFS tracked
        c</span>md := exec.Command("git", "lfs", "ls-files", "-I", fileName, "--json")
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If git lfs ls-files returns error, the file is not LFS tracked
                return false, nil, nil
        }</span></span></span>

        // If output is empty, file is not LFS tracked
        <span class="cov0" title="0">if len(strings.TrimSpace(string(out))) == 0 </span>{
                return false, nil, nil
        }

        // Parse the JSON output
        var lfsOutput LfsLsOutput
        err = sonic.ConfigFastest.Unmarshal(out, &amp;lfsOutput)
        if err != nil {
                return false, nil, fmt.Errorf("error unmarshaling git lfs ls-files output for %s: %v", fileName, err)
        }

        // If no files in output,</span></span></span></span> not LFS tracked
        <span class="cov0" title="0">if len(lfsOutput.Files) == 0 </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        // Convert to our LfsFileInfo struct
        file := lfsOutput.Files[0]
        lfsInfo := &amp;LfsFileInfo{
                Name:       file.Name,
                Size:       f</span>ile.Size,
                Checkout:   file.Checkout,
                Downloaded: file.Downloaded,
                OidType:    file.OidType,
                Oid:        file.Oid,
                Version:    file.Version,
        }

        return true, lfsInfo, nil</span></span></span>
}

func getStagedF</span><span class="cov0" title="0">iles() ([]string, error) {
        // chose exec here for performance over using go-git
        /</span>/ tradeoff is very rare concurrency problems which currently aren't relevant to the pre-commit
        // FIXME: filter out files that have been deleted? Bug: if git rm, the DRS object still created
        cmd := exec.Command("git", "diff", "--name-only", "--cached")
        cmdOut, err := cmd.Output()
        if err != nil </span>{
</span>                return nil, fmt.Errorf("error running git command: %w: out: '%s'", err, string(cmdOut))
        }</span>
        <span class="cov0" title="0">stagedFiles := strings.Split(strings.TrimSpace(string(cmdOut)), "\n")
        return stagedFiles, nil</span>
</span>}

</span>f<span class="cov7" title="56">unc GetRepoNameFromGit(remote string) (string, error) {
        // prefer simp</span>le os.Exec over using go-git
        cmd := exec.Command("git", "config", "--get", fmt.Sprintf("remote.%s.url", remote))
        out, err := cmd.Output()
        if err != nil </span></span><span class="cov0" title="0">{
                return "", err
        }</span>

        remoteURL := strings.TrimSpace(string(out))
        repoName := strings.TrimSuffix(filepath.Base(remoteURL), ".git")
        return repoName, nil
}

</span></span>func GetAllLfsFiles(gitRemoteName, gitRemoteLocation string, branches []string, logger *log.Logger) (map[string]LfsFileInfo, error) {
        i</span>f logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger is required")
        }</span></span>
        r</span>epoDir, err := os.Getwd()
        if err != nil </span>{
                </span>return nil, err
        }</span>

        // no timeout for now
        ctx := context.Background</span>()
        // If needed, can re-enable timeout
        // Set a timeout context for git commands, 3 minutes should be enough
        //ctx, cancel := context.WithTimeout(context.Background(), 180*time.Second)
        //defer cancel()

        if gitRemoteName == "" </span>{
</span>                gitRemoteName = "origin"
        }
</span></span>        <span class="cov7" title="48">if gitRemoteLocation != "" </span><span class="cov7" title="48">{
                if drslog.TraceEnabled() </span>{
</span>                        logger.Printf("Using git remote %s at %s for LFS dry-run", gitRemoteName, gitRemoteLocation)
                }</span></span>
        } else<span class="cov0" title="0"> {
                if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                        logger.Printf("Using git remote %s for LFS dry-run", gitRemoteName)
                }</span></span>
        }

        refs := buildLfsRefs(b</span>ranches)
        lfsFileMap := make(map[string]LfsFileInfo)
        for _, ref := range refs </span>{
</span>                spec := LfsDryRunSpec{
                        Remote: gitRemoteName,
                        Ref:    ref,
                }
                out, err := RunLfsPushDryRun(ctx, repoDir, spec, logger)
                if err != nil </span></span></span>{
</span>                        return nil, err
                }</span>

</span>                if err := addLfsFilesFromDryRun(out, repoDir, logger, lfsFileMap); err != nil {
                        </span></span>return nil, err
                }</span>
</span>        }
</span>
        <span class="cov7" title="48">return lfsFileMap, nil</span>
}
</span>
f<span class="cov7" title="56">unc buildLfsRefs(b</span><span class="cov0" title="0">ranches []string) []string {
        if len(branches) == 0 {
                </span></span>return []string{"HEAD"}
        }</span>
</span>        <span class="cov7" title="48">refs := make([]string, 0, len(branches))
        seen := make(map[string]struct{})
        for _, branch := range branches </span><span class="cov7" title="48">{
                branch = strings.TrimSpace(branch)
                if branch == "" </span>{
</span>                        continue</span>
                }
                </span><span class="cov7" title="48">ref := branch
                if branch != "HEAD" &amp;&amp; !strings.HasPrefix(branch, "refs/") </span><span class="cov7" title="48">{
                        ref = fmt.Sprintf("refs/heads/%s", branch)
                }</span>
                if _, ok := seen[ref]; ok {
                        continue
</span></span></span>                }
                seen[ref] = st</span>ruct{}{}
                refs = append(refs, ref)</span>
</span>        }
        <span class="cov7" title="48">if len(refs) == 0 </span>{
                return []string{"H</span>EAD"}
        }</span>
</span>        <span class="cov7" title="48">return refs</span>
}

func addLfsFilesFromDryRun(out, repoDir string, logger *log.Logger, lfsFileMap map[string]LfsFileInfo) error {
        // Log when dry-run returns no output to help with debugging
        if strings.TrimSpace(out) == ""</span> </span>{
                if drslog.TraceEnabled() {
                        logger.P</span></span>rintf("No LFS files to push (dry-run returned no output)")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

</span>        // accept lowercase or uppercase hex
        sha256Re :</span>= regexp.MustCompile(`(?i)^[a-f0-9]{64}$`)

        for _, line := range strings.Split(strings.TrimSpace(string(out)), "\n") </span><span class="cov7" title="72">{
                line = strings.TrimSpace(line)
                if line == "" </span>{
</span>                        continue</span>
                }</span>
                <span class="cov7" title="72">parts := strings.Fields(line)
                if len(parts) &lt; 2 </span>{
                        continue
</span></span>                }
                o</span>id := parts[1]
                path := parts[len(parts)-1]

                // Validate OID looks like a SHA256 hex string.
                if !sha256Re.MatchString(oid) </span></span></span>{
                        if drslog.TraceEnabled() {
</span></span>                                logger.Printf("skipping LFS line with invalid oid %q: %q", oid, line)
                        }</span></span>
                        <span class="cov0" title="0">continue</span>
                }

                // see https://github.com/calypr/git-drs/issues/124#issuecomment-3721837089
                <span class="cov7" title="72">if oid == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" &amp;&amp; strings.Contains(path, ".gitattributes") </span><span class="cov6" title="24">{
                        if drslog.TraceEnabled() </span>{</span>
                                logger.Printf("skipping empty LFS pointer for %s", path)
                        }</span></span>
                        continue
</span></span>                }
                // Remove a trailing parenthetical suffix from p, e.g.:
</span>                // "path/to/file.dat (100 KB)" -&gt; "path/to/file.dat"
                if i</span>dx := strings.LastIndex(path, " ("); idx != -1 &amp;&amp; strings.HasSuffix(path, ")") </span><span class="cov0" title="0">{
                        path = strings.TrimSpace(path[:idx])
                }</span></span>
                <span class="cov7" title="48">size := int64(0)
                absPath := path
                if repoDir != "" &amp;&amp; !filepath.IsAbs(path) </span><span class="cov7" title="48">{
                        absPath = filepath.Join(repoDir, path)
                }</span>
                if stat, err := os.Stat(absPath); err == nil {
                        size = stat.Size()
                } else {
                        if drslog.TraceEnabled() {
                        </span></span></span></span>        logger.Printf("could not stat file %s: %v", path, err)
                        }</span>
                        <span class="cov0" title="0">if _, fmtErr := fmt.Fprintf(os.Stderr, "could not stat file %s: %v\n", path, err); fmtErr != nil </span><span class="cov0" title="0">{
                                if drslog.TraceEnabled() </span><span class="cov0" title="0">{
                                        logger.Printf("error writing to stderr for %s: %v", path, fmtErr)
                                }</span></span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // If the file is small, read it and detect LFS pointer sign<span class="cov0" title="0">ature.
                // Pointer files are textual and include the LFS spec version + an oid line.
                if size &gt; 0 &amp;&amp; size &lt; 2048 {
</span></span>                        if data, readErr := os.ReadFile(absPath); readErr == nil </span>{
                </span>                s := strings.TrimSpace(string(data))
                                if strings.Contains(s, "version https://git-lfs.github.com/spec/v1") &amp;&amp; strings.Contains(s, "oid sha256:") </span>{
                                        if drslog.TraceEnabled() {
                                                logger.Printf("WARNING: Detected upload of lfs pointer file %s skipping", path)
                                        }
                                        if _, fprintfErr :=</span></span></span> fmt.Fprintf(os.Stderr, "WARNING: Detected upload of lfs pointer file %s\n", path); fprintfErr != nil </span>{
                                                if drslo</span>g.TraceEnabled() </span>{
                                                        logger.Printf("error writing to stderr for %s: %v", path, fprintfErr)
                                                }
</span></span>                                        }
                                        <span class="cov0" title="0">continue</span>
        <span class="cov0" title="0">                        }
</span>                        }
                </span>}

                lfsFileMap[path] = LfsFileInfo{
                        Name:    path,
</span>                        Size:    size,
                        OidType: "sha256",
                        Oid:     oid,
                        Version: "https://git-lfs.github.com/spec/v1",
                }</span>
                //logger.Printf("Get</span><span class="cov0" title="0">AllLfsFiles added LFS file %s", path)
        }

</span>        <span class="cov7" title="48">return nil</span>
}

// CreateCustom</span><span class="cov0" title="0">Path creates a custom path based on the DRS URI
// For example, DRS URI drs://&lt;namespace&gt;:&lt;drs_id&gt;
//</span> create custom path &lt;baseDir&gt;/&lt;namespace&gt;/&lt;drs_id&gt;
func CreateCustomPath(baseDir, drsURI string) (string, error) <span class="cov0" title="0">{
        const prefix = "drs://"
        if len(drsURI) &lt;= len(prefix) || drsURI[:len(prefix)] != prefix </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid DRS URI: %s", drsURI)
        }</span></span>
</span>        rest := drsURI[len(prefix):]

</span>        // Split by first colon
        colonIdx := -1
        for i, c := range rest </span></span>{
</span>                if c == ':' </span>{
                        c</span>olonIdx = i
                        break</span>
                }
        }
        <span class="cov0" title="0">if colonIdx == </span>-1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("DRS URI missing colon: %s", drsURI)
        }</span>
        <span class="cov0" title="0">namespace := rest[:colonIdx]
        drsId := rest[colonIdx+1:]
        return filepath.Join(baseDir, namespace, drsId), nil</span>
}

// FindMatchingRecord finds a record from the list that matches the given project ID authz
// If no matching record is found return nil
func FindMatchingRecord(records []drs.DRSObject, projectId string) (*drs.DRSObject, error) <span class="cov7" title="48">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Convert project ID to resource path format for comparison
        <span class="cov7" title="48">expectedAuthz, err := utils.ProjectToResource(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting project ID to resource format: %v", err)
        }</span>

        // Get the first record with matching authz if exists

        <span class="cov7" title="48">for _, record := range records </span><span class="cov7" title="48">{
                for _, access := range record.AccessMethods </span><span class="cov7" title="48">{
                        // assert access has Authorizations
                        if access.Authorizations == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("access method for record %v missing authorizations", record)
                        }</span>
                        <span class="cov7" title="48">if access.Authorizations.Value == expectedAuthz </span><span class="cov7" title="48">{
                                return &amp;record, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package drsmap

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
)

func CreateLfsPointer(drsObj *drs.DRSObject, dst string) error <span class="cov10" title="3">{
        sumMap := hash.ConvertHashInfoToMap(drsObj.Checksums)
        if len(sumMap) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no checksums found for DRS object")
        }</span>

        // find sha256 checksum
        <span class="cov6" title="2">var shaSum string
        for csType, cs := range sumMap </span><span class="cov6" title="2">{
                if csType == hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                        shaSum = cs
                        break</span>
                }
        }
        <span class="cov6" title="2">if shaSum == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("no sha256 checksum found for DRS object")
        }</span>

        // create pointer file content
        <span class="cov1" title="1">pointerContent := "version https://git-lfs.github.com/spec/v1\n"
        pointerContent += fmt.Sprintf("oid sha256:%s\n", shaSum)
        pointerContent += fmt.Sprintf("size %d\n", drsObj.Size)

        // write to file
        err := os.WriteFile(dst, []byte(pointerContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write LFS pointer file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/cmd"
        "github.com/calypr/git-drs/drslog"
)

func main() <span class="cov10" title="1129">{

        _, err := drslog.NewLogger("", true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open log file: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov10" title="1129">if err := cmd.RootCmd.Execute(); err != nil </span><span class="cov1" title="2">{
                drslog.Close() // closes log file if there was one
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package testutils

import (
        "os"
        "os/exec"
        "path/filepath"
        "testing"

        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/projectdir"
        "github.com/stretchr/testify/require"
        "gopkg.in/yaml.v3"
)

// SetupTestGitRepo creates a temp directory mocking a real git repo
func SetupTestGitRepo(t *testing.T) string <span class="cov10" title="3">{
        t.Helper()

        tmpDir, err := os.MkdirTemp("", "git-drs-test-*")
        require.NoError(t, err)

        originalDir, err := os.Getwd()
        require.NoError(t, err)

        err = os.Chdir(tmpDir)
        require.NoError(t, err)

        cmd := exec.Command("git", "init")
        cmd.Dir = tmpDir
        err = cmd.Run()
        require.NoError(t, err)

        cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        cmd = exec.Command("git", "config", "user.name", "Test User")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        t.Cleanup(func() </span><span class="cov10" title="3">{
                os.Chdir(originalDir)
                os.RemoveAll(tmpDir)
        }</span>)

        <span class="cov10" title="3">return tmpDir</span>
}

// CreateTestConfig creates a test Git DRS config file with the given content
func CreateTestConfig(t *testing.T, tmpDir string, cfg *config.Config) string <span class="cov0" title="0">{
        t.Helper()

        configDir := filepath.Join(tmpDir, projectdir.DRS_DIR)
        err := os.MkdirAll(configDir, 0755)
        require.NoError(t, err)

        configPath := filepath.Join(configDir, projectdir.CONFIG_YAML)
        file, err := os.Create(configPath)
        require.NoError(t, err)
        defer file.Close()

        encoder := yaml.NewEncoder(file)
        err = encoder.Encode(cfg)
        require.NoError(t, err)

        return configPath
}</span>

// CreateDefaultTestConfig creates a standard test configuration
func CreateDefaultTestConfig(t *testing.T, tmpDir string) *config.Config <span class="cov0" title="0">{
        t.Helper()

        testConfig := &amp;config.Config{
                Remotes: map[config.Remote]config.RemoteSelect{
                        config.Remote(config.ORIGIN): {
                                Gen3: &amp;indexd_client.Gen3Remote{
                                        Endpoint:  "https://test.gen3.org",
                                        ProjectID: "test-project",
                                        Bucket:    "test",
                                },
                        },
                },
        }

        CreateTestConfig(t, tmpDir, testConfig)
        return testConfig
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package testutils

import (
        "bytes"
        "io"
        "os"
        "testing"

        "github.com/stretchr/testify/require"
)

// CaptureStdout captures stdout during test execution
func CaptureStdout(t *testing.T, f func()) string <span class="cov10" title="5">{
        t.Helper()

        r, w, err := os.Pipe()
        require.NoError(t, err)

        oldStdout := os.Stdout
        os.Stdout = w

        defer func() </span><span class="cov10" title="5">{
                os.Stdout = oldStdout
        }</span>()

        <span class="cov10" title="5">outC := make(chan string)
        go func() </span><span class="cov10" title="5">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, r)
                outC &lt;- buf.String()
        }</span>()

        <span class="cov10" title="5">f()

        w.Close()
        output := &lt;-outC

        return output</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package lfs

import (
        "github.com/bytedance/sonic/encoder"
)

// InitMessage represents the structure of the initiation data
type InitMessage struct {
        Event               string `json:"event"`               // Always "init" to identify this message
        Operation           string `json:"operation"`           // "upload" or "download" depending on transfer direction
        Remote              string `json:"remote"`              // Git remote name or URL
        Concurrent          bool   `json:"concurrent"`          // Reflects lfs.customtransfer.&lt;name&gt;.concurrent
        ConcurrentTransfers int    `json:"concurrenttransfers"` // Reflects lfs.concurrenttransfers value
}

// CompleteMessage is a minimal response to signal transfer is "complete"
type CompleteMessage struct {
        Event string `json:"event"`
        Oid   string `json:"oid"`
        Path  string `json:"path,omitempty"`
}

// UploadMessage represents a request to upload an object.
type UploadMessage struct {
        Event  string  `json:"event"`  // "upload"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Path   string  `json:"path"`   // Local path to file
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
}

// DownloadMessage represents a request to download an object.
type DownloadMessage struct {
        Event  string  `json:"event"`  // "download"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
        Path   string  `json:"path"`   // Where to store the downloaded file
}

// TerminateMessage is sent when the agent should terminate.
type TerminateMessage struct {
        Event string `json:"event"` // "terminate"
}

// ErrorMessage is sent when an error occurs during a transfer.
type ErrorMessage struct {
        Event string `json:"event"` // "error"
        Oid   string `json:"oid"`   // Object ID involved in the error
        Error Error  `json:"error"` // Error details
}

type InitErrorMessage struct {
        Error Error `json:"error"` // Error details
}

type Error struct {
        Code    int    `json:"code"`    // Error code (standard or custom)
        Message string `json:"message"` // Human-readable error message
}

// ProgressResponse provides progress updates for an object transfer.
type ProgressResponse struct {
        Event          string `json:"event"`          // "progress"
        Oid            string `json:"oid"`            // Object ID being transferred
        BytesSoFar     int64  `json:"bytesSoFar"`     // Bytes transferred so far
        BytesSinceLast int64  `json:"bytesSinceLast"` // Bytes transferred since last progress message
}

// TerminateResponse signals the agent has completed termination.
type TerminateResponse struct {
        Event string `json:"event"` // "terminate"
}

// Action is an optional struct representing transfer actions (upload/download URLs, etc.)
type Action struct {
        Href      string            `json:"href"`
        Header    map[string]string `json:"header,omitempty"`
        ExpiresIn int               `json:"expires_in,omitempty"`
}

func WriteInitErrorMessage(encoder *encoder.StreamEncoder, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := InitErrorMessage{
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteErrorMessage(encoder *encoder.StreamEncoder, oid string, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := ErrorMessage{
                Event: "complete",
                Oid:   oid,
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteCompleteMessage(encoder *encoder.StreamEncoder, oid string, path string) <span class="cov7" title="205">{
        // create success message and send it back
        completeResponse := CompleteMessage{
                Event: "complete",
                Oid:   oid,
                Path:  path,
        }
        encoder.Encode(completeResponse)
}</span>

func WriteProgressMessage(encoder *encoder.StreamEncoder, oid string, bytesSoFar int64, bytesSinceLast int64) <span class="cov10" title="2269">{
        progressResponse := ProgressResponse{
                Event:          "progress",
                Oid:            oid,
                BytesSoFar:     bytesSoFar,
                BytesSinceLast: bytesSinceLast,
        }
        encoder.Encode(progressResponse)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package s3_utils

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
)

// downloads a file to a specified path using a signed URL
func DownloadSignedUrl(signedURL string, dstPath string) error <span class="cov1" title="2">{
        return DownloadSignedUrlWithProgress(signedURL, dstPath, nil)
}</span>

</span>// DownloadSignedUrlWithProgress downloads a file using a signed URL and reports bytes transferred.
fu</span>nc DownloadSignedUrlWithProgress(signedURL string, dstPath string, reportBytes func(int64)) error <span class="cov3" title="36">{
        // Download the file using the signed URL
        fileResponse, err := http.Get(signedURL)
        if err != nil </span>{
                return err
</span>        }</span>
        defer fileRespo</span>nse.Body.Close()

        // Check if the response status is OK
        if fileResponse.StatusCode != http.StatusOK </span></span>{
</span>                body, err := io.ReadAll(fileResponse.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download file using signed URL: %s", fileResponse.Status)
                }</span>
                return fmt.Er</span>rorf("failed to download file using signed URL: %s. Full error: %s", fileResponse.Status, string(body))</span>
        }

</span>        // Create the destination directory if it doesn't exist
        <span class="cov3" title="36">err = os.MkdirAll(filepath.Dir(dstPath), os.ModePerm)
        if err != nil </span>{
                return err
</span>        }</span>

</span>        <span class="cov4" title="64">// Create the destination file
        dstFile, err := os.Create(dstPath)
        if err != nil {
                return err
        }
</span></span></span>        defer dstFile.Close()

</span>        buffer := make([]byte, 32*1024)
        for </span>{
</span>                n, readErr := fileResponse.Body.Read(buffer)
                if n &gt; 0 </span><span class="cov10" title="91641">{
                        if _, writeErr := dstFile.Write(buffer[:n]); writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                        <span class="cov10" title="91641">if reportBytes != nil </span><span class="cov10" title="91641">{
                                reportBytes(int64(n))
                        }</span>
                }
                <span class="cov10" title="91641">if readErr == io.EOF </span><span class="cov3" title="36">{
                        break</span>
                }
                <span class="cov9" title="91605">if readErr != nil </span><span class="cov0" title="0">{
                        return readErr
                }</span>
        }

        <span class="cov3" title="36">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package s3_utils

import (
        "log"
        "net/http"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

type S3BucketsResponse struct {
        GSBuckets map[string]any       `json:"GS_BUCKETS"`
        S3Buckets map[string]*S3Bucket `json:"S3_BUCKETS"`
}

type S3Bucket struct {
        Region      string   `json:"region,omitempty"`
        EndpointURL string   `json:"endpoint_url,omitempty"`
        Programs    []string `json:"programs,omitempty"`
}

// S3Meta holds S3 object metadata
type S3Meta struct {
        Size         int64
        LastModified string
}

type CustomEndpointResolver struct {
        Endpoint string
}

const (
        AWS_KEY_FLAG_NAME          = "aws-access-key-id"
        AWS_SECRET_FLAG_NAME       = "aws-secret-access-key"
        AWS_KEY_ENV_VAR            = "AWS_ACCESS_KEY_ID"
        AWS_SECRET_ENV_VAR         = "AWS_SECRET_ACCESS_KEY"
        AWS_REGION_FLAG_NAME       = "region"
        AWS_REGION_ENV_VAR         = "AWS_REGION"
        AWS_ENDPOINT_URL_FLAG_NAME = "endpoint-url"
        AWS_ENDPOINT_URL_ENV_VAR   = "AWS_ENDPOINT_URL"
)

// AuthHandler is an interface for adding authentication headers
// This allows us to inject different auth implementations for testing vs production
type AuthHandler interface {
        AddAuthHeader(req *http.Request) error
}

func (r *CustomEndpointResolver) ResolveEndpoint(service, region string) (aws.Endpoint, error) <span class="cov10" title="3">{
        return aws.Endpoint{
                URL: r.Endpoint,
        }, nil
}</span>

// AddURLConfig holds optional clients for dependency injection
type AddURLConfig struct {
        S3Client   *s3.Client
        HttpClient *http.Client
        Logger     *log.Logger
}

// AddURLOption is a functional option for configuring AddURL
type AddURLOption func(*AddURLConfig)

// WithS3Client provides a custom S3 client to AddURL
func WithS3Client(client *s3.Client) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.S3Client = client
        }</span>
}

// WithHTTPClient provides a custom HTTP client to AddURL
func WithHTTPClient(client *http.Client) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.HttpClient = client
        }</span>
}

// WithLogger provides a custom logger to AddURL
func WithLogger(logger *log.Logger) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.Logger = logger
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package s3_utils

import (
        "encoding/hex"
        "errors"
        "strings"
)

func ValidateInputs(s3URL string, sha256 string) error <span class="cov10" title="42">{
        if !strings.HasPrefix(s3URL, "s3://") </span><span class="cov6" title="9">{
                return errors.New("invalid S3 URL format. URL should be of the format 's3://bucket/path/to/file'")
        }</span>

        // Normalize case and validate SHA256
        <span class="cov9" title="33">sha256 = strings.ToLower(sha256)
        if len(sha256) != 64 </span><span class="cov5" title="6">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="27">if _, err := hex.DecodeString(sha256); err != nil </span><span class="cov2" title="2">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="25">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Creates directories from stdin lines, each with 16 `sub-directory-N` subfolders, each containing 1001000 files of 1 KiB whose contents are the relative file path. Save as `generate-fixtures.go`.

package main

import (
        "bufio"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

const (
        minSubDirs = 1
        maxSubDirs = 6

        minFilesPerSub = 100
        maxFilesPerSub = 1000

        fileSizeBytes = 1024
)

// main reads directory names from stdin (one per line) and creates a set of
// "fixture" directories and files for each input name. For each top-level
// directory it creates between minSubDirs and maxSubDirs subdirectories
// named "sub-directory-N". Each subdirectory receives between minFilesPerSub
// and maxFilesPerSub files. File contents are written as the relative path
// bytes. The program prints progress and errors to stderr and exits with a
// non-zero code on read errors or when no input is provided.
func main() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())

        // Flags: if &gt;0 they override randomness
        numSubdirsFlag := flag.Int("number-of-subdirectories", 0, "fixed number of subdirectories per top-level directory (overrides random)")
        numFilesFlag := flag.Int("number-of-files", 0, "fixed number of files per subdirectory (overrides random)")
        flag.Parse()

        scanner := bufio.NewScanner(os.Stdin)
        entries := []string{}
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">entries = append(entries, line)</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "reading stdin: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "no input lines; provide one directory name per line on stdin")
                os.Exit(1)
        }</span>

        // Determine digits for file name padding based on configured or default max
        <span class="cov0" title="0">maxFilesConsidered := maxFilesPerSub
        if *numFilesFlag &gt; 0 &amp;&amp; *numFilesFlag &gt; maxFilesConsidered </span><span class="cov0" title="0">{
                maxFilesConsidered = *numFilesFlag
        }</span>
        <span class="cov0" title="0">maxFilesDigits := len(strconv.Itoa(maxFilesConsidered))

        for _, name := range entries </span><span class="cov0" title="0">{
                // Clean the path and disallow absolute paths for safety
                clean := filepath.Clean(name)
                if filepath.IsAbs(clean) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping absolute path: %s\n", name)
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(clean, ".."+string(os.PathSeparator)) || clean == ".." </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping path outside current tree: %s\n", name)
                        continue</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(clean, 0o755); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", clean, err)
                        continue</span>
                }

                // Choose number of subdirectories
                <span class="cov0" title="0">var nSub int
                if *numSubdirsFlag &gt; 0 </span><span class="cov0" title="0">{
                        if *numSubdirsFlag &lt; 1 </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "invalid --number-of-subdirectories: %d (must be &gt;= 1)\n", *numSubdirsFlag)
                                continue</span>
                        }
                        <span class="cov0" title="0">nSub = *numSubdirsFlag</span>
                } else<span class="cov0" title="0"> {
                        nSub = rand.Intn(maxSubDirs-minSubDirs+1) + minSubDirs
                }</span>

                <span class="cov0" title="0">for si := 1; si &lt;= nSub; si++ </span><span class="cov0" title="0">{
                        subdir := filepath.Join(clean, fmt.Sprintf("sub-directory-%d", si))
                        if err := os.MkdirAll(subdir, 0o755); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", subdir, err)
                                continue</span>
                        }

                        // Choose number of files per subdirectory
                        <span class="cov0" title="0">var nFiles int
                        if *numFilesFlag &gt; 0 </span><span class="cov0" title="0">{
                                if *numFilesFlag &lt; 1 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "invalid --number-of-files: %d (must be &gt;= 1)\n", *numFilesFlag)
                                        continue</span>
                                }
                                <span class="cov0" title="0">nFiles = *numFilesFlag</span>
                        } else<span class="cov0" title="0"> {
                                nFiles = rand.Intn(maxFilesPerSub-minFilesPerSub+1) + minFilesPerSub
                        }</span>

                        <span class="cov0" title="0">for fi := 1; fi &lt;= nFiles; fi++ </span><span class="cov0" title="0">{
                                filename := fmt.Sprintf("file-%0*d.dat", maxFilesDigits, fi)
                                path := filepath.Join(subdir, filename)
                                pathBytes := []byte(path)
                                if err := os.WriteFile(path, pathBytes, 0o644); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "write %s: %v\n", path, err)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "created %d files in %s\n", nFiles, subdir)</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "done: %s (%d subdirs)\n", clean, nSub)</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package utils

import (
        "fmt"
        "strings"
)

const (
        DRS_DIR = ".git/drs"
)

func ProjectToResource(project string) (string, error) <span class="cov10" title="316">{
        if !strings.Contains(project, "-") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error: invalid project ID %s in config file, ID should look like &lt;program&gt;-&lt;project&gt;", project)
        }</span>
        <span class="cov9" title="315">projectIdArr := strings.SplitN(project, "-", 2)
        return "/programs/" + projectIdArr[0] + "/projects/" + projectIdArr[1], nil</span>
}

// AddUnique appends items from 'toAdd' to 'existing' only if they're not already present.
// Returns the updated slice with unique items.
func AddUnique[T comparable](existing []T, toAdd []T) []T <span class="cov2" title="3">{
        // seen map uses struct{} as the value for memory efficiency
        seen := make(map[T]struct{}, len(existing))

        // Populate the set with existing items
        for _, item := range existing </span><span class="cov3" title="4">{
                seen[item] = struct{}{}
        }</span>

        <span class="cov2" title="3">for _, item := range toAdd </span><span class="cov3" title="4">{
                // check if item not yet in the set
                if _, found := seen[item]; !found </span><span class="cov2" title="2">{
                        existing = append(existing, item)
                        // Add the new unique item to the set
                        seen[item] = struct{}{}
                }</span>
        }
        <span class="cov2" title="3">return existing</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
)

const (
        // ConfirmationYes is the string users must type to confirm destructive operations
        ConfirmationYes = "yes"
)

// PromptForConfirmation displays a prompt and reads user input to confirm an operation.
// Returns nil if the response matches expectedResponse, error otherwise.
// If caseSensitive is false, comparison is case-insensitive.
func PromptForConfirmation(w io.Writer, prompt string, expectedResponse string, caseSensitive bool) error <span class="cov10" title="2">{
        fmt.Fprintf(w, "%s: ", prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading confirmation: %v", err)
        }</span>

        <span class="cov10" title="2">response = strings.TrimSpace(response)
        if !caseSensitive </span><span class="cov1" title="1">{
                response = strings.ToLower(response)
                expectedResponse = strings.ToLower(expectedResponse)
        }</span>

        <span class="cov10" title="2">if response != expectedResponse </span><span class="cov1" title="1">{
                return fmt.Errorf("operation cancelled: confirmation did not match")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DisplayWarningHeader writes a formatted warning header to the writer
func DisplayWarningHeader(w io.Writer, operation string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\n  WARNING: You are about to %s\n\n", operation)
}</span>

// DisplayField writes a formatted key-value field to the writer
func DisplayField(w io.Writer, key, value string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "%-11s %s\n", key+":", value)
}</span>

// DisplayFooter writes the standard "cannot be undone" footer to the writer
func DisplayFooter(w io.Writer) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\nThis action CANNOT be undone.\n\n")
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// GitAttribute represents a single line in .gitattributes file
type GitAttribute struct {
        Pattern    string
        Attributes map[string]string
}

// ParseGitAttributes parses the content of a .gitattributes file
func ParseGitAttributes(content string) ([]GitAttribute, error) <span class="cov5" title="26">{
        var attributes []GitAttribute
        scanner := bufio.NewScanner(strings.NewReader(content))

        for scanner.Scan() </span><span class="cov9" title="263">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov7" title="108">{
                        continue</span>
                }

                <span class="cov8" title="155">attr, err := parseLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed lines
                }

                <span class="cov8" title="155">attributes = append(attributes, attr)</span>
        }

        <span class="cov5" title="26">return attributes, scanner.Err()</span>
}

// parseLine parses a single line from .gitattributes
func parseLine(line string) (GitAttribute, error) <span class="cov8" title="155">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return GitAttribute{}, nil
        }</span>

        <span class="cov8" title="155">pattern := parts[0]
        attributes := make(map[string]string)

        for _, attr := range parts[1:] </span><span class="cov10" title="416">{
                if strings.Contains(attr, "=") </span><span class="cov9" title="284">{
                        // Handle key=value attributes
                        kv := strings.SplitN(attr, "=", 2)
                        attributes[kv[0]] = kv[1]
                }</span> else<span class="cov8" title="132"> if strings.HasPrefix(attr, "-") </span><span class="cov7" title="87">{
                        // Handle negated attributes (-attr)
                        attributes[attr[1:]] = "false"
                }</span> else<span class="cov6" title="45"> {
                        // Handle simple attributes (attr)
                        attributes[attr] = "true"
                }</span>
        }

        <span class="cov8" title="155">return GitAttribute{
                Pattern:    pattern,
                Attributes: attributes,
        }, nil</span>
}

func IsLFSTracked(gitattributesFilePath, filePath string) (bool, error) <span class="cov0" title="0">{
        gitattributesContent, err := os.ReadFile(gitattributesFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read .gitattributes file: %w", err)
        }</span>

        <span class="cov0" title="0">return isLFSTracked(string(gitattributesContent), filePath)</span>
}

// isLFSTracked determines if a given file path is tracked by Git LFS
func isLFSTracked(gitattributesContent string, filePath string) (bool, error) <span class="cov5" title="25">{
        attributes, err := ParseGitAttributes(gitattributesContent)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Process attributes in order, later rules override earlier ones
        <span class="cov5" title="25">isLFS := false

        for _, attr := range attributes </span><span class="cov7" title="107">{
                if matchesPattern(attr.Pattern, filePath) </span><span class="cov5" title="15">{
                        // Check for LFS attributes
                        if filter, exists := attr.Attributes["filter"]; exists </span><span class="cov4" title="13">{
                                return filter == "lfs", nil // Return immediately on filter match
                        }</span>
                }
        }

        <span class="cov4" title="12">return isLFS, nil</span>
}

// matchesPattern checks if a file path matches a gitattributes pattern
func matchesPattern(pattern, filePath string) bool <span class="cov8" title="125">{
        // Handle exact matches first
        if pattern == filePath </span><span class="cov2" title="3">{
                return true
        }</span>

        // Handle directory patterns ending with /
        <span class="cov8" title="122">if strings.HasSuffix(pattern, "/") </span><span class="cov2" title="2">{
                return strings.HasPrefix(filePath+"/", pattern)
        }</span>

        // Handle ** patterns (match any number of directories)
        <span class="cov8" title="120">if strings.Contains(pattern, "**") </span><span class="cov5" title="20">{
                return matchesDoubleStarPattern(pattern, filePath)
        }</span>

        // Handle patterns with explicit path separators
        <span class="cov7" title="100">if strings.Contains(pattern, "/") </span><span class="cov5" title="18">{
                // Pattern contains path separator, do full path matching
                matched, err := filepath.Match(pattern, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov5" title="18">return matched</span>
        }

        // For simple glob patterns without path separators (like *.bin),
        // only match against the filename, not the full path
        // filename := filepath.Base(filePath)
        <span class="cov7" title="82">matched, err := filepath.Match(pattern, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="82">return matched</span>
}

// matchesDoubleStarPattern handles ** patterns in gitattributes
func matchesDoubleStarPattern(pattern, filePath string) bool <span class="cov5" title="20">{
        // Handle ** patterns by splitting on ** and matching each part
        parts := strings.Split(pattern, "**")

        // If no ** found, fall back to regular matching
        if len(parts) == 1 </span><span class="cov0" title="0">{
                matched, err := filepath.Match(pattern, filePath)
                return err == nil &amp;&amp; matched
        }</span>

        // For patterns with **, we need to match each part
        // Example: "docs/**/*.pdf" becomes ["docs/", "/*.pdf"]
        // Example: "**/*.bin" becomes ["", "/*.bin"]

        <span class="cov5" title="20">currentPath := filePath

        for i, part := range parts </span><span class="cov5" title="27">{
                if part == "" </span><span class="cov2" title="2">{
                        continue</span> // Skip empty parts
                }

                <span class="cov5" title="25">if i == 0 </span><span class="cov5" title="18">{
                        // First part - must match the beginning
                        if strings.HasSuffix(part, "/") </span><span class="cov5" title="18">{
                                // Directory prefix
                                if !strings.HasPrefix(currentPath, part) </span><span class="cov4" title="13">{
                                        return false
                                }</span>
                                <span class="cov3" title="5">currentPath = currentPath[len(part):]</span>
                        } else<span class="cov0" title="0"> {
                                // File pattern at the beginning
                                matched, err := filepath.Match(part, currentPath)
                                return err == nil &amp;&amp; matched
                        }</span>
                } else<span class="cov3" title="7"> if i == len(parts)-1 </span><span class="cov3" title="7">{
                        // Last part - must match the end or remaining path
                        part = strings.TrimPrefix(part, "/")

                        // For the last part, try to match against the filename or remaining path
                        if strings.Contains(part, "/") </span><span class="cov0" title="0">{
                                // Pattern has path components, match against remaining path
                                matched, err := filepath.Match(part, currentPath)
                                return err == nil &amp;&amp; matched
                        }</span> else<span class="cov3" title="7"> {
                                // Simple filename pattern, match against just the filename
                                filename := filepath.Base(currentPath)
                                matched, err := filepath.Match(part, filename)
                                return err == nil &amp;&amp; matched
                        }</span>
                }
                // Middle parts would be handled here if we had more complex patterns
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package utils

import (
        "fmt"
        "net/http"
        "net/url"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

func GitTopLevel() (string, error) <span class="cov9" title="1355">{
        path, err := SimpleRun([]string{"git", "rev-parse", "--show-toplevel"})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="1355">return strings.TrimSuffix(path, "\n"), nil</span>
}

func SimpleRun(cmds []string) (string, error) <span class="cov10" title="1356">{
        exePath, err := exec.LookPath(cmds[0])
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("command not found: %s: %w", cmds[0], err)
        }</span>
        <span class="cov9" title="1355">cmd := exec.Command(exePath, cmds[1:]...)
        cmdOut, err := cmd.Output()
        return string(cmdOut), err</span>
}

func DrsTopLevel() (string, error) <span class="cov0" title="0">{
        base, err := GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(base, DRS_DIR), nil</span>
}

// CanDownloadFile checks if a file can be downloaded from the given signed URL
// by issuing a ranged GET for a single byte to mimic HEAD behavior.
func CanDownloadFile(signedURL string) error <span class="cov6" title="104">{
        req, err := http.NewRequest("GET", signedURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov6" title="104">req.Header.Set("Range", "bytes=0-0")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while sending the request: %v", err)
        }</span>
        <span class="cov6" title="104">defer resp.Body.Close()

        if resp.StatusCode == http.StatusPartialContent || resp.StatusCode == http.StatusOK </span><span class="cov5" title="50">{
                return nil
        }</span>

        <span class="cov5" title="54">return fmt.Errorf("failed to access file, HTTP status: %d", resp.StatusCode)</span>
}

func ParseEmailFromToken(tokenString string) (string, error) <span class="cov3" title="5">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode token in ParseEmailFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov2" title="4">context, ok := claims["context"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context' claim structure")
        }</span>
        <span class="cov2" title="3">user, ok := context["user"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user' claim structure")
        }</span>
        <span class="cov1" title="2">name, ok := user["name"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user.name' claim")
        }</span>
        <span class="cov1" title="1">return name, nil</span>
}

func ParseAPIEndpointFromToken(tokenString string) (string, error) <span class="cov6" title="90">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token in ParseAPIEndpointFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov6" title="90">issUrl, ok := claims["iss"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'iss' claim")
        }</span>
        <span class="cov6" title="89">parsedURL, err := url.Parse(issUrl)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov6" title="88">return fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host), nil</span>
}

func ParseS3URL(s3url string) (string, string, error) <span class="cov4" title="22">{
        s3Prefix := "s3://"
        if !strings.HasPrefix(s3url, s3Prefix) </span><span class="cov3" title="5">{
                return "", "", fmt.Errorf("S3 URL requires prefix 's3://': %s", s3url)
        }</span>
        <span class="cov4" title="17">trimmed := strings.TrimPrefix(s3url, s3Prefix)
        slashIndex := strings.Index(trimmed, "/")
        if slashIndex == -1 || slashIndex == len(trimmed)-1 </span><span class="cov2" title="4">{
                return "", "", fmt.Errorf("invalid S3 file URL: %s", s3url)
        }</span>
        <span class="cov4" title="13">return trimmed[:slashIndex], trimmed[slashIndex+1:], nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Package version reports the Git-DRS version.
package version

import "fmt"

// Build and version details
var (
        GitCommit   = ""
        GitBranch   = ""
        GitUpstream = ""
        BuildDate   = ""
        Version     = ""
)

var tpl = `git commit: %s
git branch: %s
git upstream: %s
build date: %s
version: %s`

// String formats a string with version details.
func String() string <span class="cov0" title="0">{
        return fmt.Sprintf(tpl, GitCommit, GitBranch, GitUpstream, BuildDate, Version)
}</span>

// LogFields logs build and version information to the given logger.
func LogFields() []any <span class="cov0" title="0">{
        return []any{
                "GitCommit", GitCommit,
                "GitBranch", GitBranch,
                "GitUpstream", GitUpstream,
                "BuildDate", BuildDate,
                "Version", Version,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
