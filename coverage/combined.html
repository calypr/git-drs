
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anvil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/calypr/git-drs/client/anvil/anvil_client.go (0.0%)</option>
				
				<option value="file1">github.com/calypr/git-drs/client/anvil/remote.go (100.0%)</option>
				
				<option value="file2">github.com/calypr/git-drs/client/indexd/add_url.go (47.4%)</option>
				
				<option value="file3">github.com/calypr/git-drs/client/indexd/auth_handler.go (52.4%)</option>
				
				<option value="file4">github.com/calypr/git-drs/client/indexd/convert.go (86.5%)</option>
				
				<option value="file5">github.com/calypr/git-drs/client/indexd/gen3_remote.go (71.4%)</option>
				
				<option value="file6">github.com/calypr/git-drs/client/indexd/indexd_client.go (66.9%)</option>
				
				<option value="file7">github.com/calypr/git-drs/client/indexd/records.go (100.0%)</option>
				
				<option value="file8">github.com/calypr/git-drs/client/indexd/utils.go (81.8%)</option>
				
				<option value="file9">github.com/calypr/git-drs/cloud/agent_fetch_reader.go (42.4%)</option>
				
				<option value="file10">github.com/calypr/git-drs/cloud/download.go (75.0%)</option>
				
				<option value="file11">github.com/calypr/git-drs/cloud/downloader.go (71.4%)</option>
				
				<option value="file12">github.com/calypr/git-drs/cloud/inspect.go (81.3%)</option>
				
				<option value="file13">github.com/calypr/git-drs/cloud/s3.go (100.0%)</option>
				
				<option value="file14">github.com/calypr/git-drs/cloud/validate.go (100.0%)</option>
				
				<option value="file15">github.com/calypr/git-drs/cmd/addref/add-ref.go (3.3%)</option>
				
				<option value="file16">github.com/calypr/git-drs/cmd/addurl/main.go (72.4%)</option>
				
				<option value="file17">github.com/calypr/git-drs/cmd/cache/create-cache.go (0.0%)</option>
				
				<option value="file18">github.com/calypr/git-drs/cmd/delete/main.go (4.4%)</option>
				
				<option value="file19">github.com/calypr/git-drs/cmd/deleteproject/main.go (4.3%)</option>
				
				<option value="file20">github.com/calypr/git-drs/cmd/download/main.go (5.9%)</option>
				
				<option value="file21">github.com/calypr/git-drs/cmd/fetch/main.go (0.0%)</option>
				
				<option value="file22">github.com/calypr/git-drs/cmd/initialize/main.go (74.1%)</option>
				
				<option value="file23">github.com/calypr/git-drs/cmd/list/main.go (17.7%)</option>
				
				<option value="file24">github.com/calypr/git-drs/cmd/listconfig/main.go (6.2%)</option>
				
				<option value="file25">github.com/calypr/git-drs/cmd/precommit/main.go (0.0%)</option>
				
				<option value="file26">github.com/calypr/git-drs/cmd/prepush/main.go (72.8%)</option>
				
				<option value="file27">github.com/calypr/git-drs/cmd/push/main.go (0.0%)</option>
				
				<option value="file28">github.com/calypr/git-drs/cmd/query/main.go (12.5%)</option>
				
				<option value="file29">github.com/calypr/git-drs/cmd/register/main.go (1.6%)</option>
				
				<option value="file30">github.com/calypr/git-drs/cmd/remote/add/anvil.go (0.0%)</option>
				
				<option value="file31">github.com/calypr/git-drs/cmd/remote/add/gen3.go (57.1%)</option>
				
				<option value="file32">github.com/calypr/git-drs/cmd/remote/add/init.go (100.0%)</option>
				
				<option value="file33">github.com/calypr/git-drs/cmd/remote/list.go (0.0%)</option>
				
				<option value="file34">github.com/calypr/git-drs/cmd/remote/root.go (100.0%)</option>
				
				<option value="file35">github.com/calypr/git-drs/cmd/remote/set.go (0.0%)</option>
				
				<option value="file36">github.com/calypr/git-drs/cmd/root.go (100.0%)</option>
				
				<option value="file37">github.com/calypr/git-drs/cmd/transfer/main.go (48.8%)</option>
				
				<option value="file38">github.com/calypr/git-drs/cmd/transferref/main.go (0.0%)</option>
				
				<option value="file39">github.com/calypr/git-drs/cmd/version/main.go (57.9%)</option>
				
				<option value="file40">github.com/calypr/git-drs/config/config.go (60.8%)</option>
				
				<option value="file41">github.com/calypr/git-drs/drs/hash/hash.go (93.8%)</option>
				
				<option value="file42">github.com/calypr/git-drs/drs/object.go (100.0%)</option>
				
				<option value="file43">github.com/calypr/git-drs/drs/object_builder.go (92.3%)</option>
				
				<option value="file44">github.com/calypr/git-drs/drs/store.go (76.8%)</option>
				
				<option value="file45">github.com/calypr/git-drs/drs/util.go (80.0%)</option>
				
				<option value="file46">github.com/calypr/git-drs/drslog/compat.go (100.0%)</option>
				
				<option value="file47">github.com/calypr/git-drs/drslog/logger.go (55.2%)</option>
				
				<option value="file48">github.com/calypr/git-drs/drsmap/drs_map.go (27.6%)</option>
				
				<option value="file49">github.com/calypr/git-drs/drsmap/lfs/lfs.go (60.1%)</option>
				
				<option value="file50">github.com/calypr/git-drs/drsmap/store/store.go (100.0%)</option>
				
				<option value="file51">github.com/calypr/git-drs/git-drs.go (42.9%)</option>
				
				<option value="file52">github.com/calypr/git-drs/internal/testutils/config.go (56.8%)</option>
				
				<option value="file53">github.com/calypr/git-drs/internal/testutils/output.go (100.0%)</option>
				
				<option value="file54">github.com/calypr/git-drs/lfs/gitattributes.go (85.5%)</option>
				
				<option value="file55">github.com/calypr/git-drs/lfs/helpers.go (71.2%)</option>
				
				<option value="file56">github.com/calypr/git-drs/lfs/lfs_tracked.go (78.6%)</option>
				
				<option value="file57">github.com/calypr/git-drs/lfs/messages.go (100.0%)</option>
				
				<option value="file58">github.com/calypr/git-drs/precommit_cache/helpers.go (0.0%)</option>
				
				<option value="file59">github.com/calypr/git-drs/tests/monorepos/generate-fixtures.go (0.0%)</option>
				
				<option value="file60">github.com/calypr/git-drs/utils/common.go (100.0%)</option>
				
				<option value="file61">github.com/calypr/git-drs/utils/confirmation.go (93.3%)</option>
				
				<option value="file62">github.com/calypr/git-drs/utils/lfs-track.go (78.9%)</option>
				
				<option value="file63">github.com/calypr/git-drs/utils/util.go (86.2%)</option>
				
				<option value="file64">github.com/calypr/git-drs/version/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anvil_client

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "golang.org/x/oauth2/google"
)

type AnvilClient struct {
        Endpoint string
        SConfig  sonic.API
}

func (an *AnvilClient) GetObject(objectID string) (*drs.DRSObject, error) <span class="cov0" title="0">{
        // get auth token
        token, err := GetAuthToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auth token: %w", err)
        }</span>

        <span class="cov0" title="0">reqBody := map[string]any{
                "url":    objectID,
                "fields": []string{"hashes", "size", "fileName"},
        }
        bodyBytes, err := an.SConfig.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", an.Endpoint, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, _ := io.ReadAll(resp.Body)
        if resp.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                // Try to extract error message
                var errResp map[string]any
                an.SConfig.Unmarshal(respBody, &amp;errResp)
                msg := fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(respBody))
                if m, ok := errResp["message"].(string); ok </span><span class="cov0" title="0">{
                        msg = m
                }</span>
                <span class="cov0" title="0">return &amp;drs.DRSObject{}, errors.New(msg)</span>
        }

        // Parse expected response
        // subset of ResourceMetadata
        // https://github.com/DataBiosphere/terra-drs-hub/blob/dev/common/openapi.yml#L123
        <span class="cov0" title="0">var parsed struct {
                Hashes   map[string]string `json:"hashes"`
                Size     int64             `json:"size"`
                FileName string            `json:"fileName"`
        }
        if err := an.SConfig.Unmarshal(respBody, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.DRSObject{
                SelfURI:   objectID,
                Id:        objectID,
                Checksums: hash.ConvertStringMapToHashInfo(parsed.Hashes),
                Size:      parsed.Size,
                Name:      parsed.FileName,
        }, nil</span>
}

// GetAuthToken fetches a Google Cloud authentication token using Application Default Credentials.
// The user must run `gcloud auth application-default login` before using this.
func GetAuthToken() (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        creds, err := google.FindDefaultCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">ts := creds.TokenSource
        token, err := ts.Token()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid() || token.AccessToken == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no token retrieved")
        }</span>

        <span class="cov0" title="0">return token.AccessToken, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package anvil_client

import (
        "fmt"
        "log/slog"

        "github.com/calypr/git-drs/client"
)

// AnvilAuth holds authentication info for Anvil
type AnvilAuth struct {
        TerraProject string `yaml:"terra_project"`
}

// AnvilRemote holds Anvil remote config
type AnvilRemote struct {
        Endpoint string    `yaml:"endpoint"`
        Auth     AnvilAuth `yaml:",inline"`
}

func (s AnvilRemote) GetProjectId() string <span class="cov8" title="1">{
        return s.Auth.TerraProject
}</span>

func (s AnvilRemote) GetEndpoint() string <span class="cov8" title="1">{
        return s.Endpoint
}</span>

func (s AnvilRemote) GetBucketName() string <span class="cov8" title="1">{
        return ""
}</span>

func (s AnvilRemote) GetClient(params map[string]string, logger *slog.Logger) (client.DRSClient, error) <span class="cov8" title="1">{
        return nil, fmt.Errorf(("AnVIL Client needs to be implemented"))
        // return NewAnvilClient(s, logger)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package indexd_client

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "path/filepath"
        "slices"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/messages"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
)

// getBucketDetails fetches bucket details from Gen3, loading config and auth.
// This is the production version that includes all config/auth dependencies.
func (inc *IndexDClient) getBucketDetails(ctx context.Context, bucket string, httpClient *http.Client) (*cloud.S3Bucket, error) <span class="cov0" title="0">{
        // get all buckets
        baseURL := *inc.Base // Create a copy to avoid mutating inc.Base
        baseURL.Path = filepath.Join(baseURL.Path, "user/data/buckets")
        // Use the AuthHandler pattern for cleaner auth handling
        return GetBucketDetailsWithAuth(ctx, bucket, baseURL.String(), inc.AuthHandler, httpClient)
}</span>

// FetchS3MetadataWithBucketDetails fetches S3 metadata given bucket details.
// This is the core testable logic, separated for easier unit testing.
func FetchS3MetadataWithBucketDetails(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, bucketDetails *cloud.S3Bucket, s3Client *s3.Client, logger *slog.Logger) (int64, string, error) <span class="cov10" title="9">{

        // Parse S3 URL
        bucket, key, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov1" title="1">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        // Create s3 client if not passed as param
        <span class="cov9" title="8">var finalRegion, finalEndpoint string
        var finalCfg aws.Config
        var clientWasProvided bool = (s3Client != nil)

        if s3Client == nil </span><span class="cov7" title="5">{
                // Always load base AWS configuration first
                cfg, err := awsConfig.LoadDefaultConfig(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", fmt.Errorf("unable to load base AWS SDK config: %v. %s", err, messages.ADDURL_HELP_MSG)
                }</span>

                // Build config options to override defaults
                <span class="cov7" title="5">var configOptions []func(*awsConfig.LoadOptions) error

                // Override credentials if provided
                if awsAccessKey != "" &amp;&amp; awsSecretKey != "" </span><span class="cov6" title="4">{
                        configOptions = append(configOptions,
                                awsConfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                                        awsAccessKey,
                                        awsSecretKey,
                                        "", // session token (empty for basic credentials)
                                )),
                        )
                }</span>

                // Override region with priority: parameter &gt; bucketDetails &gt; default
                <span class="cov7" title="5">regionToUse := ""
                if region != "" </span><span class="cov3" title="2">{
                        regionToUse = region
                }</span> else<span class="cov5" title="3"> if bucketDetails.Region != "" </span><span class="cov1" title="1">{
                        regionToUse = bucketDetails.Region
                }</span>
                <span class="cov7" title="5">if regionToUse != "" </span><span class="cov5" title="3">{
                        configOptions = append(configOptions, awsConfig.WithRegion(regionToUse))
                }</span>

                // Reload config with overrides if any options were set
                <span class="cov7" title="5">if len(configOptions) &gt; 0 </span><span class="cov6" title="4">{
                        cfg, err = awsConfig.LoadDefaultConfig(ctx, configOptions...)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, "", fmt.Errorf("unable to load AWS SDK config with overrides: %v. %s", err, messages.ADDURL_HELP_MSG)
                        }</span>
                }

                // Determine endpoint with priority: parameter &gt; bucketDetails &gt; default config
                <span class="cov7" title="5">endpointToUse := ""
                if endpoint != "" </span><span class="cov3" title="2">{
                        endpointToUse = endpoint
                        finalEndpoint = endpoint
                }</span> else<span class="cov5" title="3"> if bucketDetails.EndpointURL != "" </span><span class="cov5" title="3">{
                        endpointToUse = bucketDetails.EndpointURL
                }</span>
                // Note: endpoint may also come from AWS config file, which will be loaded automatically

                // Store final values for validation
                <span class="cov7" title="5">finalRegion = cfg.Region
                finalCfg = cfg

                // Create S3 client with optional endpoint override and path-style addressing
                s3Client = s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov7" title="5">{
                        if endpointToUse != "" </span><span class="cov7" title="5">{
                                o.BaseEndpoint = aws.String(endpointToUse)
                        }</span>
                        <span class="cov7" title="5">o.UsePathStyle = true</span> // This forces path-style URLs
                })
        }

        // Validate that all required configuration is present before making the HeadObject call
        // Only validate if we created the client ourselves (not provided as parameter)
        <span class="cov9" title="8">if !clientWasProvided </span><span class="cov7" title="5">{
                var missingFields []string

                // Check credentials
                if finalCfg.Credentials != nil </span><span class="cov7" title="5">{
                        creds, err := finalCfg.Credentials.Retrieve(ctx)
                        if err != nil || creds.AccessKeyID == "" </span><span class="cov1" title="1">{
                                missingFields = append(missingFields, "AWS credentials (access key and secret key)")
                        }</span>
                }

                // Check region
                <span class="cov7" title="5">if finalRegion == "" </span><span class="cov3" title="2">{
                        missingFields = append(missingFields, "AWS region")
                }</span>

                // Check endpoint, ok if missing
                <span class="cov7" title="5">if finalEndpoint == "" </span><span class="cov5" title="3">{
                        logger.Debug("Warning: S3 endpoint URL is not provided. If supplied, using default AWS endpoint in configuration.")
                }</span>

                // Note: We don't validate endpoint here because:
                // 1. It may be configured in AWS config file (which we can't easily inspect)
                // 2. For standard AWS S3, the endpoint is optional and determined by region

                // If any required fields are missing, return a clear error
                <span class="cov7" title="5">if len(missingFields) &gt; 0 </span><span class="cov3" title="2">{
                        var errorMsg strings.Builder
                        errorMsg.WriteString("Missing required AWS configuration:\n")
                        for i, field := range missingFields </span><span class="cov5" title="3">{
                                errorMsg.WriteString(fmt.Sprintf("  %d. %s\n", i+1, field))
                        }</span>
                        <span class="cov3" title="2">errorMsg.WriteString("\nPlease provide these values via:\n")
                        errorMsg.WriteString("  - Command-line flags (--" + cloud.AWS_KEY_FLAG_NAME + ", --" + cloud.AWS_SECRET_FLAG_NAME + ", --" + cloud.AWS_REGION_FLAG_NAME + ", --" + cloud.AWS_ENDPOINT_URL_FLAG_NAME + ")\n")
                        errorMsg.WriteString("  - Environment variables (" + cloud.AWS_KEY_ENV_VAR + ", " + cloud.AWS_SECRET_ENV_VAR + ", " + cloud.AWS_REGION_ENV_VAR + ", " + cloud.AWS_ENDPOINT_URL_ENV_VAR + ")\n")
                        errorMsg.WriteString("  - AWS credentials file (~/.aws/credentials)\n")
                        errorMsg.WriteString("  - Gen3 bucket registration (if bucket can be registered in Gen3)\n")
                        errorMsg.WriteString("\n")
                        errorMsg.WriteString(messages.ADDURL_HELP_MSG)
                        return 0, "", errors.New(errorMsg.String())</span>
                }
        }

        // Ensure client was initialized (safety check)
        <span class="cov8" title="6">if s3Client == nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("S3 client was not initialized. %s", messages.ADDURL_HELP_MSG)
        }</span>

        <span class="cov8" title="6">input := &amp;s3.HeadObjectInput{
                Bucket: &amp;bucket,
                Key:    aws.String(key),
        }

        resp, err := s3Client.HeadObject(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                return 0, "", fmt.Errorf("failed to head object, %v", err)
        }</span>

        <span class="cov7" title="5">var contentLength int64
        if resp.ContentLength != nil </span><span class="cov7" title="5">{
                contentLength = *resp.ContentLength
        }</span> else<span class="cov0" title="0"> {
                contentLength = 0
        }</span>

        <span class="cov7" title="5">return contentLength, resp.LastModified.Format(time.RFC3339), nil</span>
}

// fetchS3Metadata fetches S3 metadata (size, modified date) for a given S3 URL.
// This is the production version that fetches bucket details from Gen3.
func (inc *IndexDClient) fetchS3Metadata(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, s3Client *s3.Client, httpClient *http.Client, logger *slog.Logger) (int64, string, error) <span class="cov0" title="0">{

        // Fetch AWS bucket region and endpoint from /data/buckets (fence in gen3)
        bucket, _, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">bucketDetails, err := inc.getBucketDetails(ctx, bucket, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("unable to get bucket details: %w. Please ensure you've specified the correct AWS region and AWS bucket endpoint URL via flags or environment variables. %s", err, messages.ADDURL_HELP_MSG)
        }</span>
        <span class="cov0" title="0">if bucketDetails == nil </span><span class="cov0" title="0">{
                logger.Debug("WARNING: no matching bucket found in CALYPR")
                bucketDetails = &amp;cloud.S3Bucket{}
        }</span>

        <span class="cov0" title="0">return FetchS3MetadataWithBucketDetails(ctx, s3URL, awsAccessKey, awsSecretKey, region, endpoint, bucketDetails, s3Client, logger)</span>
}

// // upserts index record, so that if...
// // 1. the record exists for the project, it updates the URL
// // 2. the record for the project does not exist, it creates a new one
func (inc *IndexDClient) upsertIndexdRecord(url string, sha256 string, fileSize int64, logger *slog.Logger) (*drs.DRSObject, error) <span class="cov0" title="0">{
        projectId := inc.GetProjectId()
        uuid := drsmap.DrsUUID(projectId, sha256)

        // handle if record already exists
        records, err := inc.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: sha256})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying indexd server for matches to hash %s: %v", sha256, err)
        }</span>

        <span class="cov0" title="0">matchingRecord, err := drsmap.FindMatchingRecord(records, projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
        }</span>

        <span class="cov0" title="0">if matchingRecord != nil &amp;&amp; matchingRecord.Id == uuid </span><span class="cov0" title="0">{
                // if record exists and contains requested url, nothing to do
                if slices.Contains(indexdURLFromDrsAccessURLs(matchingRecord.AccessMethods), url) </span><span class="cov0" title="0">{
                        logger.Debug("Nothing to do: file already registered")
                        return matchingRecord, nil
                }</span>

                // if record exists with different url, update via index/{guid}
                <span class="cov0" title="0">if matchingRecord.Id == uuid &amp;&amp; !slices.Contains(indexdURLFromDrsAccessURLs(matchingRecord.AccessMethods), url) </span><span class="cov0" title="0">{
                        logger.Debug("updating existing record with new url")

                        updatedRecord := drs.DRSObject{AccessMethods: []drs.AccessMethod{{AccessURL: drs.AccessURL{URL: url}}}}
                        drsObj, err := inc.UpdateRecord(&amp;updatedRecord, matchingRecord.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update indexd record: %w", err)
                        }</span>
                        <span class="cov0" title="0">return drsObj, nil</span>
                }
        }

        // If no record exists, create indexd record
        <span class="cov0" title="0">logger.Debug("creating new record")
        authzStr, err := utils.ProjectToResource(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, relPath, err := utils.ParseS3URL(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get relative S3 path from URL: %s", url)
        }</span>

        <span class="cov0" title="0">indexdObject := &amp;IndexdRecord{
                Did:      uuid,
                FileName: relPath,
                Hashes:   hash.HashInfo{SHA256: sha256},
                Size:     fileSize,
                URLs:     []string{url},
                Authz:    []string{authzStr},
                // NOTE: that this isn't being carried over atm cause we're registering via DRS Object
                Metadata: map[string]string{"remote": "true"},
        }

        inputDrsObj, err := indexdObject.ToDrsObject()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert indexd record to DRS object: %w", err)
        }</span>

        <span class="cov0" title="0">drsObj, err := inc.RegisterRecord(inputDrsObj)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register indexd record: %w", err)
        }</span>
        <span class="cov0" title="0">return drsObj, nil</span>
}

// AddURL adds a file to the Git DRS repo using an S3 URL
func (inc *IndexDClient) AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, regionFlag, endpointFlag string, opts ...cloud.AddURLOption) (cloud.S3Meta, error) <span class="cov3" title="2">{
        // Create context with 10-second timeout
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // Apply options
        cfg := &amp;cloud.AddURLConfig{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        // Use NoOpLogger if no logger provided
        <span class="cov3" title="2">if inc.Logger == nil </span><span class="cov0" title="0">{
                inc.Logger = drslog.NewNoOpLogger()
        }</span>

        // Validate inputs
        <span class="cov3" title="2">if err := cloud.ValidateInputs(s3URL, sha256); err != nil </span><span class="cov3" title="2">{
                return cloud.S3Meta{}, err
        }</span>

        // check that lfs is tracking the file
        <span class="cov0" title="0">_, relPath, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return cloud.S3Meta{}, fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        // confirm file is tracked
        <span class="cov0" title="0">isLFS, err := utils.IsLFSTracked(".gitattributes", relPath)
        if err != nil </span><span class="cov0" title="0">{
                return cloud.S3Meta{}, fmt.Errorf("unable to determine if file is tracked by LFS: %w", err)
        }</span>
        <span class="cov0" title="0">if !isLFS </span><span class="cov0" title="0">{
                return cloud.S3Meta{}, fmt.Errorf("file is not tracked by LFS. Please run `git lfs track %s &amp;&amp; git add .gitattributes` before proceeding", relPath)
        }</span>

        // Fetch S3 metadata (size, modified date)
        <span class="cov0" title="0">inc.Logger.Debug("Fetching S3 metadata...")
        fileSize, modifiedDate, err := inc.fetchS3Metadata(ctx, s3URL, awsAccessKey, awsSecretKey, regionFlag, endpointFlag, cfg.S3Client, cfg.HttpClient, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                // if err contains 403, probably misconfigured credentials
                if strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        return cloud.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w. Double check your configured AWS credentials and endpoint url", err)
                }</span>
                <span class="cov0" title="0">return cloud.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w", err)</span>
        }

        // logging
        <span class="cov0" title="0">inc.Logger.Debug("Fetched S3 metadata successfully:")
        inc.Logger.Debug(fmt.Sprintf(" - File Size: %d bytes", fileSize))
        inc.Logger.Debug(fmt.Sprintf(" - Last Modified: %s", modifiedDate))

        // Create indexd record
        inc.Logger.Debug("Processing indexd record...")
        drsObj, err := inc.upsertIndexdRecord(s3URL, sha256, fileSize, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return cloud.S3Meta{}, fmt.Errorf("failed to create indexd record: %w", err)
        }</span>

        // write to file so push has that file available
        <span class="cov0" title="0">drsObjPath, err := drsmap.GetObjectPath(projectdir.DRS_OBJS_PATH, drsObj.Checksums.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return cloud.S3Meta{}, fmt.Errorf("failed to get object path: %w", err)
        }</span>
        <span class="cov0" title="0">if err := drsmap.WriteDrsObj(drsObj, sha256, drsObjPath); err != nil </span><span class="cov0" title="0">{
                return cloud.S3Meta{}, fmt.Errorf("failed to write DRS object: %w", err)
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug("Indexd updated")

        return cloud.S3Meta{
                Size:         fileSize,
                LastModified: modifiedDate,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package indexd_client

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/calypr/data-client/client/api"
        "github.com/calypr/data-client/client/conf"
        "github.com/calypr/data-client/client/logs"
        "github.com/calypr/data-client/client/request"
        GoJwt "github.com/golang-jwt/jwt/v5"
)

// RealAuthHandler uses actual Gen3 authentication
type RealAuthHandler struct {
        Cred conf.Credential
}

func (rh *RealAuthHandler) AddAuthHeader(req *http.Request) error <span class="cov9" title="23">{
        return rh.addGen3AuthHeader(req.Context(), req)
}</span>

// Moved this function out of bmeg/grip-graphql/middleware into this repo to simplify deps.
func GetExpiration(tokenString string) (time.Time, error) <span class="cov10" title="25">{
        // Also consider trimming the 'Bearer ' prefix too
        tokenString = strings.TrimPrefix(tokenString, "bearer ")
        token, _, err := new(GoJwt.Parser).ParseUnverified(tokenString, GoJwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        // Parse and convert from float64 epoch time to time.Time
        <span class="cov10" title="25">if claims, ok := token.Claims.(GoJwt.MapClaims); ok </span><span class="cov10" title="25">{
                if exp, ok := claims["exp"].(float64); ok </span><span class="cov9" title="24">{
                        temp := int64(exp)
                        exp := time.Unix(temp, 0)
                        return exp, nil
                }</span>
        }
        <span class="cov1" title="1">return time.Time{}, fmt.Errorf("expiration field 'exp' type float64 not found in token %v", token)</span>
}

// Kindof hackish. There exists logic to do this deeper in gen3-client but it is not exported
func RefreshToken(ctx context.Context, cred *conf.Credential) error <span class="cov9" title="23">{
        expiration, err := GetExpiration(cred.AccessToken)

        // Update AccessToken if token is old or there was an error getting the expiration
        needRefresh := false
        if err != nil </span><span class="cov0" title="0">{
                needRefresh = true
        }</span> else<span class="cov9" title="23"> if expiration.Before(time.Now()) </span><span class="cov0" title="0">{
                needRefresh = true
        }</span>

        <span class="cov9" title="23">if needRefresh </span><span class="cov0" title="0">{
                logger, closer := logs.New(cred.Profile)
                defer closer()

                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("failed to get access token expiration, attempting token refresh: %v", err)
                }</span>
                <span class="cov0" title="0">conf := conf.NewConfigure(logger)
                r := api.NewFunctions(conf, request.NewRequestInterface(logger, cred, conf), cred, logger)
                f, ok := r.(*api.Functions)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("Function interface is not of type api.Functions")
                }</span>
                <span class="cov0" title="0">err = f.NewAccessToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cred.AccessToken = f.Cred.AccessToken
                err = conf.Save(cred)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov9" title="23">return nil</span>
}

func (rh *RealAuthHandler) refreshToken(ctx context.Context) error <span class="cov9" title="23">{
        return RefreshToken(ctx, &amp;rh.Cred)
}</span>

func (rh *RealAuthHandler) addGen3AuthHeader(ctx context.Context, req *http.Request) error <span class="cov9" title="23">{
        err := rh.refreshToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Add headers to the request
        <span class="cov9" title="23">authStr := "Bearer " + rh.Cred.AccessToken
        req.Header.Set("Authorization", authStr)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package indexd_client

// Conversion functions between DRSObject and IndexdRecord

import (
        "fmt"
        "net/url"

        "github.com/calypr/git-drs/drs"
)

// IndexdRecord represents a simplified version of an indexd record for conversion purposes
func indexdRecordFromDrsObject(drsObj *drs.DRSObject) (*IndexdRecord, error) <span class="cov6" title="5">{
        indexdObj := &amp;IndexdRecord{
                Did:      drsObj.Id,
                Size:     drsObj.Size,
                FileName: drsObj.Name,
                URLs:     indexdURLFromDrsAccessURLs(drsObj.AccessMethods),
                Authz:    indexdAuthzFromDrsAccessMethods(drsObj.AccessMethods),
                Hashes:   drsObj.Checksums,
                //Metadata: drsObj.Metadata,
                //Form:     drsObj.Form,
        }
        return indexdObj, nil
}</span>

func indexdRecordToDrsObject(indexdObj *IndexdRecord) (*drs.DRSObject, error) <span class="cov9" title="12">{
        accessMethods, err := drsAccessMethodsFromIndexdURLs(indexdObj.URLs, indexdObj.Authz)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="12">for _, am := range accessMethods </span><span class="cov9" title="12">{
                if am.Authorizations == nil || am.Authorizations.Value == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("access method missing authorization %v, %v", indexdObj, indexdObj.Authz)
                }</span>
        }

        <span class="cov9" title="12">return &amp;drs.DRSObject{
                Id:   indexdObj.Did,
                Size: indexdObj.Size,
                //Form:  indexdObj.Form,
                Name:          indexdObj.FileName,
                AccessMethods: accessMethods,
                Checksums:     indexdObj.Hashes,
                //Metadata: indexdObj.Metadata,
        }, nil</span>
}

func drsAccessMethodsFromIndexdURLs(urls []string, authz []string) ([]drs.AccessMethod, error) <span class="cov10" title="13">{
        var accessMethods []drs.AccessMethod
        for _, urlString := range urls </span><span class="cov10" title="13">{
                var method drs.AccessMethod
                method.AccessURL = drs.AccessURL{URL: urlString}

                parsed, err := url.Parse(urlString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse url %q: %v", urlString, err)
                }</span>
                <span class="cov10" title="13">if parsed.Scheme == "" </span><span class="cov0" title="0">{
                        // default to https if no scheme or parse error
                        method.Type = "https"
                }</span> else<span class="cov10" title="13"> {
                        method.Type = parsed.Scheme
                }</span>

                // check if authz is null or 0-length, then error
                <span class="cov10" title="13">if authz == nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("authz is required")
                }</span>

                // NOTE: a record can only have 1 authz entry atm
                // this is fine since rn we're creating UUIDs based on project ID
                <span class="cov9" title="12">method.Authorizations = &amp;drs.Authorizations{Value: authz[0]}
                accessMethods = append(accessMethods, method)</span>
        }
        <span class="cov9" title="12">return accessMethods, nil</span>
}

// extract authz values from DRS access methods
func indexdAuthzFromDrsAccessMethods(accessMethods []drs.AccessMethod) []string <span class="cov7" title="6">{
        var authz []string
        for _, drsURL := range accessMethods </span><span class="cov7" title="6">{
                if drsURL.Authorizations != nil </span><span class="cov7" title="6">{
                        authz = append(authz, drsURL.Authorizations.Value)
                }</span>
        }
        <span class="cov7" title="6">return authz</span>
}

func indexdURLFromDrsAccessURLs(accessMethods []drs.AccessMethod) []string <span class="cov6" title="5">{
        var urls []string
        for _, drsURL := range accessMethods </span><span class="cov6" title="5">{
                urls = append(urls, drsURL.AccessURL.URL)
        }</span>
        <span class="cov6" title="5">return urls</span>
}

func (inr *IndexdRecord) ToDrsObject() (*drs.DRSObject, error) <span class="cov3" title="2">{
        o, err := indexdRecordToDrsObject(inr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return o, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package indexd_client

import (
        "log/slog"

        "github.com/calypr/data-client/client/conf"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drslog"
)

// Gen3Server holds Gen3 server config
type Gen3Remote struct {
        Endpoint  string `yaml:"endpoint"`
        ProjectID string `yaml:"project_id"`
        Bucket    string `yaml:"bucket"`
}

func (s Gen3Remote) GetProjectId() string <span class="cov10" title="40">{
        return s.ProjectID
}</span>

func (s Gen3Remote) GetEndpoint() string <span class="cov0" title="0">{
        return s.Endpoint
}</span>

func (s Gen3Remote) GetBucketName() string <span class="cov10" title="40">{
        return s.Bucket
}</span>

func (s Gen3Remote) GetClient(params map[string]string, logger *slog.Logger) (client.DRSClient, error) <span class="cov9" title="32">{
        cred, err := conf.NewConfigure(drslog.AsStdLogger(logger)).Load(params["remote_name"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="32">return NewIndexDClient(*cred, s, logger)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package indexd_client

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/client/common"
        "github.com/calypr/data-client/client/conf"
        "github.com/calypr/data-client/client/logs"
        "github.com/calypr/data-client/client/upload"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "github.com/hashicorp/go-multierror"
        "github.com/hashicorp/go-retryablehttp"

        dataClient "github.com/calypr/data-client/client/client"
)

type IndexDClient struct {
        Base        *url.URL
        ProjectId   string
        BucketName  string
        Logger      *slog.Logger
        AuthHandler cloud.AuthHandler // Injected for testing/flexibility

        HttpClient *retryablehttp.Client
        SConfig    sonic.API

        Upsert             bool  // whether to force push (upsert) indexd records and file uploads
        MultiPartThreshold int64 // threshold for multipart uploads
}

////////////////////
// CLIENT METHODS //
////////////////////

// load repo-level config and return a new IndexDClient
func NewIndexDClient(profileConfig conf.Credential, remote Gen3Remote, logger *slog.Logger) (client.DRSClient, error) <span class="cov9" title="33">{

        baseUrl, err := url.Parse(profileConfig.APIEndpoint)
        // get the gen3Project and gen3Bucket from the config
        projectId := remote.GetProjectId()
        if projectId == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no gen3 project specified. Run 'git drs init', use the '--help' flag for more info")
        }</span>

        <span class="cov9" title="33">bucketName := remote.GetBucketName()
        if bucketName == "" </span><span class="cov0" title="0">{
                logger.Debug("WARNING: no gen3 bucket specified. To add a bucket, run 'git remote add gen3', use the '--help' flag for more info")
        }</span>

        <span class="cov9" title="33">transport := &amp;http.Transport{
                MaxIdleConns:        100, // Default pool size (across all hosts)
                MaxIdleConnsPerHost: 100, // Important: Pool size per *single host* (your Indexd server)
                IdleConnTimeout:     90 * time.Second,
        }
        httpClient := &amp;http.Client{
                Timeout:   30 * time.Second,
                Transport: transport,
        }
        retryClient := retryablehttp.NewClient()
        retryClient.HTTPClient = httpClient

        // Custom CheckRetry: do not retry when response body contains "already exists"
        retryClient.CheckRetry = func(ctx context.Context, resp *http.Response, err error) (bool, error) </span><span class="cov8" title="22">{
                if resp != nil &amp;&amp; resp.StatusCode &lt; 500 &amp;&amp; resp.StatusCode &gt;= 400 </span><span class="cov2" title="2">{
                        // do not retry on 4xx
                        // 400 =&gt; "The request could not be understood by the
                        // server due to malformed syntax".
                        return false, nil
                }</span>
                <span class="cov8" title="20">if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov8" title="20">{
                        bodyBytes, readErr := io.ReadAll(resp.Body)
                        // restore body for downstream consumers
                        resp.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                        if readErr == nil </span><span class="cov8" title="20">{
                                if strings.Contains(string(bodyBytes), "already exists") </span><span class="cov0" title="0">{
                                        // do not retry on "already exists" messages
                                        return false, nil
                                }</span>
                        }
                }
                // fallback to default policy
                <span class="cov8" title="20">return retryablehttp.DefaultRetryPolicy(ctx, resp, err)</span>
        }

        <span class="cov9" title="33">retryClient.Logger = drslog.AsStdLogger(logger)
        // TODO - make these configurable?
        retryClient.RetryMax = 5
        retryClient.RetryWaitMin = 5 * time.Second
        retryClient.RetryWaitMax = 15 * time.Second

        upsert, err := getLfsCustomTransferBool("lfs.customtransfer.drs.upsert", false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="33">multiPartThresholdInt, err := getLfsCustomTransferInt("lfs.customtransfer.drs.multipart-threshold", 500)
        var multiPartThreshold int64 = multiPartThresholdInt * common.MB // default 100 MB

        return &amp;IndexDClient{
                Base:               baseUrl,
                ProjectId:          projectId,
                BucketName:         bucketName,
                Logger:             logger,
                AuthHandler:        &amp;RealAuthHandler{profileConfig}, // Use real auth in production
                HttpClient:         retryClient,
                SConfig:            sonic.ConfigFastest,
                Upsert:             upsert,
                MultiPartThreshold: multiPartThreshold,
        }, nil</span>
}

func (cl *IndexDClient) GetProjectId() string <span class="cov5" title="5">{
        return cl.ProjectId
}</span>

func getLfsCustomTransferBool(key string, defaultValue bool) (bool, error) <span class="cov10" title="35">{
        defaultText := strconv.FormatBool(defaultValue)
        // TODO cache or get all the configs at once?
        cmd := exec.Command("git", "config", "--get", "--default", defaultText, key)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue, fmt.Errorf("error reading git config %s: %v", key, err)
        }</span>

        <span class="cov10" title="35">value := strings.TrimSpace(string(output))

        parsed, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue, fmt.Errorf("invalid boolean value for %s: &gt;%q&lt;", key, value)
        }</span>
        <span class="cov10" title="35">return parsed, nil</span>
}

func getLfsCustomTransferInt(key string, defaultValue int64) (int64, error) <span class="cov9" title="33">{
        defaultText := strconv.FormatInt(defaultValue, 10)
        // TODO cache or get all the configs at once?
        cmd := exec.Command("git", "config", "--get", "--default", defaultText, key)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue, fmt.Errorf("error reading git config %s: %v", key, err)
        }</span>

        <span class="cov9" title="33">value := strings.TrimSpace(string(output))

        parsed, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue, fmt.Errorf("invalid int value for %s: &gt;%q&lt;", key, value)
        }</span>

        <span class="cov9" title="33">if parsed &lt; 1 || parsed &gt; 500 </span><span class="cov0" title="0">{
                return defaultValue, fmt.Errorf("invalid int value for %s: %d. Must be between 1 and 500", key, parsed)
        }</span>

        <span class="cov9" title="33">return parsed, nil</span>
}

// GetProfile extracts the profile from the auth handler if available
// This is only needed for external APIs like g3cmd that require it
func (cl *IndexDClient) GetProfile() (string, error) <span class="cov4" title="4">{
        if rh, ok := cl.AuthHandler.(*RealAuthHandler); ok </span><span class="cov3" title="3">{
                return rh.Cred.Profile, nil
        }</span>
        <span class="cov1" title="1">return "", fmt.Errorf("AuthHandler is not RealAuthHandler, cannot extract profile")</span>
}

func (cl *IndexDClient) DeleteRecordsByProject(projectId string) error <span class="cov0" title="0">{
        recs, err := cl.ListObjectsByProject(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for rec := range recs </span><span class="cov0" title="0">{
                for sumType, sum := range hash.ConvertHashInfoToMap(rec.Object.Checksums) </span><span class="cov0" title="0">{
                        if sumType == string(hash.ChecksumTypeSHA256) </span><span class="cov0" title="0">{
                                err := cl.DeleteRecord(sum)
                                if err != nil </span><span class="cov0" title="0">{
                                        cl.Logger.Debug(fmt.Sprintf("DeleteRecordsByProject Error: %v", err))
                                        continue</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (cl *IndexDClient) DeleteRecord(oid string) error <span class="cov0" title="0">{
        // get records by hash
        record, err := cl.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting records for OID %s: %v", oid, err)
        }</span>
        <span class="cov0" title="0">if len(record) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no records found for OID %s", oid)
        }</span>

        // Find a record that matches the project ID
        <span class="cov0" title="0">matchingRecord, err := drsmap.FindMatchingRecord(record, cl.GetProjectId())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error finding matching record for project %s: %v", cl.GetProjectId(), err)
        }</span>
        <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no matching record found for project %s", cl.GetProjectId())
        }</span>

        // call helper to do the delete for a gen3 GUID
        <span class="cov0" title="0">return cl.deleteIndexdRecord(matchingRecord.Id)</span>
}

func (cl *IndexDClient) deleteIndexdRecord(did string) error <span class="cov2" title="2">{
        // get the indexd record, can't use GetObject cause the DRS object doesn't contain the rev
        record, err := cl.getIndexdRecordByDID(did)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not query index record for did %s: %v", did, err)
        }</span>

        // delete indexd record using did and rev
        <span class="cov2" title="2">url := fmt.Sprintf("%s/index/index/%s?rev=%s", cl.Base.String(), did, record.Rev)
        delReq, err := retryablehttp.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">err = cl.AuthHandler.AddAuthHeader(delReq.Request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error adding Gen3 auth header to delete record: %v", err)
        }</span>
        // set Content-Type header for JSON
        <span class="cov2" title="2">delReq.Header.Set("accept", "application/json")

        delResp, err := cl.HttpClient.Do(delReq)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">defer delResp.Body.Close()

        // response error handling
        if delResp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                bodyBytes, readErr := io.ReadAll(delResp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete failed with status %s: could not read response body: %v", delResp.Status, readErr)
                }</span>
                <span class="cov0" title="0">bodyString := string(bodyBytes)
                return fmt.Errorf("delete failed with status %s. Response body: %s", delResp.Status, bodyString)</span>
        }
        <span class="cov2" title="2">return nil</span>
}

func (cl *IndexDClient) RegisterRecord(record *drs.DRSObject) (*drs.DRSObject, error) <span class="cov0" title="0">{
        // prolly could do cleanup but use register record
        indexdRecord, err := indexdRecordFromDrsObject(record)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting DRS object to indexd record: %v", err)
        }</span>

        <span class="cov0" title="0">return cl.RegisterIndexdRecord(indexdRecord)</span>
}

// GetDownloadURL implements DRSClient
func (cl *IndexDClient) GetDownloadURL(oid string) (*drs.AccessURL, error) <span class="cov4" title="4">{

        cl.Logger.Debug(fmt.Sprintf("Try to get download url for file OID %s", oid))

        // get the DRS object using the OID
        records, err := cl.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error getting DRS object for OID %s: %s", oid, err))
                return nil, fmt.Errorf("error getting DRS object for OID %s: %v", oid, err)
        }</span>
        <span class="cov4" title="4">return cl.getDownloadURLFromRecords(oid, records)</span>
}

func (cl *IndexDClient) getDownloadURLFromRecords(oid string, records []drs.DRSObject) (*drs.AccessURL, error) <span class="cov4" title="4">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no DRS object found for OID %s", oid))
                return nil, fmt.Errorf("no DRS object found for OID %s", oid)
        }</span>

        // Find a record that matches the client's project ID
        <span class="cov4" title="4">matchingRecord, err := drsmap.FindMatchingRecord(records, cl.ProjectId)
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error finding matching record for project %s: %s", cl.ProjectId, err))
                return nil, fmt.Errorf("error finding matching record for project %s: %v", cl.ProjectId, err)
        }</span>
        <span class="cov4" title="4">if matchingRecord == nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no matching record found for project %s", cl.ProjectId))
                return nil, fmt.Errorf("no matching record found for project %s", cl.ProjectId)
        }</span>

        <span class="cov4" title="4">cl.Logger.Debug(fmt.Sprintf("Matching record: %#v for oid %s", matchingRecord, oid))
        drsObj := matchingRecord

        // Check if access methods exist
        if len(drsObj.AccessMethods) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no access methods available for DRS object %s", drsObj.Id))
                return nil, fmt.Errorf("no access methods available for DRS object %s", drsObj.Id)
        }</span>

        // naively get access ID from splitting first path into :
        <span class="cov4" title="4">accessType := drsObj.AccessMethods[0].Type
        if accessType == "" </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0]))
                return nil, fmt.Errorf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0])
        }</span>
        <span class="cov4" title="4">did := drsObj.Id

        accessUrl, err := cl.getDownloadURL(did, accessType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="4">return &amp;accessUrl, nil</span>
}

// getDownloadURL gets a signed URL for the given DRS ID and accessType (eg s3)
func (cl *IndexDClient) getDownloadURL(did string, accessType string) (drs.AccessURL, error) <span class="cov6" title="8">{
        // get signed url
        a := *cl.Base
        a.Path = filepath.Join(a.Path, "ga4gh/drs/v1/objects", did, "access", accessType)

        req, err := retryablehttp.NewRequest("GET", a.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return drs.AccessURL{}, err
        }</span>

        <span class="cov6" title="8">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return drs.AccessURL{}, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

        <span class="cov6" title="8">response, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return drs.AccessURL{}, fmt.Errorf("error getting signed URL: %v", err)
        }</span>
        <span class="cov6" title="8">defer func() </span><span class="cov6" title="8">{
                if closeErr := response.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        cl.Logger.Debug(fmt.Sprintf("error closing response body: %v", closeErr))
                }</span>
        }()

        <span class="cov6" title="8">accessUrl := drs.AccessURL{}

        // read full body so we can both decode and include it in any error
        bodyBytes, readErr := io.ReadAll(response.Body)
        if readErr != nil </span><span class="cov0" title="0">{
                return drs.AccessURL{}, fmt.Errorf("unable to read response body: %v", readErr)
        }</span>

        <span class="cov6" title="8">if err := cl.SConfig.Unmarshal(bodyBytes, &amp;accessUrl); err != nil </span><span class="cov0" title="0">{
                return drs.AccessURL{}, fmt.Errorf("unable to decode response into drs.AccessURL: %v; body: %s", err, string(bodyBytes))
        }</span>

        // check if empty
        <span class="cov6" title="8">if accessUrl.URL == "" </span><span class="cov0" title="0">{
                return drs.AccessURL{}, fmt.Errorf("signed url is empty %#v %s", accessUrl, response.Status)
        }</span>

        <span class="cov6" title="8">cl.Logger.Debug(fmt.Sprintf("signed url retrieved: %s", response.Status))

        return accessUrl, nil</span>
}

// RegisterFile implements DRSClient.
// It registers (or reuses) an indexd record for the oid, uploads the object if it
// is not already available in the bucket, and returns the resulting DRS object.
// When registration fails without force push, it retries once with force push
// enabled to reuse existing records and avoid duplicate uploads.
func (cl *IndexDClient) RegisterFile(oid string, progressCallback common.ProgressCallback) (*drs.DRSObject, error) <span class="cov4" title="4">{
        cl.Logger.Debug(fmt.Sprintf("register file started for oid: %s", oid))

        // load the DRS object from oid created by prepush
        drsObject, err := drsmap.DrsInfoFromOid(oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting drs object for oid %s: %v", oid, err)
        }</span>

        // convert to indexd record
        <span class="cov4" title="4">indexdObj, err := indexdRecordFromDrsObject(drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting DRS object oid %s to indexd record: %v", oid, err)
        }</span>

        // save the indexd record
        <span class="cov4" title="4">_, err = cl.RegisterIndexdRecord(indexdObj)
        if err != nil </span><span class="cov2" title="2">{
                // handle "already exists" error ie upsert behavior
                if strings.Contains(err.Error(), "already exists") </span><span class="cov2" title="2">{
                        if !cl.Upsert </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("indexd record already exists, proceeding for oid %s: did: %s err: %v", oid, indexdObj.Did, err))
                        }</span> else<span class="cov2" title="2"> {
                                cl.Logger.Debug(fmt.Sprintf("indexd record already exists, deleting and re-adding for oid %s: did: %s err: %v", oid, indexdObj.Did, err))
                                err = cl.deleteIndexdRecord(indexdObj.Did)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error deleting existing indexd record oid %s: did: %s err: %v", oid, indexdObj.Did, err)
                                }</span>
                                <span class="cov2" title="2">_, err = cl.RegisterIndexdRecord(indexdObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error re-saving indexd record after deletion: oid %s: did: %s err: %v", oid, indexdObj.Did, err)
                                }</span>
                        }

                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("error saving oid %s indexd record: %v", oid, err)
                }</span>
        }

        // Now attempt to upload the file if not already available
        <span class="cov4" title="4">downloadable, err := cl.isFileDownloadable(drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error checking if file is downloadable: oid %s %v", oid, err)
        }</span>
        <span class="cov4" title="4">if downloadable </span><span class="cov2" title="2">{
                cl.Logger.Debug(fmt.Sprintf("file %s is already available for download, skipping upload", oid))
                return drsObject, nil
        }</span>

        // Proceed to upload the file -------------------
        <span class="cov2" title="2">profile, err := cl.GetProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting profile for upload: %v", err)
        }</span>
        // TODO - should we deprecate this gen3-client style logger in favor of drslog.Logger?
        // TODO - or can we "wrap it" so both work together?
        <span class="cov2" title="2">logger, closer := logs.New(profile, logs.WithBaseLogger(drslog.AsStdLogger(cl.Logger)))
        defer closer()
        // Instantiate interface to Gen3
        // TODO - Can we reuse this interface to avoid repeated config parsing and most likely repeated token refresh?
        // TODO - Can we reuse Auth to ensure we are not repeatedly refreshing tokens?
        g3, err := dataClient.NewGen3Interface(profile, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating Gen3 interface: %v", err)
        }</span>

        <span class="cov2" title="2">filePath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span>
        <span class="cov2" title="2">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov2" title="2">defer func(file *os.File) </span><span class="cov2" title="2">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cl.Logger.Debug(fmt.Sprintf("warning: error closing file %s: %v", filePath, err))
                }</span>
        }(file)

        <span class="cov2" title="2">if drsObject.Size &lt; cl.MultiPartThreshold </span><span class="cov1" title="1">{
                cl.Logger.Debug(fmt.Sprintf("UploadSingle size: %d path: %s", drsObject.Size, filePath))
                err := upload.UploadSingle(context.Background(), g3.GetCredential().Profile, drsObject.Id, drsObject.Checksums.SHA256, filePath, cl.BucketName, false, progressCallback)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("UploadSingle error: %s", err)
                }</span>
        } else<span class="cov1" title="1"> {
                cl.Logger.Debug(fmt.Sprintf("MultipartUpload size: %d path: %s", drsObject.Size, filePath))
                err = upload.MultipartUpload(
                        context.TODO(),
                        g3,
                        common.FileUploadRequestObject{
                                FilePath:     filePath,
                                Filename:     filepath.Base(filePath),
                                GUID:         drsObject.Id,
                                OID:          drsObject.Checksums.SHA256,
                                FileMetadata: common.FileMetadata{},
                                Bucket:       cl.BucketName,
                                Progress:     progressCallback,
                        },
                        file, false,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("MultipartUpload error: %s", err)
                }</span>
        }
        <span class="cov2" title="2">return drsObject, nil</span>

}

func (cl *IndexDClient) isFileDownloadable(drsObject *drs.DRSObject) (bool, error) <span class="cov4" title="4">{
        if drsObject == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("drsObject is nil")
        }</span>
        <span class="cov4" title="4">if len(drsObject.AccessMethods) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("DRS object %s has no access methods; proceeding to upload", drsObject.Id))
                return false, nil
        }</span>
        <span class="cov4" title="4">cl.Logger.Debug(fmt.Sprintf("checking if %s file is downloadable %v %v %v", drsObject.Id, drsObject.AccessMethods[0].AccessID, drsObject.AccessMethods[0].Type, drsObject.AccessMethods[0].AccessURL))
        signedUrl, err := cl.getDownloadURL(drsObject.Id, drsObject.AccessMethods[0].Type)
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error getting signed URL for file with oid %s: %s", drsObject.Id, err))
                return false, fmt.Errorf("error getting signed URL for file with oid %s: %s", drsObject.Id, err)
        }</span>
        <span class="cov4" title="4">if signedUrl.URL == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov4" title="4">err = utils.CanDownloadFile(signedUrl.URL)
        if err != nil </span><span class="cov2" title="2">{
                cl.Logger.Debug(fmt.Sprintf("file with oid %s does not exist in bucket: %s", drsObject.Id, err))
                return false, nil
        }</span>
        <span class="cov2" title="2">cl.Logger.Debug(fmt.Sprintf("file with oid %s exists in bucket", drsObject.Id))
        return true, nil</span>
}

func (cl *IndexDClient) GetObject(id string) (*drs.DRSObject, error) <span class="cov1" title="1">{

        a := *cl.Base
        a.Path = filepath.Join(a.Path, "ga4gh/drs/v1/objects", id)

        req, err := retryablehttp.NewRequest("GET", a.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

        <span class="cov1" title="1">response, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer response.Body.Close()

        if response.Status == "404" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s not found", id)
        }</span>

        <span class="cov1" title="1">in := drs.OutputObject{}
        if err := cl.SConfig.NewDecoder(response.Body).Decode(&amp;in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return drs.ConvertOutputObjectToDRSObject(&amp;in), nil</span>

}

func (cl *IndexDClient) ListObjectsByProject(projectId string) (chan drs.DRSObjectResult, error) <span class="cov2" title="2">{
        const PAGESIZE = 50
        pageNum := 0

        cl.Logger.Debug("Getting DRS objects from indexd")
        resourcePath, err := utils.ProjectToResource(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">a := *cl.Base
        a.Path = filepath.Join(a.Path, "index/index")

        out := make(chan drs.DRSObjectResult, PAGESIZE)

        go func() </span><span class="cov2" title="2">{
                defer close(out)

                // This will hold all errors encountered during the loop
                var resultErrors *multierror.Error
                active := true

                for active </span><span class="cov4" title="4">{
                        req, err := retryablehttp.NewRequest("GET", a.String(), nil)
                        if err != nil </span><span class="cov0" title="0">{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("request creation: %w", err))
                                break</span>
                        }

                        <span class="cov4" title="4">q := req.URL.Query()
                        q.Add("authz", resourcePath)
                        q.Add("limit", fmt.Sprintf("%d", PAGESIZE))
                        q.Add("page", fmt.Sprintf("%d", pageNum))
                        req.URL.RawQuery = q.Encode()

                        if err := cl.AuthHandler.AddAuthHeader(req.Request); err != nil </span><span class="cov0" title="0">{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("auth: %w", err))
                                break</span>
                        }

                        <span class="cov4" title="4">response, err := cl.HttpClient.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("http call: %w", err))
                                break</span>
                        }

                        // Read body and close immediately
                        <span class="cov3" title="3">body, err := io.ReadAll(response.Body)
                        response.Body.Close()

                        if err != nil </span><span class="cov0" title="0">{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("read body: %w", err))
                                break</span>
                        }

                        <span class="cov3" title="3">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("api error %d: %s", response.StatusCode, string(body)))
                                break</span>
                        }

                        <span class="cov3" title="3">page := &amp;ListRecords{}
                        if err := cl.SConfig.Unmarshal(body, &amp;page); err != nil </span><span class="cov0" title="0">{
                                resultErrors = multierror.Append(resultErrors, fmt.Errorf("unmarshal: %w", err))
                                break</span>
                        }

                        <span class="cov3" title="3">if len(page.Records) == 0 </span><span class="cov1" title="1">{
                                active = false
                        }</span>

                        <span class="cov3" title="3">for _, elem := range page.Records </span><span class="cov2" title="2">{
                                drsObj, err := elem.ToIndexdRecord().ToDrsObject()
                                if err != nil </span><span class="cov0" title="0">{
                                        // Append and keep going, or break if this is fatal
                                        resultErrors = multierror.Append(resultErrors, err)
                                        continue</span>
                                }
                                <span class="cov2" title="2">out &lt;- drs.DRSObjectResult{Object: drsObj}</span>
                        }
                        <span class="cov3" title="3">pageNum++</span>
                }

                // If we accumulated any errors, send the final concatenated result
                <span class="cov1" title="1">if resultErrors != nil </span><span class="cov0" title="0">{
                        out &lt;- drs.DRSObjectResult{Error: resultErrors.ErrorOrNil()}
                }</span>
        }()

        <span class="cov2" title="2">return out, nil</span>
}

// given indexd record, constructs a new indexd record
// implements /index/index POST
func (cl *IndexDClient) RegisterIndexdRecord(indexdObj *IndexdRecord) (*drs.DRSObject, error) <span class="cov5" title="7">{
        indexdObjForm := IndexdRecordForm{
                IndexdRecord: *indexdObj,
                Form:         "object",
        }

        jsonBytes, err := sonic.Marshal(indexdObjForm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="7">cl.Logger.Debug(fmt.Sprintf("writing IndexdObj: %s", string(jsonBytes)))

        // register DRS object via /index POST
        // (setup post request to indexd)
        endpt := *cl.Base
        endpt.Path = filepath.Join(endpt.Path, "index", "index")

        req, err := retryablehttp.NewRequest("POST", endpt.String(), bytes.NewBuffer(jsonBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // set Content-Type header for JSON
        <span class="cov5" title="7">req.Header.Set("accept", "application/json")
        req.Header.Set("Content-Type", "application/json")

        // add auth token
        err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

        <span class="cov5" title="7">cl.Logger.Debug(fmt.Sprintf("POST request created for indexd: %s", endpt.String()))
        response, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="7">defer response.Body.Close()

        // check and see if the response status is OK
        drsId := indexdObjForm.Did
        if response.StatusCode != http.StatusOK </span><span class="cov2" title="2">{
                body, _ := io.ReadAll(response.Body)
                return nil, fmt.Errorf("failed to register DRS ID %s: %s", drsId, body)
        }</span>
        <span class="cov5" title="5">cl.Logger.Debug(fmt.Sprintf("POST successful: %s", response.Status))

        // removed re-query return DRS object (was missing access method authorization anyway)
        drsObj, err := indexdRecordToDrsObject(indexdObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting indexd record to DRS object: %w %v", err, indexdObj)
        }</span>
        <span class="cov5" title="5">return drsObj, nil</span>
}

// implements /index{did}?rev={rev} DELETE
func (cl *IndexDClient) DeleteIndexdRecord(did string) error <span class="cov0" title="0">{
        // get the indexd record, can't use GetObject cause the DRS object doesn't contain the rev
        record, err := cl.GetIndexdRecordByDID(did)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not query index record for did %s: %v", did, err)
        }</span>

        // delete indexd record using did and rev
        <span class="cov0" title="0">url := fmt.Sprintf("%s/index/index/%s?rev=%s", cl.Base.String(), did, record.Rev)
        delReq, err := retryablehttp.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cl.AuthHandler.AddAuthHeader(delReq.Request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error adding Gen3 auth header to delete record: %v", err)
        }</span>
        // set Content-Type header for JSON
        <span class="cov0" title="0">delReq.Header.Set("accept", "application/json")
        delResp, err := cl.HttpClient.Do(delReq)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer delResp.Body.Close()

        if delResp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                bodyBytes, readErr := io.ReadAll(delResp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete failed with status %s: could not read response body: %v", delResp.Status, readErr)
                }</span>
                <span class="cov0" title="0">bodyString := string(bodyBytes)
                return fmt.Errorf("delete failed with status %s. Response body: %s", delResp.Status, bodyString)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// implements /index/index?hash={hashType}:{hash} GET
func (cl *IndexDClient) GetObjectByHash(sum *hash.Checksum) ([]drs.DRSObject, error) <span class="cov5" title="5">{
        // setup get request to indexd
        url := fmt.Sprintf("%s/index/index?hash=%s:%s", cl.Base.String(), sum.Type, sum.Checksum)
        cl.Logger.Debug(fmt.Sprintf("Querying indexd at %s", url))
        req, err := retryablehttp.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("http.NewRequest Error: %s", err))
                return nil, err
        }</span>
        <span class="cov5" title="5">cl.Logger.Debug(fmt.Sprintf("Looking for files with hash %s:%s", sum.Type, sum.Checksum))

        err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to add authentication when searching for object: %s:%s. More on the error: %v", sum.Type, sum.Checksum, err)
        }</span>
        <span class="cov5" title="5">req.Header.Set("accept", "application/json")

        // run request and do checks
        resp, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to check if server has files with hash %s:%s: %v", sum.Type, sum.Checksum, err)
        }</span>
        <span class="cov5" title="5">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("failed to query indexd for %s:%s. Error: %s, %s", sum.Type, sum.Checksum, resp.Status, string(body))
        }</span>

        // unmarshal response body
        <span class="cov5" title="5">records := ListRecords{}
        err = cl.SConfig.NewDecoder(resp.Body).Decode(&amp;records)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling (%s:%s): %v", sum.Type, sum.Checksum, err)
        }</span>
        // log how many records were found
        <span class="cov5" title="5">cl.Logger.Debug(fmt.Sprintf("Found %d indexd record(s) matching the hash %v", len(records.Records), records))

        out := make([]drs.DRSObject, 0, len(records.Records))

        // if no records found, return empty slice
        if len(records.Records) == 0 </span><span class="cov0" title="0">{
                return out, nil
        }</span>

        <span class="cov5" title="5">resourcePath, _ := utils.ProjectToResource(cl.GetProjectId())

        for _, record := range records.Records </span><span class="cov5" title="7">{
                // skip records that do not authorize this client/project
                found := false
                for _, a := range record.Authz </span><span class="cov5" title="7">{
                        if a == resourcePath </span><span class="cov4" title="4">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov5" title="7">if !found </span><span class="cov3" title="3">{
                        continue</span>
                }

                <span class="cov4" title="4">drsObj, err := indexdRecordToDrsObject(record.ToIndexdRecord())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting indexd record to DRS object: %w", err)
                }</span>
                <span class="cov4" title="4">out = append(out, *drsObj)</span>
        }

        <span class="cov5" title="5">return out, nil</span>
}

// GetProjectSample retrieves a sample of DRS objects for a given project (limit: 1 by default)
// Returns up to 'limit' records for preview purposes before destructive operations
func (cl *IndexDClient) GetProjectSample(projectId string, limit int) ([]drs.DRSObject, error) <span class="cov1" title="1">{
        if limit &lt;= 0 </span><span class="cov1" title="1">{
                limit = 1
        }</span>

        <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("Getting sample DRS objects from indexd for project %s (limit: %d)", projectId, limit))

        // Reuse ListObjectsByProject and collect first 'limit' results
        objChan, err := cl.ListObjectsByProject(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">result := make([]drs.DRSObject, 0, limit)
        for objResult := range objChan </span><span class="cov1" title="1">{
                if objResult.Error != nil </span><span class="cov0" title="0">{
                        return nil, objResult.Error
                }</span>
                <span class="cov1" title="1">result = append(result, *objResult.Object)

                // Stop after collecting enough samples
                if len(result) &gt;= limit </span><span class="cov1" title="1">{
                        // Drain remaining results to avoid goroutine leak
                        go func() </span><span class="cov1" title="1">{
                                for range objChan </span>{<span class="cov0" title="0">
                                }</span>
                        }()
                        <span class="cov1" title="1">break</span>
                }
        }

        <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("Retrieved %d sample record(s)", len(result)))
        return result, nil</span>
}

// implements /index/index?authz={resource_path}&amp;start={start}&amp;limit={limit} GET
func (cl *IndexDClient) ListObjects() (chan drs.DRSObjectResult, error) <span class="cov1" title="1">{

        cl.Logger.Debug("Getting DRS objects from indexd")

        a := *cl.Base
        a.Path = filepath.Join(a.Path, "ga4gh/drs/v1/objects")

        out := make(chan drs.DRSObjectResult, 10)

        LIMIT := 50
        pageNum := 0

        go func() </span><span class="cov1" title="1">{
                defer close(out)
                active := true
                for active </span><span class="cov2" title="2">{
                        // setup request
                        req, err := retryablehttp.NewRequest("GET", a.String(), nil)
                        if err != nil </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("error: %s", err))
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span>

                        <span class="cov2" title="2">q := req.URL.Query()
                        q.Add("limit", fmt.Sprintf("%d", LIMIT))
                        q.Add("page", fmt.Sprintf("%d", pageNum))
                        req.URL.RawQuery = q.Encode()

                        err = cl.AuthHandler.AddAuthHeader(req.Request)
                        if err != nil </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("error contacting %s : %s", req.URL, err))
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span>

                        // execute request with error checking
                        <span class="cov2" title="2">response, err := cl.HttpClient.Do(req)

                        if err != nil </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("error: %s", err))
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span>

                        <span class="cov2" title="2">defer response.Body.Close()
                        body, err := io.ReadAll(response.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("error: %s", err))
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span>
                        <span class="cov2" title="2">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("%d: check that your credentials are valid \nfull message: %s", response.StatusCode, body))
                                out &lt;- drs.DRSObjectResult{Error: fmt.Errorf("%d: check your credentials are valid, \nfull message: %s", response.StatusCode, body)}
                                return
                        }</span>

                        // return page of DRS objects
                        <span class="cov2" title="2">page := &amp;drs.DRSPage{}
                        err = cl.SConfig.Unmarshal(body, &amp;page)
                        if err != nil </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("error: %s (%s)", err, body))
                                out &lt;- drs.DRSObjectResult{Error: err}
                                return
                        }</span>
                        <span class="cov2" title="2">for _, elem := range page.DRSObjects </span><span class="cov1" title="1">{
                                out &lt;- drs.DRSObjectResult{Object: &amp;elem}
                        }</span>
                        <span class="cov2" title="2">if len(page.DRSObjects) == 0 </span><span class="cov1" title="1">{
                                active = false
                        }</span>
                        <span class="cov2" title="2">pageNum++</span>
                }

                <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("total pages retrieved: %d", pageNum))</span>
        }()
        <span class="cov1" title="1">return out, nil</span>
}

// UpdateRecord updates an existing indexd record by GUID using the PUT /index/index/{guid} endpoint
// Supports updating: URLs, name (file_name), description (metadata), version, and authz
func (cl *IndexDClient) UpdateRecord(updateInfo *drs.DRSObject, did string) (*drs.DRSObject, error) <span class="cov1" title="1">{
        // Get current revision from existing record
        record, err := cl.GetIndexdRecordByDID(did)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve existing record for DID %s: %v", did, err)
        }</span>

        // Build update payload starting with existing record values
        <span class="cov1" title="1">updatePayload := UpdateInputInfo{
                URLs:     record.URLs,
                FileName: record.FileName,
                Version:  record.Version,
                Authz:    record.Authz,
                ACL:      record.ACL,
                Metadata: record.Metadata,
        }

        // Apply updates from updateInfo
        // Update URLs by appending new access methods (deduplicated)
        if len(updateInfo.AccessMethods) &gt; 0 </span><span class="cov1" title="1">{
                // Collect new URLs from access methods
                newURLs := make([]string, 0, len(updateInfo.AccessMethods))
                for _, a := range updateInfo.AccessMethods </span><span class="cov1" title="1">{
                        newURLs = append(newURLs, a.AccessURL.URL)
                }</span>
                <span class="cov1" title="1">updatePayload.URLs = utils.AddUnique(updatePayload.URLs, newURLs)

                // Append authz from access methods (deduplicated)
                authz := indexdAuthzFromDrsAccessMethods(updateInfo.AccessMethods)
                updatePayload.Authz = utils.AddUnique(updatePayload.Authz, authz)</span>
        }

        // Update name (maps to file_name in indexd)
        <span class="cov1" title="1">if updateInfo.Name != "" </span><span class="cov1" title="1">{
                updatePayload.FileName = updateInfo.Name
        }</span>

        // Update version
        <span class="cov1" title="1">if updateInfo.Version != "" </span><span class="cov1" title="1">{
                updatePayload.Version = updateInfo.Version
        }</span>

        // Update description (stored in metadata)
        <span class="cov1" title="1">if updateInfo.Description != "" </span><span class="cov1" title="1">{
                if updatePayload.Metadata == nil </span><span class="cov1" title="1">{
                        updatePayload.Metadata = make(map[string]any)
                }</span>
                <span class="cov1" title="1">updatePayload.Metadata["description"] = updateInfo.Description</span>
        }

        <span class="cov1" title="1">jsonBytes, err := cl.SConfig.Marshal(updatePayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling indexd object form: %v", err)
        }</span>

        <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("Prepared updated indexd object for DID %s: %s", did, string(jsonBytes)))

        // prepare URL
        updateURL := fmt.Sprintf("%s/index/index/%s?rev=%s", cl.Base.String(), did, record.Rev)

        req, err := retryablehttp.NewRequest("PUT", updateURL, bytes.NewBuffer(jsonBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating PUT request: %v", err)
        }</span>

        // Set required headers
        <span class="cov1" title="1">req.Header.Set("accept", "application/json")
        req.Header.Set("Content-Type", "application/json")

        err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>

        <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("PUT request created for indexd update: %s", updateURL))

        // Execute the request
        response, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error executing PUT request: %v", err)
        }</span>
        <span class="cov1" title="1">defer response.Body.Close()

        // Check response status
        if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(response.Body)
                return nil, fmt.Errorf("failed to update indexd record %s: status %d, body: %s", did, response.StatusCode, string(body))
        }</span>

        <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("PUT request successful: %s", response.Status))

        // Query and return the updated DRS object
        updatedDrsObj, err := cl.GetObject(did)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error retrieving updated DRS object: %v", err)
        }</span>

        <span class="cov1" title="1">cl.Logger.Debug(fmt.Sprintf("Successfully updated and retrieved DRS object: %s", did))
        return updatedDrsObj, nil</span>
}

// Helper function to get indexd record by DID (similar to existing pattern in DeleteIndexdRecord)
func (cl *IndexDClient) GetIndexdRecordByDID(did string) (*OutputInfo, error) <span class="cov2" title="2">{
        url := fmt.Sprintf("%s/index/%s", cl.Base.String(), did)

        req, err := retryablehttp.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>
        <span class="cov2" title="2">req.Request.Header.Set("accept", "application/json")

        resp, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("failed to get record: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov2" title="2">record := &amp;OutputInfo{}
        if err := cl.SConfig.NewDecoder(resp.Body).Decode(record); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response body: %v", err)
        }</span>

        <span class="cov2" title="2">return record, nil</span>
}

// Helper function to get indexd record by DID (similar to existing pattern in DeleteIndexdRecord)
func (cl *IndexDClient) getIndexdRecordByDID(did string) (*OutputInfo, error) <span class="cov2" title="2">{
        url := fmt.Sprintf("%s/index/%s", cl.Base.String(), did)

        req, err := retryablehttp.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">err = cl.AuthHandler.AddAuthHeader(req.Request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error adding Gen3 auth header: %v", err)
        }</span>
        <span class="cov2" title="2">req.Header.Set("accept", "application/json")

        resp, err := cl.HttpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("failed to get record: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov2" title="2">record := &amp;OutputInfo{}
        if err := cl.SConfig.NewDecoder(resp.Body).Decode(record); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response body: %v", err)
        }</span>

        <span class="cov2" title="2">return record, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package indexd_client

import "github.com/calypr/git-drs/drs/hash"

// Based on OpenAPI specification
// https://github.com/uc-cdis/indexd/blob/master/openapis/swagger.yaml

// subset of the OpenAPI spec for the InputInfo object in indexd
// TODO: make another object based on VersionInputInfo that has content_created_date and so can handle a POST of dates via indexd/&lt;GUID&gt;
type IndexdRecord struct {
        // Unique identifier for the record (UUID)
        Did string `json:"did"`

        // Human-readable file name
        FileName string `json:"file_name,omitempty"`

        // List of URLs where the file can be accessed
        URLs []string `json:"urls"`

        // Hashes of the file (e.g., md5, sha256)
        Size int64 `json:"size"`

        // List of access control lists (ACLs)
        ACL []string `json:"acl,omitempty"`

        // List of authorization policies
        Authz []string `json:"authz,omitempty"`

        Hashes hash.HashInfo `json:"hashes,omitzero"`

        // Additional metadata as key-value pairs
        Metadata map[string]string `json:"metadata,omitempty"`

        // Version of the record (optional)
        Version string `json:"version,omitempty"`

        // // Created timestamp (RFC3339 format)
        // ContentCreatedDate string `json:"content_created_date,omitempty"`

        // // Updated timestamp (RFC3339 format)
        // ContentUpdatedDate string `json:"content_updated_date,omitempty"`
}

// create indexd record struct used for POSTs that is IndexdRecord with form field
type IndexdRecordForm struct {
        IndexdRecord
        Form string `json:"form"`
        Rev  string `json:"rev,omitempty"`
}

type ListRecordsResult struct {
        Record *OutputInfo
        Error  error
}

type ListRecords struct {
        IDs      []string       `json:"ids"`
        Records  []OutputInfo   `json:"records"`
        Size     int64          `json:"size"`
        Start    int64          `json:"start"`
        Limit    int64          `json:"limit"`
        FileName string         `json:"file_name"`
        URLs     []string       `json:"urls"`
        ACL      []string       `json:"acl"`
        Authz    []string       `json:"authz"`
        Hashes   hash.HashInfo  `json:"hashes"`
        Metadata map[string]any `json:"metadata"`
        Version  string         `json:"version"`
}

type OutputInfo struct {
        Did          string         `json:"did"`
        BaseID       string         `json:"baseid"`
        Rev          string         `json:"rev"`
        Form         string         `json:"form"`
        Size         int64          `json:"size"`
        FileName     string         `json:"file_name"`
        Version      string         `json:"version"`
        Uploader     string         `json:"uploader"`
        URLs         []string       `json:"urls"`
        ACL          []string       `json:"acl"`
        Authz        []string       `json:"authz"`
        Hashes       hash.HashInfo  `json:"hashes"`
        UpdatedDate  string         `json:"updated_date"`
        CreatedDate  string         `json:"created_date"`
        Metadata     map[string]any `json:"metadata"`
        URLsMetadata map[string]any `json:"urls_metadata"`
}

func (outputInfo *OutputInfo) ToIndexdRecord() *IndexdRecord <span class="cov10" title="6">{
        return &amp;IndexdRecord{
                Did:      outputInfo.Did,
                Size:     outputInfo.Size,
                FileName: outputInfo.FileName,
                URLs:     outputInfo.URLs,
                ACL:      outputInfo.ACL,
                Authz:    outputInfo.Authz,
                Hashes:   outputInfo.Hashes,
                //Metadata: outputInfo.Metadata, //TODO: re-enable metadata. One is map[string]string, the other is map[string]interface{}
                Version: outputInfo.Version,
        }
}</span>

// UpdateInputInfo is the put object for index records
type UpdateInputInfo struct {
        // Human-readable file name
        FileName string `json:"file_name,omitempty"`

        // Additional metadata as key-value pairs
        Metadata map[string]any `json:"metadata,omitempty"`

        // URL-specific metadata as key-value pairs
        URLsMetadata map[string]any `json:"urls_metadata,omitempty"`

        // Version of the record
        Version string `json:"version,omitempty"`

        // List of URLs where the file can be accessed
        URLs []string `json:"urls,omitempty"`

        // List of access control lists (ACLs)
        ACL []string `json:"acl,omitempty"`

        // List of authorization policies
        Authz []string `json:"authz,omitempty"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package indexd_client

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/cloud"
)

// getBucketDetailsWithAuth fetches bucket details from Gen3 using an AuthHandler.
// This function accepts an auth handler for dependency injection, making it testable.
// Parameters:
//   - ctx: context for the request
//   - bucket: the bucket name to look up
//   - bucketsEndpointURL: full URL to the /user/data/buckets endpoint
//   - authHandler: handler for adding authentication headers
//   - httpClient: the HTTP client to use
func GetBucketDetailsWithAuth(ctx context.Context, bucket, bucketsEndpointURL string, authHandler cloud.AuthHandler, httpClient *http.Client) (*cloud.S3Bucket, error) <span class="cov10" title="11">{
        // Use provided client or create default
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{}
        }</span>

        <span class="cov10" title="11">req, err := http.NewRequestWithContext(ctx, "GET", bucketsEndpointURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authentication using the auth handler
        <span class="cov10" title="11">if authHandler != nil </span><span class="cov6" title="4">{
                if err := authHandler.AddAuthHeader(req); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to add authentication: %w", err)
                }</span>
        }

        <span class="cov9" title="10">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch bucket information: %w", err)
        }</span>
        <span class="cov9" title="10">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        // extract bucket endpoint
        <span class="cov9" title="9">var bucketInfo cloud.S3BucketsResponse
        if err := sonic.ConfigFastest.NewDecoder(resp.Body).Decode(&amp;bucketInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode bucket information: %w", err)
        }</span>

        <span class="cov9" title="9">if info, exists := bucketInfo.S3Buckets[bucket]; exists </span><span class="cov8" title="7">{
                if info.EndpointURL != "" &amp;&amp; info.Region != "" </span><span class="cov6" title="4">{
                        return info, nil
                }</span>
                <span class="cov5" title="3">return nil, errors.New("endpoint_url or region not found for bucket")</span>
        }

        <span class="cov3" title="2">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cloud

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "strings"
        "sync/atomic"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

// progressReader wraps an io.ReadCloser and periodically writes progress to stderr.
type progressReader struct {
        rc     io.ReadCloser
        label  string
        start  time.Time
        total  int64 // accessed atomically
        quit   chan struct{}
        done   chan struct{}
        ticker time.Duration
}

func newProgressReader(rc io.ReadCloser, label string) io.ReadCloser <span class="cov8" title="1">{
        p := &amp;progressReader{
                rc:     rc,
                label:  label,
                start:  time.Now(),
                quit:   make(chan struct{}),
                done:   make(chan struct{}),
                ticker: 500 * time.Millisecond,
        }

        go func() </span><span class="cov8" title="1">{
                t := time.NewTicker(p.ticker)
                defer t.Stop()
                var last int64
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-t.C:<span class="cov0" title="0">
                                total := atomic.LoadInt64(&amp;p.total)
                                elapsed := time.Since(p.start).Seconds()
                                var rate float64
                                if elapsed &gt; 0 </span><span class="cov0" title="0">{
                                        rate = float64(total) / elapsed
                                }</span>
                                // \r to overwrite the same line like git pull; no newline until done
                                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\r%s: %d bytes (%.1f KiB/s)", p.label, total, rate/1024)
                                last = total</span>
                        case &lt;-p.quit:<span class="cov8" title="1">
                                // final line (replace same line, then newline)
                                total := atomic.LoadInt64(&amp;p.total)
                                _ = last // in case we want to use last for something later
                                fmt.Fprintf(os.Stderr, "\r%s: %d bytes\n", p.label, total)
                                close(p.done)
                                return</span>
                        }
                }
        }()

        <span class="cov8" title="1">return p</span>
}

func (p *progressReader) Read(b []byte) (int, error) <span class="cov8" title="1">{
        n, err := p.rc.Read(b)
        if n &gt; 0 </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;p.total, int64(n))
        }</span>
        <span class="cov8" title="1">return n, err</span>
}

func (p *progressReader) Close() error <span class="cov8" title="1">{
        // Close underlying reader first, then stop progress goroutine and wait for completion.
        err := p.rc.Close()
        close(p.quit)
        &lt;-p.done
        return err
}</span>

// AgentFetchReader fetches the object described by `input` and returns an io.ReadCloser.
// It accepts `s3://bucket/key` URLs and converts them to HTTPS URLs. If `input.AWSEndpoint`
// is set it will use that endpoint in path-style (endpoint/bucket/key); otherwise it
// uses the default virtual-hosted AWS form: https://{bucket}.s3.amazonaws.com/{key}.
func AgentFetchReader(ctx context.Context, input S3ObjectParameters) (io.ReadCloser, error) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov8" title="1">raw := strings.TrimSpace(input.S3URL)
        if raw == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: S3ObjectParameters.S3URL is empty")
        }</span>

        <span class="cov8" title="1">useSignedFetch := strings.TrimSpace(input.AWSAccessKey) != "" ||
                strings.TrimSpace(input.AWSSecretKey) != "" ||
                strings.TrimSpace(input.AWSRegion) != ""
        if useSignedFetch </span><span class="cov8" title="1">{
                if strings.TrimSpace(input.AWSAccessKey) == "" || strings.TrimSpace(input.AWSSecretKey) == "" || strings.TrimSpace(input.AWSRegion) == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: AWSAccessKey, AWSSecretKey, and AWSRegion are required for signed fetch")
                }</span>

                <span class="cov8" title="1">bucket, key, err := parseS3URL(raw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: parse s3 url %q: %w", raw, err)
                }</span>

                <span class="cov8" title="1">s3Client, err := newS3Client(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: init s3 client: %w", err)
                }</span>

                <span class="cov8" title="1">out, err := s3Client.GetObject(ctx, &amp;s3.GetObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: s3 GetObject failed (bucket=%q key=%q): %w", bucket, key, err)
                }</span>
                <span class="cov8" title="1">if out.Body == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: response body is nil for s3://%s/%s", bucket, key)
                }</span>

                <span class="cov8" title="1">label := fmt.Sprintf("fetch s3://%s/%s", bucket, key)
                return newProgressReader(out.Body, label), nil</span>
        }

        <span class="cov0" title="0">u, err := url.Parse(raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: parse url %q: %w", raw, err)
        }</span>

        <span class="cov0" title="0">var s3url string
        switch u.Scheme </span>{
        case "s3":<span class="cov0" title="0">
                bucket := u.Host
                key := strings.TrimPrefix(u.Path, "/")
                if bucket == "" || key == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: invalid s3 URL %q", raw)
                }</span>
                <span class="cov0" title="0">if ep := strings.TrimSpace(input.AWSEndpoint); ep != "" </span><span class="cov0" title="0">{
                        // ensure endpoint has a scheme
                        if !strings.HasPrefix(ep, "http://") &amp;&amp; !strings.HasPrefix(ep, "https://") </span><span class="cov0" title="0">{
                                ep = "https://" + ep
                        }</span>
                        <span class="cov0" title="0">s3url = strings.TrimRight(ep, "/") + "/" + bucket + "/" + key</span>
                } else<span class="cov0" title="0"> {
                        s3url = fmt.Sprintf("https://%s.s3.amazonaws.com/%s", bucket, key)
                }</span>
        case "", "http", "https":<span class="cov0" title="0">
                // allow bare host/path (no scheme) by assuming https, otherwise use as-is
                if u.Scheme == "" </span><span class="cov0" title="0">{
                        s3url = "https://" + raw
                }</span> else<span class="cov0" title="0"> {
                        s3url = raw
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("AgentFetchReader: unsupported URL scheme %q", u.Scheme)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodGet, s3url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: http get %s: %w", s3url, err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                if _, copyErr := io.Copy(io.Discard, resp.Body); copyErr != nil </span><span class="cov0" title="0">{
                        _ = resp.Body.Close()
                        return nil, fmt.Errorf("AgentFetchReader: unexpected status %d fetching %s; failed to drain body: %w", resp.StatusCode, s3url, copyErr)
                }</span>
                <span class="cov0" title="0">if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: unexpected status %d fetching %s; failed to close body: %w", resp.StatusCode, s3url, closeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("AgentFetchReader: unexpected status %d fetching %s", resp.StatusCode, s3url)</span>
        }

        <span class="cov0" title="0">if resp.Body == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: response body is nil for %s", s3url)
        }</span>
        // wrap response body with progress reporting that writes to stderr
        <span class="cov0" title="0">label := fmt.Sprintf("fetch %s", s3url)
        return newProgressReader(resp.Body, label), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cloud

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
)

// downloads a file to a specified path using a signed URL
func DownloadSignedUrl(signedURL string, dstPath string) error <span class="cov10" title="6">{
        // Download the file using the signed URL
        fileResponse, err := http.Get(signedURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="6">defer fileResponse.Body.Close()

        // Check if the response status is OK
        if fileResponse.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, err := io.ReadAll(fileResponse.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download file using signed URL: %s", fileResponse.Status)
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("failed to download file using signed URL: %s. Full error: %s", fileResponse.Status, string(body))</span>
        }

        // Create the destination directory if it doesn't exist
        <span class="cov9" title="5">err = os.MkdirAll(filepath.Dir(dstPath), os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the destination file
        <span class="cov9" title="5">dstFile, err := os.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="5">defer dstFile.Close()

        // Write the file content to the destination file
        _, err = io.Copy(dstFile, fileResponse.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cloud

import (
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
)

// Download downloads the S3 object to a temporary file while computing its SHA256 hash.
// returns the computed SHA256 hash, temporary path and any error encountered.
func Download(ctx context.Context, info *S3Object, s3Input S3ObjectParameters, lfsRoot string) (string, string, error) <span class="cov8" title="1">{
        // 2) object destination
        etag := info.ETag
        subdir1, subdir2 := "xx", "yy"
        if len(etag) &gt;= 4 </span><span class="cov8" title="1">{
                subdir1 = etag[0:2]
                subdir2 = etag[2:4]
        }</span>
        <span class="cov8" title="1">objName := etag
        if objName == "" </span><span class="cov0" title="0">{
                objName = "unknown-etag"
        }</span>
        <span class="cov8" title="1">tmpDir := filepath.Join(lfsRoot, "tmp-objects", subdir1, subdir2)
        tmpObj := filepath.Join(tmpDir, objName)

        // 3) fetch bytes -&gt; tmp, compute sha+count

        // Create the temporary directory and file where the S3 object will be streamed while computing its hash and size.
        if err := os.MkdirAll(tmpDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("mkdir %s: %w", tmpDir, err)
        }</span>

        <span class="cov8" title="1">f, err := os.Create(tmpObj)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("create %s: %w", tmpObj, err)
        }</span>
        // ensure any leftover file is closed and error propagated via named return
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if f != nil </span><span class="cov0" title="0">{
                        if cerr := f.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("close tmp file: %w", cerr)
                        }</span>
                }
        }()

        <span class="cov8" title="1">h := sha256.New()

        var reader io.ReadCloser
        reader, err = AgentFetchReader(ctx, s3Input)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("fetch reader: %w", err)
        }</span>
        // ensure close on any early return; propagate close error via named return
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if reader != nil </span><span class="cov0" title="0">{
                        if cerr := reader.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("close reader: %w", cerr)
                        }</span>
                }
        }()

        <span class="cov8" title="1">n, err := io.Copy(io.MultiWriter(f, h), reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("copy bytes to %s: %w", tmpObj, err)
        }</span>

        // explicitly close reader and handle error
        <span class="cov8" title="1">if cerr := reader.Close(); cerr != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("close reader: %w", cerr)
        }</span>
        <span class="cov8" title="1">reader = nil

        // ensure data is flushed to disk
        if err = f.Sync(); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("sync %s: %w", tmpObj, err)
        }</span>

        // explicitly close tmp file before rename
        <span class="cov8" title="1">if cerr := f.Close(); cerr != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("close %s: %w", tmpObj, cerr)
        }</span>
        <span class="cov8" title="1">f = nil

        // use n (bytes written) to avoid unused var warnings
        _ = n

        // compute hex SHA256 of the fetched content
        computedSHA := fmt.Sprintf("%x", h.Sum(nil))
        return computedSHA, tmpObj, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package lfss3 provides a small helper for Git-LFS + S3 object introspection.
//
// It:
//  1. determines the effective Git LFS storage root (.git/lfs vs git config lfs.storage)
//  2. derives a working-tree filename from the S3 object key (basename of key)
//  3. performs an S3 HEAD Object to retrieve size and user metadata (sha256 if present)
package cloud

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "regexp"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

// S3ObjectParameters container for S3 object identification and access.
type S3ObjectParameters struct {
        S3URL           string
        AWSAccessKey    string
        AWSSecretKey    string
        AWSRegion       string
        AWSEndpoint     string // optional: custom endpoint (Ceph/MinIO/etc.)
        SHA256          string // optional expected hex (64 chars). Can be "sha256:&lt;hex&gt;" or "&lt;hex&gt;"
        DestinationPath string // optional override URL path (worktree filename)
}

// S3Object is what we return.
type S3Object struct {

        // Object identity
        Bucket string
        Key    string
        Path   string // basename of Key (filename), or override from input

        // HEAD-derived info
        SizeBytes   int64
        MetaSHA256  string // from user-defined object metadata (if present)
        ETag        string
        LastModTime time.Time
}

// InspectS3ForLFS does all 3 requested tasks.
func InspectS3ForLFS(ctx context.Context, in S3ObjectParameters) (*S3Object, error) <span class="cov4" title="2">{
        if strings.TrimSpace(in.S3URL) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("S3URL is required")
        }</span>
        <span class="cov4" title="2">if strings.TrimSpace(in.AWSRegion) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("AWSRegion is required")
        }</span>
        <span class="cov4" title="2">if in.AWSAccessKey == "" || in.AWSSecretKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("AWSAccessKey and AWSSecretKey are required")
        }</span>

        // 2) Parse S3 URL + derive working tree filename.
        <span class="cov4" title="2">bucket, key, err := parseS3URL(in.S3URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">worktreeName := strings.TrimSpace(in.DestinationPath)
        if worktreeName == "" </span><span class="cov0" title="0">{
                worktreeName = path.Base(key)
                if worktreeName == "." || worktreeName == "/" || worktreeName == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not derive worktree name from key %q", key)
                }</span>
        } else<span class="cov4" title="2"> if worktreeName == "." || worktreeName == "/" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid worktree name override %q", worktreeName)
        }</span>

        // 3) HEAD on S3 to determine size and meta.SHA256.
        <span class="cov4" title="2">s3Client, err := newS3Client(ctx, in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">head, err := s3Client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("s3 HeadObject failed (bucket=%q key=%q): %w", bucket, key, err)
        }</span>

        <span class="cov4" title="2">metaSHA := extractSHA256FromMetadata(head.Metadata)

        // Optional: validate provided SHA256 against metadata if both exist.
        expected := normalizeSHA256(in.SHA256)
        if expected != "" &amp;&amp; metaSHA != "" &amp;&amp; !strings.EqualFold(expected, metaSHA) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sha256 mismatch: expected=%s head.meta=%s", expected, metaSHA)
        }</span>

        <span class="cov4" title="2">var lm time.Time
        if head.LastModified != nil </span><span class="cov4" title="2">{
                lm = *head.LastModified
        }</span>

        <span class="cov4" title="2">if head.ContentLength == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("s3 HeadObject missing ContentLength (bucket=%q key=%q)", bucket, key)
        }</span>
        <span class="cov4" title="2">sizeBytes := *head.ContentLength

        var etag string
        if head.ETag != nil </span><span class="cov4" title="2">{
                etag = strings.Trim(*head.ETag, `"`)
        }</span>

        <span class="cov4" title="2">out := &amp;S3Object{
                Bucket:      bucket,
                Key:         key,
                Path:        worktreeName,
                SizeBytes:   sizeBytes,
                MetaSHA256:  metaSHA,
                ETag:        etag,
                LastModTime: lm,
        }
        return out, nil</span>
}

//
// --- S3 parsing + client ---
//

var virtualHostedRE = regexp.MustCompile(`^(.+?)\.s3(?:[.-]|$)`)

// parseS3URL parses s3://bucket/key, virtual-hosted HTTPS (bucket.s3.../key)
// and path-style HTTPS (s3.../bucket/key). Returns bucket and key.
func parseS3URL(raw string) (string, string, error) <span class="cov8" title="6">{
        u, err := url.Parse(raw)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="6">switch u.Scheme </span>{
        case "s3":<span class="cov7" title="4">
                bucket := u.Host
                key := strings.TrimPrefix(u.Path, "/")
                return bucket, key, nil</span>
        case "http", "https":<span class="cov4" title="2">
                host := u.Hostname()

                // virtual-hosted: bucket.s3.amazonaws.com or bucket.s3-region.amazonaws.com
                if m := virtualHostedRE.FindStringSubmatch(host); m != nil </span><span class="cov1" title="1">{
                        bucket := m[1]
                        key := strings.TrimPrefix(u.Path, "/")
                        return bucket, key, nil
                }</span>

                // path-style: s3.../bucket/key
                <span class="cov1" title="1">path := strings.TrimPrefix(u.Path, "/")
                if path == "" </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("no bucket in URL: %s", raw)
                }</span>
                <span class="cov1" title="1">parts := strings.SplitN(path, "/", 2)
                bucket := parts[0]
                key := ""
                if len(parts) == 2 </span><span class="cov1" title="1">{
                        key = parts[1]
                }</span>
                <span class="cov1" title="1">return bucket, key, nil</span>
        default:<span class="cov0" title="0">
                return "", "", fmt.Errorf("unsupported scheme: %s", u.Scheme)</span>
        }
}

func newS3Client(ctx context.Context, in S3ObjectParameters) (*s3.Client, error) <span class="cov5" title="3">{
        creds := credentials.NewStaticCredentialsProvider(in.AWSAccessKey, in.AWSSecretKey, "")

        // Custom HTTP client is useful for S3-compatible endpoints.
        httpClient := &amp;http.Client{
                Timeout: 60 * time.Second,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                MinVersion: tls.VersionTLS12,
                        },
                },
        }

        cfg, err := config.LoadDefaultConfig(ctx,
                config.WithRegion(in.AWSRegion),
                config.WithCredentialsProvider(creds),
                config.WithHTTPClient(httpClient),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aws config init failed: %w", err)
        }</span>

        <span class="cov5" title="3">opts := []func(*s3.Options){}
        if strings.TrimSpace(in.AWSEndpoint) != "" </span><span class="cov5" title="3">{
                ep := strings.TrimRight(in.AWSEndpoint, "/")
                opts = append(opts, func(o *s3.Options) </span><span class="cov5" title="3">{
                        o.UsePathStyle = true // usually required for Ceph/MinIO/custom endpoints
                        o.BaseEndpoint = aws.String(ep)
                }</span>)
        }

        <span class="cov5" title="3">return s3.NewFromConfig(cfg, opts...), nil</span>
}

//
// --- SHA256 metadata extraction ---
//

var sha256HexRe = regexp.MustCompile(`(?i)^[0-9a-f]{64}$`)

func normalizeSHA256(s string) string <span class="cov10" title="8">{
        s = strings.TrimSpace(s)
        s = strings.TrimPrefix(strings.ToLower(s), "sha256:")
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov9" title="7">if !sha256HexRe.MatchString(s) </span><span class="cov1" title="1">{
                // If caller provided something malformed, treat as empty.
                // Change this to a hard error if you prefer.
                return ""
        }</span>
        <span class="cov8" title="6">return strings.ToLower(s)</span>
}

func extractSHA256FromMetadata(md map[string]string) string <span class="cov7" title="5">{
        if md == nil </span><span class="cov4" title="2">{
                return ""
        }</span>

        // AWS SDK v2 exposes user-defined metadata WITHOUT the "x-amz-meta-" prefix,
        // and normalizes keys to lower-case.
        <span class="cov5" title="3">candidates := []string{
                "sha256",
                "checksum-sha256",
                "content-sha256",
                "oid-sha256",
                "git-lfs-sha256",
        }

        for _, k := range candidates </span><span class="cov10" title="8">{
                if v, ok := md[k]; ok </span><span class="cov4" title="2">{
                        n := normalizeSHA256(v)
                        if n != "" </span><span class="cov4" title="2">{
                                return n
                        }</span>
                }
        }

        // Sometimes people stash "sha256:&lt;hex&gt;"
        <span class="cov1" title="1">for _, v := range md </span><span class="cov1" title="1">{
                if n := normalizeSHA256(v); n != "" </span><span class="cov1" title="1">{
                        return n
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cloud

import (
        "log/slog"
        "net/http"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

type S3BucketsResponse struct {
        GSBuckets map[string]any       `json:"GS_BUCKETS"`
        S3Buckets map[string]*S3Bucket `json:"S3_BUCKETS"`
}

type S3Bucket struct {
        Region      string   `json:"region,omitempty"`
        EndpointURL string   `json:"endpoint_url,omitempty"`
        Programs    []string `json:"programs,omitempty"`
}

// S3Meta holds S3 object metadata
type S3Meta struct {
        Size         int64
        LastModified string
}

type CustomEndpointResolver struct {
        Endpoint string
}

const (
        AWS_KEY_FLAG_NAME          = "aws-access-key-id"
        AWS_SECRET_FLAG_NAME       = "aws-secret-access-key"
        AWS_KEY_ENV_VAR            = "AWS_ACCESS_KEY_ID"
        AWS_SECRET_ENV_VAR         = "AWS_SECRET_ACCESS_KEY"
        AWS_REGION_FLAG_NAME       = "region"
        AWS_REGION_ENV_VAR         = "AWS_REGION"
        AWS_ENDPOINT_URL_FLAG_NAME = "endpoint-url"
        AWS_ENDPOINT_URL_ENV_VAR   = "AWS_ENDPOINT_URL"
)

// AuthHandler is an interface for adding authentication headers
// This allows us to inject different auth implementations for testing vs production
type AuthHandler interface {
        AddAuthHeader(req *http.Request) error
}

func (r *CustomEndpointResolver) ResolveEndpoint(service, region string) (aws.Endpoint, error) <span class="cov10" title="3">{
        return aws.Endpoint{
                URL: r.Endpoint,
        }, nil
}</span>

// AddURLConfig holds optional clients for dependency injection
type AddURLConfig struct {
        S3Client   *s3.Client
        HttpClient *http.Client
        Logger     *slog.Logger
}

// AddURLOption is a functional option for configuring AddURL
type AddURLOption func(*AddURLConfig)

// WithS3Client provides a custom S3 client to AddURL
func WithS3Client(client *s3.Client) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.S3Client = client
        }</span>
}

// WithHTTPClient provides a custom HTTP client to AddURL
func WithHTTPClient(client *http.Client) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.HttpClient = client
        }</span>
}

// WithLogger provides a custom logger to AddURL
func WithLogger(logger *slog.Logger) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.Logger = logger
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cloud

import (
        "encoding/hex"
        "errors"
        "strings"
)

func ValidateInputs(s3URL string, sha256 string) error <span class="cov10" title="42">{
        if !strings.HasPrefix(s3URL, "s3://") </span><span class="cov6" title="9">{
                return errors.New("invalid S3 URL format. URL should be of the format 's3://bucket/path/to/file'")
        }</span>

        // Normalize case and validate SHA256
        <span class="cov9" title="33">sha256 = strings.ToLower(sha256)
        if len(sha256) != 64 </span><span class="cov5" title="6">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="27">if _, err := hex.DecodeString(sha256); err != nil </span><span class="cov2" title="2">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="25">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package addref

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        drslfs "github.com/calypr/git-drs/drsmap/lfs"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "add-ref &lt;drs_uri&gt; &lt;dst path&gt;",
        Short: "Add a reference to an existing DRS object via URI",
        Long:  "Add a reference to an existing DRS object, eg passing a DRS URI from AnVIL. Requires that the sha256 of the file is already in the cache",
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                drsUri := args[0]
                dstPath := args[1]

                logger := drslog.GetLogger()

                logger.Debug(fmt.Sprintf("Adding reference to DRS object %s to %s", drsUri, dstPath))

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">client, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">obj, err := client.GetObject(drsUri)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">objSha := ""
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                objSha = sum
                        }</span>
                }
                <span class="cov0" title="0">if objSha == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("object %s sha256 not available", drsUri)
                }</span>
                <span class="cov0" title="0">dirPath := filepath.Dir(dstPath)
                _, err = os.Stat(dirPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // The directory does not exist
                        os.MkdirAll(dirPath, os.ModePerm)
                }</span>

                <span class="cov0" title="0">err = drslfs.CreateLfsPointer(obj, dstPath)
                return err</span>
        },
}

func init() <span class="cov10" title="46">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package addurl

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        drslfs "github.com/calypr/git-drs/drsmap/lfs"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

var Cmd = NewCommand()

func NewCommand() *cobra.Command <span class="cov10" title="48">{
        cmd := &amp;cobra.Command{
                Use:   "add-url &lt;s3-url&gt; [path]",
                Short: "Add a file to the Git DRS repo using an S3 URL",
                Args: func(cmd *cobra.Command, args []string) error </span><span class="cov2" title="2">{
                        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                                return errors.New("usage: add-url &lt;s3-url&gt; [path]")
                        }</span>
                        <span class="cov2" title="2">return nil</span>
                },
                RunE: runAddURL,
        }
        <span class="cov10" title="48">addFlags(cmd)
        return cmd</span>
}

func addFlags(cmd *cobra.Command) <span class="cov10" title="48">{
        cmd.Flags().String(
                cloud.AWS_KEY_FLAG_NAME,
                os.Getenv(cloud.AWS_KEY_ENV_VAR),
                "AWS access key",
        )

        cmd.Flags().String(
                cloud.AWS_SECRET_FLAG_NAME,
                os.Getenv(cloud.AWS_SECRET_ENV_VAR),
                "AWS secret key",
        )

        cmd.Flags().String(
                cloud.AWS_REGION_FLAG_NAME,
                os.Getenv(cloud.AWS_REGION_ENV_VAR),
                "AWS S3 region",
        )

        cmd.Flags().String(
                cloud.AWS_ENDPOINT_URL_FLAG_NAME,
                os.Getenv(cloud.AWS_ENDPOINT_URL_ENV_VAR),
                "AWS S3 endpoint (optional, for Ceph/MinIO)",
        )

        // New flag: optional expected SHA256
        cmd.Flags().String(
                "sha256",
                "",
                "Expected SHA256 checksum (optional)",
        )
}</span>

func runAddURL(cmd *cobra.Command, args []string) (err error) <span class="cov2" title="2">{
        return NewAddURLService().Run(cmd, args)
}</span>

// download uses cloud.AgentFetchReader to download the S3 object, returning
// the computed SHA256 and the path to the temporary downloaded file.
// The caller is responsible for moving/deleting the temporary file.
// we include this wrapper function to allow mocking in tests.
var download = func(ctx context.Context, info *cloud.S3Object, input cloud.S3ObjectParameters, lfsRoot string) (string, string, error) <span class="cov1" title="1">{
        return cloud.Download(ctx, info, input, lfsRoot)
}</span>

type AddURLService struct {
        newLogger    func(string, bool) (*slog.Logger, error)
        inspectS3    func(ctx context.Context, input cloud.S3ObjectParameters) (*cloud.S3Object, error)
        isLFSTracked func(path string) (bool, error)
        getGitRoots  func(ctx context.Context) (string, string, error)
        gitLFSTrack  func(ctx context.Context, path string) (bool, error)
        loadConfig   func() (*config.Config, error)
        download     func(ctx context.Context, info *cloud.S3Object, input cloud.S3ObjectParameters, lfsRoot string) (string, string, error)
}

func NewAddURLService() *AddURLService <span class="cov3" title="3">{
        return &amp;AddURLService{
                newLogger:    drslog.NewLogger,
                inspectS3:    cloud.InspectS3ForLFS,
                isLFSTracked: lfs.IsLFSTracked,
                getGitRoots:  lfs.GetGitRootDirectories,
                gitLFSTrack:  lfs.GitLFSTrackReadOnly,
                loadConfig:   config.LoadConfig,
                download:     download,
        }
}</span>

func (s *AddURLService) Run(cmd *cobra.Command, args []string) error <span class="cov3" title="3">{
        ctx := cmd.Context()
        if ctx == nil </span><span class="cov1" title="1">{
                ctx = context.Background()
        }</span>

        <span class="cov3" title="3">if _, err := s.newLogger("", false); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating logger: %v", err)
        }</span>

        <span class="cov3" title="3">input, err := parseAddURLInput(cmd, args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">s3Info, err := s.inspectS3(ctx, input.s3Params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">isTracked, err := s.isLFSTracked(input.path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check LFS tracking for %s: %w", input.path, err)
        }</span>

        <span class="cov3" title="3">gitCommonDir, lfsRoot, err := s.getGitRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get git root directories: %w", err)
        }</span>

        <span class="cov3" title="3">if err := printResolvedInfo(cmd, gitCommonDir, lfsRoot, s3Info, input.path, isTracked, input.sha256); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">oid, err := s.ensureLFSObject(ctx, s3Info, input, lfsRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">if err := writePointerFile(input.path, oid, s3Info.SizeBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">if err := maybeTrackLFS(ctx, s.gitLFSTrack, input.path, isTracked); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">cfg, err := s.loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting config: %v", err)
        }</span>

        <span class="cov3" title="3">remote, err := cfg.GetDefaultRemote()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">remoteConfig := cfg.GetRemote(remote)
        if remoteConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting remote configuration for %s", remote)
        }</span>

        <span class="cov3" title="3">builder := drs.NewObjectBuilder(remoteConfig.GetBucketName(), remoteConfig.GetProjectId())

        file := drslfs.LfsFileInfo{
                Name: input.path,
                Size: s3Info.SizeBytes,
                Oid:  oid,
        }
        if _, err := drsmap.WriteDrsFile(builder, file, &amp;input.s3URL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error WriteDrsFile: %v", err)
        }</span>

        <span class="cov3" title="3">return nil</span>
}

type addURLInput struct {
        s3URL    string
        path     string
        sha256   string
        s3Params cloud.S3ObjectParameters
}

func parseAddURLInput(cmd *cobra.Command, args []string) (addURLInput, error) <span class="cov3" title="3">{
        s3URL := args[0]

        pathArg, err := resolvePathArg(s3URL, args)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, err
        }</span>

        <span class="cov3" title="3">sha256Param, err := cmd.Flags().GetString("sha256")
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag sha256: %w", err)
        }</span>

        <span class="cov3" title="3">awsKey, err := cmd.Flags().GetString(cloud.AWS_KEY_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_KEY_FLAG_NAME, err)
        }</span>
        <span class="cov3" title="3">awsSecret, err := cmd.Flags().GetString(cloud.AWS_SECRET_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_SECRET_FLAG_NAME, err)
        }</span>
        <span class="cov3" title="3">awsRegion, err := cmd.Flags().GetString(cloud.AWS_REGION_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_REGION_FLAG_NAME, err)
        }</span>
        <span class="cov3" title="3">awsEndpoint, err := cmd.Flags().GetString(cloud.AWS_ENDPOINT_URL_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_ENDPOINT_URL_FLAG_NAME, err)
        }</span>

        <span class="cov3" title="3">if awsKey == "" || awsSecret == "" </span><span class="cov0" title="0">{
                return addURLInput{}, errors.New("AWS credentials must be provided via flags or environment variables")
        }</span>
        <span class="cov3" title="3">if awsRegion == "" </span><span class="cov0" title="0">{
                return addURLInput{}, errors.New("AWS region must be provided via flag or environment variable")
        }</span>

        <span class="cov3" title="3">s3Input := cloud.S3ObjectParameters{
                S3URL:           s3URL,
                AWSAccessKey:    awsKey,
                AWSSecretKey:    awsSecret,
                AWSRegion:       awsRegion,
                AWSEndpoint:     awsEndpoint,
                SHA256:          sha256Param,
                DestinationPath: pathArg,
        }

        return addURLInput{
                s3URL:    s3URL,
                path:     pathArg,
                sha256:   sha256Param,
                s3Params: s3Input,
        }, nil</span>
}

func resolvePathArg(s3URL string, args []string) (string, error) <span class="cov3" title="3">{
        if len(args) == 2 </span><span class="cov2" title="2">{
                return args[1], nil
        }</span>
        <span class="cov1" title="1">u, err := url.Parse(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return strings.TrimPrefix(u.Path, "/"), nil</span>
}

func printResolvedInfo(cmd *cobra.Command, gitCommonDir, lfsRoot string, s3Info *cloud.S3Object, pathArg string, isTracked bool, sha256 string) error <span class="cov3" title="3">{
        if _, err := fmt.Fprintf(cmd.OutOrStdout(), `
Resolved Git LFS s3Info
---------------------
Git common dir : %s
LFS storage    : %s

S3 object
---------
Bucket         : %s
Key            : %s
Worktree name  : %s
Size (bytes)   : %d
SHA256 (meta)  : %s
ETag           : %s
Last modified  : %s

Worktree
-------------
path           : %s
tracked by LFS : %v
sha256 param  : %s

`,
                gitCommonDir,
                lfsRoot,
                s3Info.Bucket,
                s3Info.Key,
                s3Info.Path,
                s3Info.SizeBytes,
                s3Info.MetaSHA256,
                s3Info.ETag,
                s3Info.LastModTime.Format("2006-01-02T15:04:05Z07:00"),
                pathArg,
                isTracked,
                sha256,
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("print resolved s3Info: %w", err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

func (s *AddURLService) ensureLFSObject(ctx context.Context, s3Info *cloud.S3Object, input addURLInput, lfsRoot string) (string, error) <span class="cov3" title="3">{
        if input.sha256 != "" </span><span class="cov1" title="1">{
                return input.sha256, nil
        }</span>

        <span class="cov2" title="2">computedSHA, tmpObj, err := s.download(ctx, s3Info, input.s3Params, lfsRoot)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov2" title="2">oid := computedSHA
        dstDir := filepath.Join(lfsRoot, "objects", oid[0:2], oid[2:4])
        dstObj := filepath.Join(dstDir, oid)

        if err := os.MkdirAll(dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("mkdir %s: %w", dstDir, err)
        }</span>

        <span class="cov2" title="2">if err := os.Rename(tmpObj, dstObj); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("rename %s to %s: %w", tmpObj, dstObj, err)
        }</span>

        <span class="cov2" title="2">if _, err := fmt.Fprintf(os.Stderr, "Added data file at %s\n", dstObj); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("stderr write: %w", err)
        }</span>

        <span class="cov2" title="2">return computedSHA, nil</span>
}

func writePointerFile(pathArg, oid string, sizeBytes int64) error <span class="cov3" title="3">{
        pointer := fmt.Sprintf(
                "version https://git-lfs.github.com/spec/v1\noid sha256:%s\nsize %d\n",
                oid, sizeBytes,
        )
        if pathArg == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("empty worktree path")
        }</span>
        <span class="cov3" title="3">safePath := filepath.Clean(pathArg)
        dir := filepath.Dir(safePath)
        if dir != "." &amp;&amp; dir != "/" </span><span class="cov3" title="3">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mkdir %s: %w", dir, err)
                }</span>
        }
        <span class="cov3" title="3">if err := os.WriteFile(safePath, []byte(pointer), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write %s: %w", safePath, err)
        }</span>

        <span class="cov3" title="3">if _, err := fmt.Fprintf(os.Stderr, "Added Git LFS pointer file at %s\n", safePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stderr write: %w", err)
        }</span>
        <span class="cov3" title="3">return nil</span>
}

func maybeTrackLFS(ctx context.Context, gitLFSTrack func(context.Context, string) (bool, error), pathArg string, isTracked bool) error <span class="cov3" title="3">{
        if isTracked </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="2">if _, err := gitLFSTrack(ctx, pathArg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git lfs track %s: %w", pathArg, err)
        }</span>

        <span class="cov2" title="2">if _, err := fmt.Fprintf(os.Stderr, "Info: Added to Git LFS. Remember to `git add %s` and `git commit ...`", pathArg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stderr write: %w", err)
        }</span>
        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cache

import (
        "encoding/csv"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "create-cache &lt;manifest.tsv&gt;",
        Short: "create a local version of a file manifest containing DRS URIs",
        Long:  "create a local version of a file manifest containing DRS URIs. Enables LFS to map its file object id (sha256) back to a DRS URI by file",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                file := args[0]

                // load file
                f, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open manifest file: %w", err)
                }</span>
                <span class="cov0" title="0">defer f.Close()

                // Use encoding/csv with tab delimiter for TSV
                r := csv.NewReader(f)
                r.Comma = '\t'

                // Read header
                header, err := r.Read()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read header: %w", err)
                }</span>

                // Map column names to indices
                <span class="cov0" title="0">colIdx := make(map[string]int, len(header))
                for i, col := range header </span><span class="cov0" title="0">{
                        colIdx[col] = i
                }</span>

                // Check required columns
                <span class="cov0" title="0">shaIdx, shaOk := colIdx["files.sha256"]
                drsIdx, drsOk := colIdx["files.drs_uri"]
                if !shaOk || !drsOk </span><span class="cov0" title="0">{
                        return fmt.Errorf("manifest must contain 'files.sha256' and 'files.drs_uri' columns")
                }</span>

                // Read each row
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        row, err := r.Read()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("error reading manifest file: %w", err)</span>
                        }
                        <span class="cov0" title="0">sha := row[shaIdx]
                        drsURI := row[drsIdx]
                        fmt.Printf("Indexing DRS URI %s with sha256 %s\n", drsURI, sha)

                        // create sha to DRS URI mapping
                        objPath, err := drsmap.GetObjectPath(projectdir.DRS_REF_DIR, sha)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get object path for %s: %w", sha, err)
                        }</span>

                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(objPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", objPath, err)
                        }</span>

                        <span class="cov0" title="0">contents := fmt.Sprintf("files.drs_uri\n%s\n", drsURI)
                        if err := os.WriteFile(objPath, []byte(contents), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write DRS URI for %s: %w", sha, err)
                        }</span>

                        // Split DRS URI into a custom path and write sha to custom path
                        <span class="cov0" title="0">customPath, err := drsmap.CreateCustomPath(projectdir.DRS_REF_DIR, drsURI)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create custom path for %s: %w", drsURI, err)
                        }</span>
                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(customPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", customPath, err)
                        }</span>
                        <span class="cov0" title="0">if err := os.WriteFile(customPath, []byte(sha), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write sha for %s: %w", drsURI, err)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Cache created in %s\n", projectdir.DRS_REF_DIR)
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package delete

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag bool
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete &lt;hash-type&gt; &lt;oid&gt;",
        Short:  "Delete a file using hash and file object ID",
        Long:   "Delete a file using file object ID. Use lfs ls-files to get oid",
        Hidden: true,
        Args:   cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                hashType, oid := args[0], args[1]

                // check hash type is valid Checksum type and sha256
                if hashType != hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                        return fmt.Errorf("only sha256 supported, you requested to remove: %s", hashType)
                }</span>

                <span class="cov0" title="0">logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        return err
                }</span>

                // Get record details before deletion for confirmation
                <span class="cov0" title="0">records, err := drsClient.GetObjectByHash(&amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting records for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no records found for OID %s", oid)
                }</span>

                // Find matching record for current project
                <span class="cov0" title="0">projectId := drsClient.GetProjectId()
                matchingRecord, err := drsmap.FindMatchingRecord(records, projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
                }</span>
                <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no matching record found for project %s and OID %s", projectId, oid)
                }</span>

                // Show details and get confirmation unless --confirm flag is set
                <span class="cov0" title="0">if !confirmFlag </span><span class="cov0" title="0">{
                        utils.DisplayWarningHeader(os.Stderr, "DELETE a DRS record")
                        utils.DisplayField(os.Stderr, "Remote", string(remoteName))
                        utils.DisplayField(os.Stderr, "Project", projectId)
                        utils.DisplayField(os.Stderr, "OID", oid)
                        utils.DisplayField(os.Stderr, "Hash Type", hashType)
                        utils.DisplayField(os.Stderr, "DID", matchingRecord.Id)
                        if matchingRecord.Name != "" </span><span class="cov0" title="0">{
                                utils.DisplayField(os.Stderr, "Filename", matchingRecord.Name)
                        }</span>
                        <span class="cov0" title="0">utils.DisplayField(os.Stderr, "Size", fmt.Sprintf("%d bytes", matchingRecord.Size))
                        utils.DisplayFooter(os.Stderr)

                        if err := utils.PromptForConfirmation(os.Stderr, "Type 'yes' to confirm deletion", utils.ConfirmationYes, false); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching record
                <span class="cov0" title="0">err = drsClient.DeleteRecord(oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting file for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully deleted record for OID %s", oid))
                return nil</span>
        },
}

func init() <span class="cov10" title="46">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVar(&amp;confirmFlag, "confirm", false, "skip interactive confirmation prompt")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package deleteproject

import (
        "fmt"
        "os"

        indexdCl "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete-project &lt;project_id&gt;",
        Short:  "Delete all indexd records for a given project",
        Long:   "Delete all indexd records for a given project",
        Hidden: true,
        Args:   cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                projectId := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        return err
                }</span>

                // Cast to IndexDClient to access GetProjectSample
                <span class="cov0" title="0">indexdClient, ok := drsClient.(*indexdCl.IndexDClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("client is not an IndexDClient, cannot proceed with delete-project")
                }</span>

                // Get a sample record to show the user what will be deleted
                <span class="cov0" title="0">sampleRecords, err := indexdClient.GetProjectSample(projectId, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting sample records for project %s: %v", projectId, err)
                }</span>

                // Show details and get confirmation unless --confirm flag matches project_id
                <span class="cov0" title="0">if confirmFlag != "" &amp;&amp; confirmFlag != projectId </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: --confirm value '%s' does not match project ID '%s'", confirmFlag, projectId)
                }</span>
                <span class="cov0" title="0">if confirmFlag != projectId </span><span class="cov0" title="0">{
                        utils.DisplayWarningHeader(os.Stderr, "DELETE ALL RECORDS for a project")
                        utils.DisplayField(os.Stderr, "Remote", string(remoteName))
                        utils.DisplayField(os.Stderr, "Project ID", projectId)

                        if len(sampleRecords) &gt; 0 </span><span class="cov0" title="0">{
                                sample := sampleRecords[0]
                                fmt.Fprintf(os.Stderr, "\nSample record from this project:\n")
                                utils.DisplayField(os.Stderr, "  DID", sample.Id)
                                if sample.Name != "" </span><span class="cov0" title="0">{
                                        utils.DisplayField(os.Stderr, "  Filename", sample.Name)
                                }</span>
                                <span class="cov0" title="0">utils.DisplayField(os.Stderr, "  Size", fmt.Sprintf("%d bytes", sample.Size))
                                if sample.CreatedTime != "" </span><span class="cov0" title="0">{
                                        utils.DisplayField(os.Stderr, "  Created", sample.CreatedTime)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "\nNo records found for this project.\n")
                        }</span>

                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\nThis will DELETE ALL records in project '%s'.\n", projectId)
                        utils.DisplayFooter(os.Stderr)

                        if err := utils.PromptForConfirmation(os.Stderr, fmt.Sprintf("Type the project ID '%s' to confirm deletion", projectId), projectId, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching records
                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Deleting all records for project %s...", projectId))
                err = drsClient.DeleteRecordsByProject(projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting project %s: %v", projectId, err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully deleted all records for project %s", projectId))
                return nil</span>
        },
}

func init() <span class="cov10" title="46">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVar(&amp;confirmFlag, "confirm", "", "skip interactive confirmation by providing the project_id (e.g., --confirm my-project)")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package download

import (
        "fmt"

        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var (
        dstPath string
        remote  string
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "download &lt;oid&gt;",
        Short: "Download file using file object ID",
        Long:  "Download file using file object ID (sha256 hash). Use lfs ls-files to get oid",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (file object ID), received %d\n\nUsage: %s\n\nSee 'git drs download --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                oid := args[0]

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        return err
                }</span>

                // get signed url
                <span class="cov0" title="0">accessUrl, err := drsClient.GetDownloadURL(oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error downloading file for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">if accessUrl.URL == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Unable to get access URL %s", oid)
                }</span>

                // download url to destination path or LFS objects if not specified
                <span class="cov0" title="0">if dstPath == "" </span><span class="cov0" title="0">{
                        dstPath, err = drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, oid)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error getting destination path for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">err = cloud.DownloadSignedUrl(accessUrl.URL, dstPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error downloading file for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("\nerror downloading file object ID %s: %s", oid, err)
                }</span>

                <span class="cov0" title="0">logger.Debug("file downloaded")

                return nil</span>
        },
}

func init() <span class="cov10" title="46">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;dstPath, "dst", "d", "", "Destination path to save the downloaded file")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package fetch

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "fetch [remote-name]",
        Short: "fetch drs objects from remote",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs fetch --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov0" title="0"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PullRemoteDrsObjects(drsClient, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package initialize

import (
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var transfers int

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize repo for git-drs",
        Long: "Description:" +
                "\n  Initialize repo for git-drs",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov4" title="4">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs init --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov4" title="4">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov4" title="4">{
                logg := drslog.GetLogger()

                // check if .git dir exists to ensure you're in a git repository
                _, err := utils.GitTopLevel()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: not in a git repository. Please run this command in the root of your git repository")
                }</span>

                // create config file if it doesn't exist
                <span class="cov4" title="4">err = config.CreateEmptyConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: unable to create config file: %v", err)
                }</span>

                // load the config
                <span class="cov4" title="4">_, err = config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("We should probably fix this: %v", err))
                        return fmt.Errorf("error: unable to load config file: %v", err)
                }</span>

                // setup lfs custom transfer
                // TODO: may need to generalize for anvil
                <span class="cov4" title="4">err = initGitConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error initializing custom transfer for DRS: %v", err)
                }</span>

                // install pre-push hook
                <span class="cov4" title="4">err = installPrePushHook(logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error installing pre-push hook: %v", err)
                }</span>

                // final logs
                <span class="cov4" title="4">logg.Debug("Git DRS initialized")
                logg.Debug(fmt.Sprintf("Using %d concurrent transfers", transfers))
                return nil</span>
        },
}

func initGitConfig() error <span class="cov4" title="5">{
        configs := [][]string{
                {"lfs.standalonetransferagent", "drs"},
                {"lfs.customtransfer.drs.path", "git-drs"},
                {"lfs.customtransfer.drs.args", "transfer"},
                // TODO: different for anvil / read-only?
                {"lfs.allowincompletepush", "false"},
                {"lfs.customtransfer.drs.concurrent", strconv.FormatBool(transfers &gt; 1)},
                {"lfs.customtransfer.drs.concurrenttransfers", strconv.Itoa(transfers)},
        }

        for _, args := range configs </span><span class="cov8" title="30">{
                cmd := exec.Command("git", "config", args[0], args[1])
                if cmdOut, err := cmd.Output(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to set git config %s: %s", args[0], cmdOut)
                }</span>
        }

        <span class="cov4" title="5">return nil</span>
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().IntVarP(&amp;transfers, "transfers", "t", 4, "Number of concurrent transfers")
}</span>

func installPrePushHook(logger *slog.Logger) error <span class="cov5" title="6">{
        cmd := exec.Command("git", "rev-parse", "--git-dir")
        cmdOut, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to locate git directory: %w", err)
        }</span>
        <span class="cov5" title="6">gitDir := strings.TrimSpace(string(cmdOut))
        hooksDir := filepath.Join(gitDir, "hooks")
        if err := os.MkdirAll(hooksDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create hooks directory: %w", err)
        }</span>

        <span class="cov5" title="6">hookPath := filepath.Join(hooksDir, "pre-push")
        hookBody := `
# . git/hooks/pre-push
remote="$1"
url="$2"

# Buffer stdin for both commands
TMPFILE="${TMPDIR:-/tmp}/git-drs-$$"
trap "rm -f $TMPFILE" EXIT
cat &gt; "$TMPFILE"

# Run DRS preparation
git drs pre-push-prepare "$remote" "$url" &lt; "$TMPFILE" || exit 1

# Run LFS push
exec git lfs pre-push "$remote" "$url" &lt; "$TMPFILE"
`
        hookScript := "#!/bin/sh\n" + hookBody

        existingContent, err := os.ReadFile(hookPath)
        if err == nil </span><span class="cov3" title="3">{
                // there is an existing hook, rename it, and let the user know
                // Backup existing hook with timestamp
                timestamp := time.Now().Format("20060102T150405")
                backupPath := hookPath + "." + timestamp
                if err := os.WriteFile(backupPath, existingContent, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to back up existing pre-push hook: %w", err)
                }</span>
                <span class="cov3" title="3">if err := os.Remove(hookPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove hook after backing up: %w", err)
                }</span>
                <span class="cov3" title="3">logger.Debug(fmt.Sprintf("pre-push hook updated; backup written to %s", backupPath))</span>
        }
        // If there was an error other than expected not existing, return it
        <span class="cov5" title="6">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to read pre-push hook: %w", err)
        }</span>

        <span class="cov5" title="6">err = os.WriteFile(hookPath, []byte(hookScript), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write pre-push hook: %w", err)
        }</span>
        <span class="cov5" title="6">logger.Debug("pre-push hook installed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package list

import (
        "fmt"
        "io"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var (
        outJson     bool = false
        outFile     string
        listOutFile string
        remote      string
)

var checksumPref = []hash.ChecksumType{hash.ChecksumTypeSHA256, hash.ChecksumTypeMD5, hash.ChecksumTypeETag}

func getChecksumPos(q hash.ChecksumType, a []hash.ChecksumType) int <span class="cov4" title="4">{
        for i, s := range a </span><span class="cov5" title="7">{
                if q == s </span><span class="cov3" title="3">{
                        return i
                }</span>
        }
        <span class="cov1" title="1">return -1</span>
}

// Pick out the most preferred checksum to display
func getCheckSumStr(obj drs.DRSObject) string <span class="cov1" title="1">{
        curPos := len(checksumPref) + 1
        curVal := ""
        for checksumType, checksum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov2" title="2">{
                c := getChecksumPos(hash.ChecksumType(checksumType), checksumPref)
                if c != -1 &amp;&amp; c &lt; curPos </span><span class="cov1" title="1">{
                        curPos = c
                        curVal = checksumType + ":" + checksum
                }</span>
        }
        <span class="cov1" title="1">return curVal</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS entities from server",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                var outWriter io.Writer
                if listOutFile != "" </span><span class="cov0" title="0">{
                        f, err := os.Create(listOutFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        outWriter = f</span>
                } else<span class="cov0" title="0"> {
                        outWriter = os.Stdout
                }</span>

                <span class="cov0" title="0">conf, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := conf.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">client, err := conf.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Client failed")
                        return err
                }</span>
                <span class="cov0" title="0">objChan, err := client.ListObjects()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !outJson </span><span class="cov0" title="0">{
                        fmt.Fprintf(outWriter, "%-55s\t%-15s\t%-75s\t%s\n", "URI", "Size", "Checksum", "Name")
                }</span>

                // for each result, check for error and print
                <span class="cov0" title="0">for objResult := range objChan </span><span class="cov0" title="0">{
                        if objResult.Error != nil </span><span class="cov0" title="0">{
                                return objResult.Error
                        }</span>
                        <span class="cov0" title="0">obj := objResult.Object
                        if outJson </span><span class="cov0" title="0">{
                                out, err := sonic.ConfigFastest.Marshal(*obj)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">fmt.Fprintf(outWriter, "%s\n", string(out))</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(outWriter, "%s\t%-15d\t%-75s\t%s\n", obj.SelfURI, obj.Size, getCheckSumStr(*obj), obj.Name)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}
var ListProjectCmd = &amp;cobra.Command{
        Use:   "list-project &lt;project-id&gt;",
        Short: "List DRS entities from server",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (project ID), received %d\n\nUsage: %s\n\nSee 'git drs list-project --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                conf, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := conf.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">client, err := conf.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">objChan, err := client.ListObjectsByProject(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var f *os.File
                var outWriter io.Writer
                if outFile != "" </span><span class="cov0" title="0">{
                        f, err = os.Create(outFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        outWriter = f</span>
                } else<span class="cov0" title="0"> {
                        outWriter = os.Stdout
                }</span>
                <span class="cov0" title="0">for objResult := range objChan </span><span class="cov0" title="0">{
                        if objResult.Error != nil </span><span class="cov0" title="0">{
                                return objResult.Error
                        }</span>
                        <span class="cov0" title="0">obj := objResult.Object
                        out, err := sonic.ConfigFastest.Marshal(*obj)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = outWriter.Write(out)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = outWriter.Write([]byte("\n"))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        ListProjectCmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        ListProjectCmd.Flags().StringVarP(&amp;outFile, "out", "o", outFile, "File path to save output to")
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;listOutFile, "out", "o", listOutFile, "File path to save output to")
        Cmd.Flags().BoolVarP(&amp;outJson, "json", "j", outJson, "Output formatted as JSON")
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package listconfig

import (
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        jsonOutput bool
)

// Cmd represents the list-config command
var Cmd = &amp;cobra.Command{
        Use:   "list-config",
        Short: "Display the current configuration",
        Long:  "Pretty prints the current configuration file in YAML format",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list-config --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Load the current configuration
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                        // Output as JSON if requested
                        encoder := sonic.ConfigFastest.NewEncoder(os.Stdout)
                        encoder.SetIndent("", "  ")
                        return encoder.Encode(cfg)
                }</span> else<span class="cov0" title="0"> {
                        // Default YAML output with nice formatting
                        encoder := yaml.NewEncoder(os.Stdout)
                        encoder.SetIndent(2)
                        defer encoder.Close()

                        return encoder.Encode(cfg)
                }</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().BoolVarP(&amp;jsonOutput, "json", "j", false, "output in JSON format")
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package precommit
// -------------------------------------
// LFS-only local cache updater for:
//   - Path -&gt; OID  : .git/drs/pre-commit/v1/paths/&lt;encoded-path&gt;.json
//   - OID  -&gt; Paths + S3 URL hint : .git/drs/pre-commit/v1/oids/&lt;oid&gt;.json
//
// This hook is intentionally:
//   - LFS-only (non-LFS paths are ignored)
//   - local-only (no network, no server index reads)
//   - index-based (reads STAGED content via `git show :&lt;path&gt;`)
//
// Note: This is a reference implementation. Adjust logging/policy as desired.
package precommit

import (
        "bufio"
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

const (
        cacheVersionDir = "drs/pre-commit/v1"
        lfsSpecLine     = "version https://git-lfs.github.com/spec/v1"
)

type PathEntry struct {
        Path      string `json:"path"`
        LFSOID    string `json:"lfs_oid"`
        UpdatedAt string `json:"updated_at"`
}

type OIDEntry struct {
        LFSOID        string   `json:"lfs_oid"`
        Paths         []string `json:"paths"`
        S3URL         string   `json:"s3_url,omitempty"` // hint only; may be empty
        UpdatedAt     string   `json:"updated_at"`
        ContentChange bool     `json:"content_changed"`
}

type ChangeKind int

const (
        KindAdd ChangeKind = iota
        KindModify
        KindDelete
        KindRename
)

type Change struct {
        Kind    ChangeKind
        OldPath string // for rename
        NewPath string // for rename (and for add/modify/delete uses NewPath)
        Status  string // raw status, e.g. "A", "M", "D", "R100"
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        if err := run(ctx); err != nil </span><span class="cov0" title="0">{
                // For a reference impl, treat errors as non-fatal unless you want strict enforcement.
                // Exiting non-zero blocks the commit.
                fmt.Fprintf(os.Stderr, "pre-commit drs cache: %v\n", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context) error <span class="cov0" title="0">{
        gitDir, err := gitRevParseGitDir(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cacheRoot := filepath.Join(gitDir, cacheVersionDir)
        pathsDir := filepath.Join(cacheRoot, "paths")
        oidsDir := filepath.Join(cacheRoot, "oids")
        tombsDir := filepath.Join(cacheRoot, "tombstones")

        if err := os.MkdirAll(pathsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(oidsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_ = os.MkdirAll(tombsDir, 0o755) // optional

        changes, err := stagedChanges(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(changes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">now := time.Now().UTC().Format(time.RFC3339)

        // Process renames first so subsequent add/modify logic sees the "new" path.
        // This mirrors how we want cache paths to follow staged paths.
        for _, ch := range changes </span><span class="cov0" title="0">{
                if ch.Kind != KindRename </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Only act if BOTH old and new are LFS in scope? Prefer:
                // - If the new path is LFS, we migrate.
                // - If it isn't LFS, we remove old path entry (out of scope).
                <span class="cov0" title="0">newOID, newIsLFS, err := stagedLFSOID(ctx, ch.NewPath)
                if err != nil </span><span class="cov0" title="0">{
                        // If file doesn't exist in index due to weird staging, skip.
                        continue</span>
                }

                <span class="cov0" title="0">oldPathFile := pathEntryFile(pathsDir, ch.OldPath)
                newPathFile := pathEntryFile(pathsDir, ch.NewPath)

                if newIsLFS </span><span class="cov0" title="0">{
                        // Move/overwrite path entry file
                        if err := moveFileBestEffort(oldPathFile, newPathFile); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                return fmt.Errorf("rename migrate path entry: %w", err)
                        }</span>

                        // Ensure path entry content correct
                        <span class="cov0" title="0">if err := writeJSONAtomic(newPathFile, PathEntry{
                                Path:      ch.NewPath,
                                LFSOID:    newOID,
                                UpdatedAt: now,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Update oid entry: replace old path with new path for that OID
                        <span class="cov0" title="0">if err := oidAddOrReplacePath(oidsDir, newOID, ch.OldPath, ch.NewPath, now, false); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Out of scope now: remove any cached path entry.
                        _ = os.Remove(oldPathFile)
                }</span>
        }

        // Process adds/modifies/deletes (and renames again just to ensure content correctness on new path).
        <span class="cov0" title="0">for _, ch := range changes </span><span class="cov0" title="0">{
                switch ch.Kind </span>{
                case KindAdd, KindModify:<span class="cov0" title="0">
                        if err := handleUpsert(ctx, pathsDir, oidsDir, ch.NewPath, now); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case KindRename:<span class="cov0" title="0">
                        // Treat like upsert on NewPath to ensure OID/path consistency if content also changed.
                        if err := handleUpsert(ctx, pathsDir, oidsDir, ch.NewPath, now); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Optionally also remove old path from *other* OID entry if rename+content-change changed OID.
                        // We'll do it inside handleUpsert by checking previous cached OID for that path (after move).
                case KindDelete:<span class="cov0" title="0">
                        if err := handleDelete(ctx, pathsDir, oidsDir, tombsDir, ch.NewPath, now); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func handleUpsert(ctx context.Context, pathsDir, oidsDir, path, now string) error <span class="cov0" title="0">{
        oid, isLFS, err := stagedLFSOID(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                // If file isn't in index, ignore.
                return nil
        }</span>
        <span class="cov0" title="0">if !isLFS </span><span class="cov0" title="0">{
                // Out of scope.
                return nil
        }</span>

        <span class="cov0" title="0">pathFile := pathEntryFile(pathsDir, path)

        // Load previous path entry if it exists to detect content changes.
        var prev PathEntry
        prevExists := false
        if b, err := os.ReadFile(pathFile); err == nil </span><span class="cov0" title="0">{
                _ = json.Unmarshal(b, &amp;prev)
                if prev.Path != "" &amp;&amp; prev.LFSOID != "" </span><span class="cov0" title="0">{
                        prevExists = true
                }</span>
        }

        // Write/update path entry.
        <span class="cov0" title="0">if err := writeJSONAtomic(pathFile, PathEntry{
                Path:      path,
                LFSOID:    oid,
                UpdatedAt: now,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update OID entry for new oid: add path.
        <span class="cov0" title="0">contentChanged := prevExists &amp;&amp; prev.LFSOID != oid
        if err := oidAddOrReplacePath(oidsDir, oid, "", path, now, contentChanged); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If content changed, remove path from the *old* oid entry (best effort).
        <span class="cov0" title="0">if contentChanged </span><span class="cov0" title="0">{
                _ = oidRemovePath(oidsDir, prev.LFSOID, path, now)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func handleDelete(ctx context.Context, pathsDir, oidsDir, tombsDir, path, now string) error <span class="cov0" title="0">{
        // Only consider deletion if it was previously an LFS entry (cache-driven).
        pathFile := pathEntryFile(pathsDir, path)
        b, err := os.ReadFile(pathFile)
        if err != nil </span><span class="cov0" title="0">{
                // nothing to do
                return nil
        }</span>
        <span class="cov0" title="0">var pe PathEntry
        if err := json.Unmarshal(b, &amp;pe); err != nil </span><span class="cov0" title="0">{
                // corrupted cache; remove it
                _ = os.Remove(pathFile)
                return nil
        }</span>
        // Remove path entry.
        <span class="cov0" title="0">_ = os.Remove(pathFile)

        // Remove this path from the old oid entry (best effort).
        if pe.LFSOID != "" </span><span class="cov0" title="0">{
                _ = oidRemovePath(oidsDir, pe.LFSOID, path, now)
        }</span>

        // Optional tombstone.
        <span class="cov0" title="0">tombFile := filepath.Join(tombsDir, encodePath(path)+".json")
        _ = writeJSONAtomic(tombFile, map[string]string{
                "path":       path,
                "deleted_at": now,
        })

        return nil</span>
}

// stagedChanges parses: git diff --cached --name-status -M
// Formats:
//
//        A&lt;TAB&gt;path
//        M&lt;TAB&gt;path
//        D&lt;TAB&gt;path
//        R100&lt;TAB&gt;old&lt;TAB&gt;new
func stagedChanges(ctx context.Context) ([]Change, error) <span class="cov0" title="0">{
        out, err := git(ctx, "diff", "--cached", "--name-status", "-M")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var changes []Change
        sc := bufio.NewScanner(bytes.NewReader(out))
        for sc.Scan() </span><span class="cov0" title="0">{
                line := sc.Text()
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">parts := strings.Split(line, "\t")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">status := parts[0]
                switch </span>{
                case status == "A":<span class="cov0" title="0">
                        changes = append(changes, Change{Kind: KindAdd, NewPath: parts[1], Status: status})</span>
                case status == "M":<span class="cov0" title="0">
                        changes = append(changes, Change{Kind: KindModify, NewPath: parts[1], Status: status})</span>
                case status == "D":<span class="cov0" title="0">
                        changes = append(changes, Change{Kind: KindDelete, NewPath: parts[1], Status: status})</span>
                case strings.HasPrefix(status, "R") &amp;&amp; len(parts) &gt;= 3:<span class="cov0" title="0">
                        changes = append(changes, Change{Kind: KindRename, OldPath: parts[1], NewPath: parts[2], Status: status})</span>
                default:<span class="cov0" title="0"></span>
                        // ignore other statuses (C, T, U, etc) for this reference impl
                }
        }
        <span class="cov0" title="0">if err := sc.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return changes, nil</span>
}

// stagedLFSOID returns (oid, isLFS, err) based on STAGED content.
// isLFS is true only if the staged file is a valid LFS pointer with an oid sha256 line.
func stagedLFSOID(ctx context.Context, path string) (string, bool, error) <span class="cov0" title="0">{
        out, err := git(ctx, "show", ":"+path)
        if err != nil </span><span class="cov0" title="0">{
                // path may not exist in index (deleted/intent-to-add weirdness)
                return "", false, err
        }</span>

        // Fast parse: look for spec line and oid line near top.
        // LFS pointer files are small; scanning full content is fine.
        <span class="cov0" title="0">var hasSpec bool
        var oid string

        sc := bufio.NewScanner(bytes.NewReader(out))
        for sc.Scan() </span><span class="cov0" title="0">{
                line := sc.Text()
                if line == lfsSpecLine </span><span class="cov0" title="0">{
                        hasSpec = true
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(line, "oid sha256:") </span><span class="cov0" title="0">{
                        hex := strings.TrimPrefix(line, "oid sha256:")
                        hex = strings.TrimSpace(hex)
                        if hex != "" </span><span class="cov0" title="0">{
                                oid = "sha256:" + hex
                        }</span>
                        // keep scanning a bit in case spec is below (rare), but we can break once both are found.
                }
                // pointer usually has only a few lines; stop early after 10 lines
                <span class="cov0" title="0">if hasSpec &amp;&amp; oid != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">if err := sc.Err(); err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">if hasSpec &amp;&amp; oid != "" </span><span class="cov0" title="0">{
                return oid, true, nil
        }</span>
        <span class="cov0" title="0">return "", false, nil</span>
}

func gitRevParseGitDir(ctx context.Context) (string, error) <span class="cov0" title="0">{
        out, err := git(ctx, "rev-parse", "--git-dir")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">gitDir := strings.TrimSpace(string(out))
        if gitDir == "" </span><span class="cov0" title="0">{
                return "", errors.New("could not determine .git dir")
        }</span>
        // If gitDir is relative, resolve relative to repo root
        <span class="cov0" title="0">if !filepath.IsAbs(gitDir) </span><span class="cov0" title="0">{
                rootOut, err := git(ctx, "rev-parse", "--show-toplevel")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">root := strings.TrimSpace(string(rootOut))
                gitDir = filepath.Join(root, gitDir)</span>
        }
        <span class="cov0" title="0">return gitDir, nil</span>
}

func git(ctx context.Context, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Env = os.Environ()
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // include stderr for debugging; dont leak massive output
                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("git %s: %s", strings.Join(args, " "), msg)</span>
        }
        <span class="cov0" title="0">return stdout.Bytes(), nil</span>
}

// pathEntryFile maps a repo-relative path to a cache file location.
// We keep a deterministic encoding so any path maps to exactly one file.
func pathEntryFile(pathsDir, path string) string <span class="cov0" title="0">{
        return filepath.Join(pathsDir, encodePath(path)+".json")
}</span>

func encodePath(path string) string <span class="cov0" title="0">{
        // base64url encoding of the UTF-8 path string (no padding) is simple and safe.
        return base64.RawURLEncoding.EncodeToString([]byte(path))
}</span>

func oidEntryFile(oidsDir, oid string) string <span class="cov0" title="0">{
        // OID contains ":"; make it filesystem safe but still human readable.
        // Use a stable transform; here: sha256 of oid string to avoid path length issues.
        sum := sha256.Sum256([]byte(oid))
        return filepath.Join(oidsDir, fmt.Sprintf("%x.json", sum[:]))
}</span>

// oidAddOrReplacePath:
// - loads oid entry (if exists)
// - adds newPath to paths[]
// - if oldPath != "" and present, replaces it with newPath
// - sets ContentChange flag if requested (ORed into existing flag)
// - preserves existing s3_url hint
func oidAddOrReplacePath(oidsDir, oid, oldPath, newPath, now string, contentChanged bool) error <span class="cov0" title="0">{
        f := oidEntryFile(oidsDir, oid)

        entry := OIDEntry{
                LFSOID:    oid,
                Paths:     []string{},
                UpdatedAt: now,
        }
        if b, err := os.ReadFile(f); err == nil </span><span class="cov0" title="0">{
                _ = json.Unmarshal(b, &amp;entry)
                // ensure oid is set even if old file was incomplete
                entry.LFSOID = oid
        }</span>

        <span class="cov0" title="0">paths := make(map[string]struct{}, len(entry.Paths)+1)
        for _, p := range entry.Paths </span><span class="cov0" title="0">{
                paths[p] = struct{}{}
        }</span>

        <span class="cov0" title="0">if oldPath != "" </span><span class="cov0" title="0">{
                delete(paths, oldPath)
        }</span>
        <span class="cov0" title="0">if newPath != "" </span><span class="cov0" title="0">{
                paths[newPath] = struct{}{}
        }</span>

        <span class="cov0" title="0">entry.Paths = keysSorted(paths)
        entry.UpdatedAt = now
        entry.ContentChange = entry.ContentChange || contentChanged

        return writeJSONAtomic(f, entry)</span>
}

func oidRemovePath(oidsDir, oid, path, now string) error <span class="cov0" title="0">{
        f := oidEntryFile(oidsDir, oid)

        b, err := os.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var entry OIDEntry
        if err := json.Unmarshal(b, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">paths := make(map[string]struct{}, len(entry.Paths))
        for _, p := range entry.Paths </span><span class="cov0" title="0">{
                if p == path </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">paths[p] = struct{}{}</span>
        }
        <span class="cov0" title="0">entry.Paths = keysSorted(paths)
        entry.UpdatedAt = now

        // If no paths remain, keep the file (it may still hold s3_url hint) or delete it.
        // This ADR allows stale entries; keeping is fine. Optionally delete when empty:
        // if len(entry.Paths) == 0 &amp;&amp; entry.S3URL == "" { return os.Remove(f) }

        return writeJSONAtomic(f, entry)</span>
}

func keysSorted(m map[string]struct{}) []string <span class="cov0" title="0">{
        out := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                out = append(out, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(out)
        return out</span>
}

// writeJSONAtomic writes JSON to a temp file then renames it into place.
// This avoids partially written cache files if the process is interrupted.
func writeJSONAtomic(path string, v any) error <span class="cov0" title="0">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tmp := path + ".tmp"
        f, err := os.OpenFile(tmp, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

        <span class="cov0" title="0">enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        if err := enc.Encode(v); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmp)
                return err
        }</span>
        <span class="cov0" title="0">if err := f.Sync(); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmp)
                return err
        }</span>
        <span class="cov0" title="0">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmp)
                return err
        }</span>
        <span class="cov0" title="0">return os.Rename(tmp, path)</span>
}

func moveFileBestEffort(src, dst string) error <span class="cov0" title="0">{
        // Ensure destination directory exists.
        if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Rename will fail across devices; fall back to copy+remove.
        <span class="cov0" title="0">if err := os.Rename(src, dst); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">in, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer in.Close()

        out, err := os.OpenFile(dst, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := io.Copy(out, in); err != nil </span><span class="cov0" title="0">{
                _ = out.Close()
                return err
        }</span>
        <span class="cov0" title="0">if err := out.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.Remove(src)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package prepush

import (
        "bufio"
        "fmt"
        "io"
        "log/slog"
        "os"
        "sort"
        "strings"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "pre-push-prepare",
        Short: "pre-push hook to update DRS objects",
        Long:  "Pre-push hook that updates DRS objects before transfer",
        Args:  cobra.RangeArgs(0, 2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                return NewPrePushService().Run(args, os.Stdin)
        }</span>,
}

type PrePushService struct {
        newLogger        func(string, bool) (*slog.Logger, error)
        loadConfig       func() (*config.Config, error)
        updateDrsObjects func(drs.ObjectBuilder, string, string, []string, *slog.Logger) error
        createTempFile   func(dir, pattern string) (*os.File, error)
}

func NewPrePushService() *PrePushService <span class="cov10" title="4">{
        return &amp;PrePushService{
                newLogger:        drslog.NewLogger,
                loadConfig:       config.LoadConfig,
                updateDrsObjects: drsmap.UpdateDrsObjects,
                createTempFile:   os.CreateTemp,
        }
}</span>

func (s *PrePushService) Run(args []string, stdin io.Reader) error <span class="cov10" title="4">{
        myLogger, err := s.newLogger("", false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating logger: %v", err)
        }</span>

        <span class="cov10" title="4">myLogger.Info("~~~~~~~~~~~~~ START: pre-push ~~~~~~~~~~~~~")

        cfg, err := s.loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting config: %v", err)
        }</span>

        <span class="cov10" title="4">gitRemoteName, gitRemoteLocation := parseRemoteArgs(args)
        myLogger.Debug(fmt.Sprintf("git remote name: %s, git remote location: %s", gitRemoteName, gitRemoteLocation))

        remote, err := cfg.GetDefaultRemote()
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Debug(fmt.Sprintf("Warning. Error getting default remote: %v", err))
                fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting default remote:", err)
                return nil
        }</span>

        <span class="cov10" title="4">remoteConfig := cfg.GetRemote(remote)
        if remoteConfig == nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting remote configuration.")
                myLogger.Debug("Warning. Skipping DRS preparation. Error getting remote configuration.")
                return nil
        }</span>

        <span class="cov10" title="4">builder := drs.NewObjectBuilder(remoteConfig.GetBucketName(), remoteConfig.GetProjectId())
        myLogger.Debug(fmt.Sprintf("Current server project: %s", builder.ProjectID))

        tmp, err := bufferStdin(stdin, s.createTempFile)
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("error buffering stdin: %v", err))
                return err
        }</span>
        <span class="cov10" title="4">defer func() </span><span class="cov10" title="4">{
                _ = tmp.Close()
                _ = os.Remove(tmp.Name())
        }</span>()

        <span class="cov10" title="4">branches, err := readPushedBranches(tmp)
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("error reading pushed branches: %v", err))
                return err
        }</span>

        <span class="cov10" title="4">myLogger.Debug(fmt.Sprintf("Preparing DRS objects for push branches: %v", branches))
        err = s.updateDrsObjects(builder, gitRemoteName, gitRemoteLocation, branches, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("UpdateDrsObjects failed: %v", err))
                return err
        }</span>
        <span class="cov10" title="4">myLogger.Info("~~~~~~~~~~~~~ COMPLETED: pre-push ~~~~~~~~~~~~~")
        return nil</span>
}

func parseRemoteArgs(args []string) (string, string) <span class="cov10" title="4">{
        var gitRemoteName, gitRemoteLocation string
        if len(args) &gt;= 1 </span><span class="cov10" title="4">{
                gitRemoteName = args[0]
        }</span>
        <span class="cov10" title="4">if len(args) &gt;= 2 </span><span class="cov10" title="4">{
                gitRemoteLocation = args[1]
        }</span>
        <span class="cov10" title="4">if gitRemoteName == "" </span><span class="cov0" title="0">{
                gitRemoteName = "origin"
        }</span>
        <span class="cov10" title="4">return gitRemoteName, gitRemoteLocation</span>
}

func bufferStdin(stdin io.Reader, createTempFile func(dir, pattern string) (*os.File, error)) (*os.File, error) <span class="cov10" title="4">{
        tmp, err := createTempFile("", "prepush-stdin-*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating temp file for stdin: %w", err)
        }</span>

        <span class="cov10" title="4">if _, err := io.Copy(tmp, stdin); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error buffering stdin: %w", err)
        }</span>

        <span class="cov10" title="4">if _, err := tmp.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error seeking temp stdin: %w", err)
        }</span>
        <span class="cov10" title="4">return tmp, nil</span>
}

// readPushedBranches reads git push lines from the provided temp file,
// extracts unique local branch names for refs under `refs/heads/` and
// returns them sorted. The file is rewound to the start before returning.
func readPushedBranches(f io.ReadSeeker) ([]string, error) <span class="cov10" title="4">{
        // Ensure we read from start
        // example:
        // refs/heads/main 67890abcdef1234567890abcdef1234567890abcd refs/heads/main 12345abcdef67890abcdef1234567890abcdef12
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">scanner := bufio.NewScanner(f)
        set := make(map[string]struct{})
        for scanner.Scan() </span><span class="cov10" title="4">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="4">localRef := fields[0]
                const prefix = "refs/heads/"
                if strings.HasPrefix(localRef, prefix) </span><span class="cov10" title="4">{
                        branch := strings.TrimPrefix(localRef, prefix)
                        if branch != "" </span><span class="cov10" title="4">{
                                set[branch] = struct{}{}
                        }</span>
                }
        }
        <span class="cov10" title="4">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">branches := make([]string, 0, len(set))
        for b := range set </span><span class="cov10" title="4">{
                branches = append(branches, b)
        }</span>
        <span class="cov10" title="4">sort.Strings(branches)
        // Rewind so caller can reuse the file
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">return branches, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package push

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "push [remote-name]",
        Short: "push local objects to drs server.",
        Long:  "push local objects to drs server. Any local files that do not have drs records are written to a bucket.",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs push --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                myLogger := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error loading config: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov0" title="0"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Debug(fmt.Sprintf("Error getting default remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error creating indexd client: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PushLocalDrsObjects(drsClient, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package query

import (
        "fmt"

        "github.com/bytedance/sonic"
        conf "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

// printDRSObject marshals and prints a DRS object based on the pretty flag
func printDRSObject(obj drs.DRSObject, pretty bool) error <span class="cov0" title="0">{
        var out []byte
        var err error

        if pretty </span><span class="cov0" title="0">{
                out, err = sonic.ConfigFastest.MarshalIndent(obj, "", "  ")
        }</span> else<span class="cov0" title="0"> {
                out, err = sonic.ConfigFastest.Marshal(obj)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s\n", string(out))
        return nil</span>
}

var remote string
var checksum = false
var pretty = false

type checksumClient interface {
        GetObjectByHash(hash *hash.Checksum) ([]drs.DRSObject, error)
}

func queryByChecksum(client checksumClient, checksum string) ([]drs.DRSObject, error) <span class="cov1" title="1">{
        // Auto-detect checksum type based on hash length
        checksumType := hash.ChecksumTypeSHA256
        switch len(checksum) </span>{
        case 32:<span class="cov0" title="0">
                // 128-bit / 32-hex-character checksum (e.g., MD5)
                checksumType = hash.ChecksumTypeMD5</span>
        case 40:<span class="cov0" title="0">
                // 160-bit / 40-hex-character checksum (e.g., SHA1)
                checksumType = hash.ChecksumTypeSHA1</span>
        case 64:<span class="cov0" title="0">
                // 256-bit / 64-hex-character checksum (e.g., SHA256)
                checksumType = hash.ChecksumTypeSHA256</span>
        case 128:<span class="cov0" title="0">
                // 512-bit / 128-hex-character checksum (e.g., SHA512)
                checksumType = hash.ChecksumTypeSHA512</span>
        }

        <span class="cov1" title="1">return client.GetObjectByHash(&amp;hash.Checksum{
                Checksum: checksum,
                Type:     checksumType,
        })</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "query &lt;drs_id&gt;",
        Short: "Query DRS server by DRS ID",
        Long:  "Query DRS server by DRS ID",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (DRS ID), received %d\n\nUsage: %s\n\nSee 'git drs query --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                config, err := conf.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := config.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">client, err := config.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var obj *drs.DRSObject

                if checksum </span><span class="cov0" title="0">{
                        objs, err := queryByChecksum(client, args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, drsObj := range objs </span><span class="cov0" title="0">{
                                if err := printDRSObject(drsObj, pretty); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        obj, err = client.GetObject(args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := printDRSObject(*obj, pretty); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVarP(&amp;checksum, "checksum", "c", checksum, "Find by checksum")
        Cmd.Flags().BoolVarP(&amp;pretty, "pretty", "p", pretty, "Print indented JSON")
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package register

import (
        "fmt"

        indexdCl "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "register",
        Short: "Register all pending DRS objects with indexd",
        Long:  "Reads pending objects from .git/drs/lfs/objects/ and registers them with indexd (does not upload files)",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs register --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger, err := drslog.NewLogger("", true)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating indexd client: %v", err)
                }</span>
                <span class="cov0" title="0">icli, ok := cli.(*indexdCl.IndexDClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("remote client is not an *indexdCl.IndexDClient (got %T)", cli)
                }</span>

                // Get all pending objects
                <span class="cov0" title="0">pendingObjects, err := drs.GetPendingObjects(logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error reading pending objects: %v", err)
                }</span>

                <span class="cov0" title="0">if len(pendingObjects) == 0 </span><span class="cov0" title="0">{
                        logger.Debug("No pending objects to register")
                        return nil
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Found %d pending object(s) to register", len(pendingObjects)))

                registeredCount := 0
                skippedCount := 0
                errorCount := 0

                // Register each pending object with indexd
                for _, obj := range pendingObjects </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("Processing %s (OID: %s)", obj.Path, obj.OID))

                        // Read the IndexdRecord from disk
                        indexdObj, err := drsmap.DrsInfoFromOid(obj.OID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error reading DRS object for %s: %v", obj.Path, err))
                                errorCount++
                                continue</span>
                        }

                        // Check if records with this hash already exist in indexd
                        <span class="cov0" title="0">records, err := cli.GetObjectByHash(&amp;hash.Checksum{Type: "sha256", Checksum: obj.OID})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error querying indexd for %s: %v", obj.Path, err))
                                errorCount++
                                continue</span>
                        }

                        // Check if a record with this exact DID already exists
                        <span class="cov0" title="0">alreadyExists := false
                        for _, record := range records </span><span class="cov0" title="0">{
                                if record.Id == indexdObj.Id </span><span class="cov0" title="0">{
                                        alreadyExists = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if alreadyExists </span><span class="cov0" title="0">{
                                logger.Debug(fmt.Sprintf("Record for %s (DID: %s) already exists in indexd, skipping", obj.Path, indexdObj.Id))
                                skippedCount++
                                continue</span>
                        }

                        // Register the indexd record
                        <span class="cov0" title="0">_, err = icli.RegisterRecord(indexdObj)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error registering %s with indexd: %v", obj.Path, err))
                                errorCount++
                                continue</span>
                        }

                        <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully registered %s with DID %s", obj.Path, indexdObj.Id))
                        registeredCount++</span>
                }

                // Summary
                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Registration complete: %d registered, %d skipped, %d errors",
                        registeredCount, skippedCount, errorCount))

                if errorCount &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("completed with %d error(s)", errorCount)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="46">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package add

import (
        "fmt"
        "log/slog"

        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
)

var AnvilCmd = &amp;cobra.Command{
        Use: "anvil [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add anvil --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return fmt.Errorf("error: anvil remote is not yet implemented. Use 'git drs remote add gen3' instead. See 'git drs remote add gen3 --help' for more details")
        }</span>,
}

func anvilInit(terraProject string, logger *slog.Logger) error <span class="cov0" title="0">{
        // make sure terra project is provided
        if terraProject != "" </span><span class="cov0" title="0">{
                // populate anvil config
                remoteAnvil := config.RemoteSelect{
                        Anvil: &amp;anvil_client.AnvilRemote{
                                Endpoint: anvil_client.ANVIL_ENDPOINT,
                                Auth: anvil_client.AnvilAuth{
                                        TerraProject: terraProject,
                                },
                        },
                }
                // TODO: different than ORIGIN?
                remoteName := config.Remote(config.AnvilServerType)
                _, err := config.UpdateRemote(remoteName, remoteAnvil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error: unable to update config file: %v\n", err)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package add

import (
        "fmt"
        "log/slog"

        "github.com/calypr/data-client/client/conf"
        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var Gen3Cmd = &amp;cobra.Command{
        Use: "gen3 [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add gen3 --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                logg := drslog.GetLogger()

                // make sure at least one of the credentials params is provided
                if credFile == "" &amp;&amp; fenceToken == "" &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a credentials file or accessToken to setup project locally. Please provide either a --cred or --token flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                // When adding a new remote, bucket field is required.
                <span class="cov10" title="4">if bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a bucket name to be specified when adding a new remote. Please specify a bucket with --bucket flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                <span class="cov10" title="4">remoteName := config.ORIGIN
                if len(args) &gt; 0 </span><span class="cov10" title="4">{
                        remoteName = args[0]
                }</span>

                <span class="cov10" title="4">err := gen3Init(remoteName, credFile, fenceToken, project, bucket, logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error configuring gen3 server: %v", err)
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
}

func gen3Init(remoteName, credFile, fenceToken, project, bucket string, logg *slog.Logger) error <span class="cov10" title="4">{
        if remoteName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote name is required")
        }</span>
        <span class="cov10" title="4">if project == "" || bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project and bucket are required for Gen3 remote")
        }</span>

        <span class="cov10" title="4">var accessToken, apiKey, keyID, apiEndpoint string
        configure := conf.NewConfigure(drslog.AsStdLogger(logg))
        switch </span>{
        case fenceToken != "":<span class="cov0" title="0">
                accessToken = fenceToken
                var err error
                apiEndpoint, err = utils.ParseAPIEndpointFromToken(accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from provided access token: %w", err)
                }</span>

        case credFile != "":<span class="cov10" title="4">
                cred, err := configure.Import(credFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read credentials file %s: %w", credFile, err)
                }</span>
                <span class="cov10" title="4">accessToken = cred.AccessToken
                apiKey = cred.APIKey
                keyID = cred.KeyID

                apiEndpoint, err = utils.ParseAPIEndpointFromToken(cred.APIKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from API key in credentials file: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                existing, err := configure.Load(remoteName)
                if err == nil </span><span class="cov0" title="0">{
                        accessToken = existing.AccessToken
                        apiKey = existing.APIKey
                        keyID = existing.KeyID
                        apiEndpoint = existing.APIEndpoint
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("must provide either --cred or --token (or have existing profile %s)", remoteName)
                }</span>
        }

        <span class="cov10" title="4">if apiEndpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not determine Gen3 API endpoint")
        }</span>

        <span class="cov10" title="4">remoteGen3 := config.RemoteSelect{
                Gen3: &amp;indexd_client.Gen3Remote{
                        Endpoint:  apiEndpoint,
                        ProjectID: project,
                        Bucket:    bucket,
                },
        }

        remote := config.Remote(remoteName)
        if _, err := config.UpdateRemote(remote, remoteGen3); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update remote config: %w", err)
        }</span>
        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Remote added/updated: %s  %s (project: %s, bucket: %s)", remoteName, apiEndpoint, project, bucket))

        // Step 3: Ensure credential profile is up-to-date (refreshes token if needed)
        cred := &amp;conf.Credential{
                Profile:            remoteName,
                APIEndpoint:        apiEndpoint,
                APIKey:             apiKey,
                KeyID:              keyID,
                AccessToken:        accessToken, // may be stale
                UseShepherd:        "false",     // or preserve from existing?
                MinShepherdVersion: "",
        }

        if err := configure.Save(cred); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure/update Gen3 profile: %w", err)
        }</span>

        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Gen3 profile '%s' configured and token refreshed successfully", remoteName))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package add

import "github.com/spf13/cobra"

var (
        server       string
        apiEndpoint  string
        bucket       string
        credFile     string
        fenceToken   string
        project      string
        terraProject string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "add",
        Short: "add server access for git-drs",
}

func init() <span class="cov10" title="46">{
        Gen3Cmd.Flags().StringVar(&amp;server, "server", "gen3", "Options for DRS server: gen3 or anvil")
        Gen3Cmd.Flags().StringVar(&amp;apiEndpoint, "url", "", "[gen3] Specify the API endpoint of the data commons")
        Gen3Cmd.Flags().StringVar(&amp;bucket, "bucket", "", "[gen3] Specify the bucket name")
        Gen3Cmd.Flags().StringVar(&amp;credFile, "cred", "", "[gen3] Specify the gen3 credential file that you want to use")
        Gen3Cmd.Flags().StringVar(&amp;fenceToken, "token", "", "[gen3] Specify the token to be used as a replacement for a credential file for temporary access")
        Gen3Cmd.Flags().StringVar(&amp;project, "project", "", "[gen3] Specify the gen3 project ID in the format &lt;program&gt;-&lt;project&gt;")
        AnvilCmd.Flags().StringVar(&amp;terraProject, "terraProject", "", "[AnVIL] Specify the Terra project ID")

        Cmd.AddCommand(Gen3Cmd)
        Cmd.AddCommand(AnvilCmd)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS repos",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs remote list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logg := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("Error loading config: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">for name, remoteSelect := range cfg.Remotes </span><span class="cov0" title="0">{
                        // Determine if this is the default
                        isDefault := name == cfg.DefaultRemote
                        marker := " "
                        if isDefault </span><span class="cov0" title="0">{
                                marker = "*"
                        }</span>

                        // Determine remote type and endpoint
                        <span class="cov0" title="0">var remoteType string
                        var remote config.DRSRemote
                        if remoteSelect.Gen3 != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.Gen3ServerType)
                                remote = remoteSelect.Gen3
                        }</span> else<span class="cov0" title="0"> if remoteSelect.Anvil != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.AnvilServerType)
                                remote = remoteSelect.Anvil
                        }</span> else<span class="cov0" title="0"> {
                                remoteType = "unknown"
                        }</span>

                        <span class="cov0" title="0">endpoint := "N/A"
                        if remote != nil </span><span class="cov0" title="0">{
                                endpoint = remote.GetEndpoint()
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("%s %-10s %-8s %s\n", marker, name, remoteType, endpoint)</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package remote

import (
        "github.com/calypr/git-drs/cmd/remote/add"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "remote",
        Short: "Manage remote DRS server configs",
}

func init() <span class="cov10" title="46">{
        Cmd.AddCommand(add.Cmd)
        Cmd.AddCommand(ListCmd)
        Cmd.AddCommand(SetCmd)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var SetCmd = &amp;cobra.Command{
        Use:   "set &lt;remote-name&gt;",
        Short: "Set the default DRS remote",
        Long:  "Set which DRS remote to use by default for all operations",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (remote name), received %d\n\nUsage: %s\n\nRun 'git drs remote list' to see available remotes or 'git drs remote set --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                remoteName := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                // validate remote exists
                <span class="cov0" title="0">remote := config.Remote(remoteName)
                if _, ok := cfg.Remotes[remote]; !ok </span><span class="cov0" title="0">{
                        availableRemotes := make([]string, 0, len(cfg.Remotes))
                        for name := range cfg.Remotes </span><span class="cov0" title="0">{
                                availableRemotes = append(availableRemotes, string(name))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf(
                                "remote '%s' not found.\nAvailable remotes: %v",
                                remoteName,
                                availableRemotes,
                        )</span>
                }

                // save new default
                <span class="cov0" title="0">cfg.DefaultRemote = remote

                if err := config.SaveConfig(cfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save config: %w", err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Default remote set to: %s", remoteName))
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package cmd

import (
        "github.com/calypr/git-drs/cmd/addref"
        "github.com/calypr/git-drs/cmd/addurl"
        "github.com/calypr/git-drs/cmd/cache"
        "github.com/calypr/git-drs/cmd/delete"
        "github.com/calypr/git-drs/cmd/deleteproject"
        "github.com/calypr/git-drs/cmd/download"
        "github.com/calypr/git-drs/cmd/fetch"
        "github.com/calypr/git-drs/cmd/initialize"
        "github.com/calypr/git-drs/cmd/list"
        "github.com/calypr/git-drs/cmd/listconfig"
        "github.com/calypr/git-drs/cmd/prepush"
        "github.com/calypr/git-drs/cmd/push"
        "github.com/calypr/git-drs/cmd/query"
        "github.com/calypr/git-drs/cmd/register"
        "github.com/calypr/git-drs/cmd/remote"
        "github.com/calypr/git-drs/cmd/transfer"
        "github.com/calypr/git-drs/cmd/transferref"
        "github.com/calypr/git-drs/cmd/version"
        "github.com/spf13/cobra"
)

// RootCmd represents the root command
var RootCmd = &amp;cobra.Command{
        Use:   "git-drs",
        Short: "Git DRS - Git-LFS file management for DRS servers",
        Long:  "Git DRS provides the benefits of Git-LFS file management using DRS for seamless integration with Gen3 servers",
        PersistentPreRun: func(cmd *cobra.Command, args []string) {<span class="cov10" title="46">
                //pre-run code can go here
        }</span>,
}

func init() <span class="cov10" title="46">{
        RootCmd.AddCommand(addref.Cmd)
        RootCmd.AddCommand(cache.Cmd)
        RootCmd.AddCommand(delete.Cmd)
        RootCmd.AddCommand(deleteproject.Cmd)
        RootCmd.AddCommand(register.Cmd)
        RootCmd.AddCommand(download.Cmd)
        RootCmd.AddCommand(initialize.Cmd)
        RootCmd.AddCommand(list.Cmd)
        RootCmd.AddCommand(list.ListProjectCmd)
        RootCmd.AddCommand(listconfig.Cmd)
        RootCmd.AddCommand(prepush.Cmd)
        RootCmd.AddCommand(query.Cmd)
        RootCmd.AddCommand(transfer.Cmd)
        RootCmd.AddCommand(transferref.Cmd)
        RootCmd.AddCommand(version.Cmd)
        RootCmd.AddCommand(addurl.Cmd)
        RootCmd.AddCommand(remote.Cmd)
        RootCmd.AddCommand(fetch.Cmd)
        RootCmd.AddCommand(push.Cmd)

        RootCmd.CompletionOptions.HiddenDefaultCmd = true
        RootCmd.SilenceUsage = true
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package transfer

import (
        "bufio"
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/data-client/client/common"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

// TransferJob carries the raw JSON data and shared client
type TransferJob struct {
        data      []byte
        drsClient client.DRSClient
}

// TransferResult sent back to the single writer
type TransferResult struct {
        data    any
        isError bool
}

var (
        // Set once after init  determines which path all workers take
        transferOperation string    // "upload" or "download"
        sConfig           sonic.API = sonic.ConfigFastest
)

const (
        OPERATION_UPLOAD   = "upload"
        OPERATION_DOWNLOAD = "download"
)

var Cmd = &amp;cobra.Command{
        Use:   "transfer",
        Short: "[RUN VIA GIT LFS] register LFS files into gen3 during git push",
        Long:  `[RUN VIA GIT LFS] git-lfs transfer mechanism to register LFS files up to gen3 during git push. For new files, creates an indexd record and uploads to the bucket`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov9" title="32">{
                logger := drslog.GetLogger()
                logger.Info("~~~~~~~~~~~~~ START: drs transfer ~~~~~~~~~~~~~")

                // Gotta go fast  big buffer
                scanner := bufio.NewScanner(os.Stdin)
                const maxCapacity = 10 * 1024 * 1024 // 10 MB
                buf := make([]byte, 0, 64*1024)
                scanner.Buffer(buf, maxCapacity)
                streamEncoder := encoder.NewStreamEncoder(os.Stdout)

                // Read init message
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="32">initBytes := make([]byte, len(scanner.Bytes()))
                copy(initBytes, scanner.Bytes())
                var initMsg lfs.InitMessage
                if err := sConfig.Unmarshal(initBytes, &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error decoding initial JSON message: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="32">if initMsg.Event != "init" </span><span class="cov0" title="0">{
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%s'", initMsg.Event)
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="32">var drsClient client.DRSClient

                // Load config first
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error loading config: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                // Determine remote
                <span class="cov9" title="32">remote, err := cfg.GetDefaultRemote()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="32">drsClient, err = cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error creating DRS client: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                // Determine if upload or download
                <span class="cov9" title="32">if initMsg.Operation == OPERATION_UPLOAD || initMsg.Operation == OPERATION_DOWNLOAD </span><span class="cov9" title="32">{
                        transferOperation = initMsg.Operation
                        logger.Debug(fmt.Sprintf("Transfer operation: %s", transferOperation))
                }</span> else<span class="cov0" title="0"> {
                        err := fmt.Errorf("invalid or missing operation in init message: %s", initMsg.Operation)
                        logger.Error(err.Error())
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>
                <span class="cov9" title="32">if err := streamEncoder.Encode(map[string]any{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error sending init acknowledgment: %v", err))
                        return err
                }</span>

                <span class="cov9" title="32">for scanner.Scan() </span><span class="cov10" title="40">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("error decoding JSON: %s", err))
                                continue</span>
                        }

                        <span class="cov10" title="40">if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov4" title="4">{
                                // Handle download event
                                logger.Debug("Download requested")

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, "", 400, errMsg)
                                        continue</span>
                                }
                                <span class="cov4" title="4">logger.Info(fmt.Sprintf("Downloading file OID %s", downloadMsg.Oid))

                                // get signed url
                                accessUrl, err := drsClient.GetDownloadURL(downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error getting signed URL for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)

                                        drsObject, errG := drsmap.DrsInfoFromOid(downloadMsg.Oid)
                                        if errG == nil &amp;&amp; drsObject != nil </span><span class="cov0" title="0">{
                                                manualDownloadMsg := fmt.Sprintf("%s %s", drsObject.AccessMethods[0].AccessURL.URL, drsObject.Name)
                                                logger.Info(manualDownloadMsg)
                                                lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 302, manualDownloadMsg)
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Error(fmt.Sprintf("drsClient.GetObject failed for %s: %v ", downloadMsg.Oid, errG))
                                                lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                <span class="cov4" title="4">if accessUrl.URL == "" </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Unable to get access URL for OID %s", downloadMsg.Oid)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                // download signed url
                                <span class="cov4" title="4">dstPath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error getting destination path for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }
                                <span class="cov4" title="4">err = cloud.DownloadSignedUrl(accessUrl.URL, dstPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }

                                <span class="cov4" title="4">lfs.WriteProgressMessage(streamEncoder, downloadMsg.Oid, downloadMsg.Size, downloadMsg.Size)

                                // send success message back
                                logger.Info(fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))

                                lfs.WriteCompleteMessage(streamEncoder, downloadMsg.Oid, dstPath)</span>

                        } else<span class="cov9" title="36"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov4" title="4">{
                                // Handle upload event
                                logger.Debug("Upload requested")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }
                                <span class="cov4" title="4">logger.Info(fmt.Sprintf("Uploading file OID %s", uploadMsg.Oid))
                                drsObj, err := drsClient.RegisterFile(uploadMsg.Oid, GitLFSProgressCallback(streamEncoder))
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error registering file: %v\n", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }
                                // send success message back
                                <span class="cov4" title="4">lfs.WriteCompleteMessage(streamEncoder, uploadMsg.Oid, drsObj.Name)
                                logger.Info(fmt.Sprintf("Upload for OID %s complete", uploadMsg.Oid))</span>

                        } else<span class="cov9" title="32"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov9" title="32">{
                                logger.Info("LFS transfer terminate received.")
                        }</span>
                }

                <span class="cov9" title="32">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("stdin error: %s", err))
                }</span>

                <span class="cov9" title="32">logger.Info("~~~~~~~~~~~~~ COMPLETED: custom transfer ~~~~~~~~~~~~~")
                return nil</span>

        },
}

// GitLFSProgressCallback returns a ProgressCallback that logs progress events
// using the provided streamEncoder. It always returns nil (no error).
func GitLFSProgressCallback(streamEncoder *encoder.StreamEncoder) common.ProgressCallback <span class="cov4" title="4">{
        return func(e common.ProgressEvent) error </span><span class="cov2" title="2">{
                lfs.WriteProgressMessage(streamEncoder, e.Oid, e.BytesSoFar, e.BytesSinceLast)
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package transferref

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var (
        drsClient client.DRSClient
        sConfig   sonic.API = sonic.ConfigFastest
)

// TODO: used for AnvIL use case, requires implementation
var Cmd = &amp;cobra.Command{
        Use:   "transfer-ref",
        Short: "[RUN VIA GIT LFS] handle transfers of existing DRS object into git during git push",
        Long:  "[RUN VIA GIT LFS] custom transfer mechanism to pull LFS files during git lfs pull. Does nothing on push.",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                //setup logging to file for debugging
                myLogger := drslog.GetLogger()

                myLogger.Info("~~~~~~~~~~~~~ START: custom anvil transfer ~~~~~~~~~~~~~")

                scanner := bufio.NewScanner(os.Stdin)
                encoder := encoder.NewStreamEncoder(os.Stdout)

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("Error loading config: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">var remoteName string

                // Read the first (init) message outside the main loop
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        // No OID yet, so pass empty string
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">var initMsg map[string]any
                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("error decoding initial JSON message: %s", err))
                        return err
                }</span>

                // Handle "init" event and extract remote
                <span class="cov0" title="0">if evt, ok := initMsg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                        // if no remote name specified, use default remote
                        defaultRemote, err := cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                                lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">remoteName = string(defaultRemote)
                        myLogger.Debug(fmt.Sprintf("Initializing connection, remote not specified  using default: %s", remoteName))

                        // Respond with an empty json object via stdout
                        encoder.Encode(struct{}{})</span>
                } else<span class="cov0" title="0"> {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%v'", initMsg["event"])
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">drsClient, err = cfg.GetRemoteClient(config.Remote(remoteName), myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("Error creating indexd client: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Debug(fmt.Sprintf("error decoding JSON: %s", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Received message: %s", msg))

                        // Example: handle only "init" event
                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                                // Log for debugging
                                myLogger.Debug(fmt.Sprintf("Handling init: %s", msg))

                                // Respond with an empty json object via stdout
                                encoder.Encode(struct{}{})
                                myLogger.Debug("Responding to init with empty object")
                        }</span> else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov0" title="0">{
                                // Handle download event
                                myLogger.Debug(fmt.Sprintf("Handling download event: %s", msg))

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                // call DRS Downloader via downloadFile
                                <span class="cov0" title="0">dstPath, err := downloadFile(config.Remote(remoteName), downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v\n", downloadMsg.Oid, err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 500, errMsg)
                                        continue</span>
                                }

                                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Downloaded file for OID %s", downloadMsg.Oid))

                                // send success message back
                                myLogger.Debug(fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   downloadMsg.Oid,
                                        Path:  dstPath,
                                }
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov0" title="0">{
                                // Handle upload event
                                myLogger.Info(fmt.Sprintf("Handling upload event: %s", msg))
                                myLogger.Info("skipping upload, just registering existing DRS object")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, uploadMsg.Oid, 400, errMsg)
                                }</span>
                                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Got UploadMessage: %+v", uploadMsg))

                                // send success message back
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   uploadMsg.Oid,
                                }
                                myLogger.Info(fmt.Sprintf("Complete message: %+v", completeMsg))
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov0" title="0">{
                                // Handle terminate event
                                myLogger.Debug(fmt.Sprintf("terminate event received: %s", msg))
                        }</span>
                }

                <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("stdin error: %s", err))
                }</span>

                <span class="cov0" title="0">myLogger.Info("~~~~~~~~~~~~~ COMPLETED: custom anvil transfer ~~~~~~~~~~~~~")

                return nil</span>
        },
}

func downloadFile(remote config.Remote, sha string) (string, error) <span class="cov0" title="0">{
        myLogger := drslog.GetLogger()

        myLogger.Debug(fmt.Sprintf("Downloading file for sha %s", sha))

        // get terra project
        cfg, err := config.LoadConfig() // should this be handled only via indexd client?
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>

        <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remote, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">terraProject := cli.GetProjectId()

        filePath, err := drsmap.GetObjectPath(projectdir.DRS_REF_DIR, sha)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting object path for sha %s: %v", sha, err)
        }</span>
        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("File path for sha %s: %s", sha, filePath))

        // get DRS URI in the second line of the file
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        myLogger.Debug(fmt.Sprintf("Opened file %s for reading", filePath))

        scanner := bufio.NewScanner(file)
        var drsUri string
        lineNum := 0
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNum++
                line := scanner.Text()
                myLogger.Debug(fmt.Sprintf("Reading line %d: %s", lineNum, line))
                if lineNum == 2 </span><span class="cov0" title="0">{
                        // second line should be the DRS URI
                        drsUri = strings.TrimSpace(line)
                        myLogger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
                        break</span>
                }
        }

        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
        if drsUri == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error: file %s does not contain a valid DRS URI in the second line", filePath)
        }</span>
        <span class="cov0" title="0">drsObj, err := drsClient.GetObject(drsUri)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error fetching DRS object for URI %s: %v", drsUri, err)
        }</span>
        <span class="cov0" title="0">if drsObj == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no DRS object found for URI %s", drsUri)
        }</span>

        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("DRS Object fetched: %+v", drsObj))

        // call DRS downloader as a binary, redirect output to log file
        logFile, err := os.OpenFile(projectdir.DRS_LOG_FILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        //TODO: This should be done in the DRSClient code
        // download file, make sure its name is the sha
        dstPath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, sha)
        dstDir := filepath.Dir(dstPath)
        cmd := exec.Command("drs_downloader", "terra", "--user-project", terraProject, "--manifest-path", filePath, "--destination-dir", dstDir)

        // write command to log file
        logFile.WriteString(fmt.Sprintf("Running command: %s\n", cmd.String()))

        cmd.Stdout = logFile
        cmd.Stderr = logFile
        cmdOut, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error running drs_downloader for sha %s: %s", sha, cmdOut)
        }</span>

        //rename file to sha
        <span class="cov0" title="0">tmpPath := filepath.Join(dstDir, drsObj.Name)
        err = os.Rename(tmpPath, dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error renaming downloaded file from %s to %s: %v", tmpPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return dstPath, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package version

import (
        "fmt"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Cmd represents the "version" command
var Cmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Get version",
        Long:  ``,
        Run: func(cmd *cobra.Command, args []string) <span class="cov4" title="5">{
                fmt.Println("git-drs", buildVersion())
        }</span>,
}

func buildVersion() string <span class="cov4" title="6">{
        tag := ""
        commit := ""
        if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov4" title="6">{
                if info.Main.Version != "" &amp;&amp; info.Main.Version != "(devel)" </span><span class="cov0" title="0">{
                        tag = info.Main.Version
                }</span>
                <span class="cov4" title="6">for _, setting := range info.Settings </span><span class="cov10" title="72">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                commit = setting.Value</span>
                        case "vcs.tag":<span class="cov0" title="0">
                                if tag == "" </span><span class="cov0" title="0">{
                                        tag = setting.Value
                                }</span>
                        }
                }
        }

        <span class="cov4" title="6">commitShort := commit
        if len(commitShort) &gt; 7 </span><span class="cov0" title="0">{
                commitShort = commitShort[:7]
        }</span>

        <span class="cov4" title="6">switch </span>{
        case tag != "" &amp;&amp; commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s", tag, commitShort)</span>
        case tag != "":<span class="cov0" title="0">
                return tag</span>
        case commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("dev-%s", commitShort)</span>
        default:<span class="cov4" title="6">
                return "dev-unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package config

import (
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        "github.com/calypr/git-drs/client"
        anvil_client "github.com/calypr/git-drs/client/anvil"
        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "gopkg.in/yaml.v3"
)

// RemoteType represents the type of server being initialized
type RemoteType string
type Remote string

const (
        ORIGIN = "origin"

        Gen3ServerType  RemoteType = "gen3"
        AnvilServerType RemoteType = "anvil"
)

func AllRemoteTypes() []RemoteType <span class="cov0" title="0">{
        return []RemoteType{Gen3ServerType, AnvilServerType}
}</span>

func IsValidRemoteType(mode string) error <span class="cov0" title="0">{
        modeOptions := make([]string, len(AllRemoteTypes()))
        for i, m := range AllRemoteTypes() </span><span class="cov0" title="0">{
                modeOptions[i] = string(m)
        }</span>

        <span class="cov0" title="0">for _, validMode := range modeOptions </span><span class="cov0" title="0">{
                if mode == string(validMode) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid mode '%s'. Valid options are: %s", mode, strings.Join(modeOptions, ", "))</span>
}

// DRSRemote holds pointers to remote types
type DRSRemote interface {
        GetProjectId() string
        GetEndpoint() string
        GetBucketName() string
        GetClient(params map[string]string, logger *slog.Logger) (client.DRSClient, error)
}

type RemoteSelect struct {
        Gen3  *indexd_client.Gen3Remote `yaml:"gen3,omitempty"`
        Anvil *anvil_client.AnvilRemote `yaml:"anvil,omitempty"`
}

// Config holds the overall config structure
type Config struct {
        DefaultRemote Remote                  `yaml:"default_remote,omitempty"`
        Remotes       map[Remote]RemoteSelect `yaml:"remotes"`
}

func (c Config) GetRemoteClient(remote Remote, logger *slog.Logger) (client.DRSClient, error) <span class="cov8" title="32">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                path, _ := c.ConfigPath()
                return nil, fmt.Errorf("GetRemoteClient no remote configuration found for current remote: %s path: %s", remote, path)
        }</span>
        <span class="cov8" title="32">if x.Gen3 != nil </span><span class="cov8" title="32">{
                configText, _ := yaml.Marshal(x.Gen3)
                configParams := make(map[string]string)
                yaml.Unmarshal(configText, configParams)
                configParams["remote_name"] = string(remote)
                return x.Gen3.GetClient(configParams, logger)
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil.GetClient(nil, logger)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("no valid remote configuration found for current remote: %s", remote)</span>
}

func (c Config) GetRemote(remote Remote) DRSRemote <span class="cov5" title="7">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="7">if x.Gen3 != nil </span><span class="cov5" title="7">{
                return x.Gen3
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDefaultRemote returns the configured default remote with validation
func (c Config) GetDefaultRemote() (Remote, error) <span class="cov9" title="40">{
        if c.DefaultRemote == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "no default remote configured.\n"+
                                "Set one with: git drs remote set &lt;name&gt;\n"+
                                "Available remotes: %v",
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov9" title="40">if _, ok := c.Remotes[c.DefaultRemote]; !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "default remote '%s' not found in configuration.\n"+
                                "Available remotes: %v",
                        c.DefaultRemote,
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov9" title="40">return c.DefaultRemote, nil</span>
}

// GetRemoteOrDefault returns the specified remote if provided, otherwise returns the default remote
// This is a common pattern used across many commands that accept an optional --remote flag
func (c Config) GetRemoteOrDefault(remote string) (Remote, error) <span class="cov2" title="2">{
        if remote != "" </span><span class="cov1" title="1">{
                return Remote(remote), nil
        }</span>
        <span class="cov1" title="1">return c.GetDefaultRemote()</span>
}

// listRemoteNames returns a slice of all remote names for error messages
func (c Config) listRemoteNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(c.Remotes))
        for name := range c.Remotes </span><span class="cov0" title="0">{
                names = append(names, string(name))
        }</span>
        <span class="cov0" title="0">return names</span>
}

func getConfigPath() (string, error) <span class="cov10" title="58">{
        topLevel, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="58">configPath := filepath.Join(topLevel, projectdir.DRS_DIR, projectdir.CONFIG_YAML)
        return configPath, nil</span>
}

func (c Config) ConfigPath() (string, error) <span class="cov0" title="0">{
        return getConfigPath()
}</span>

// updates and git adds a Git DRS config file
// this should handle three cases:
// 1. create a new config file if it does not exist / is empty
// 2. return an error if the config file is invalid
// 3. update the existing config file, making sure to combine the new serversMap with the existing one
func UpdateRemote(name Remote, remote RemoteSelect) (*Config, error) <span class="cov4" title="5">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check if file exists, if not create parent directory
        <span class="cov4" title="5">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // if file doesn't exist, create file. Otherwise, open the file for writing
        <span class="cov4" title="5">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="5">defer file.Close()

        // if file is not empty, unmarshal into Config
        var cfg Config
        if err := yaml.NewDecoder(file).Decode(&amp;cfg); err != nil </span><span class="cov4" title="5">{
                // if the file is empty, we can just create a new config
                cfg = Config{
                        Remotes: map[Remote]RemoteSelect{},
                }
        }</span>

        <span class="cov4" title="5">if cfg.Remotes == nil </span><span class="cov0" title="0">{
                cfg.Remotes = make(map[Remote]RemoteSelect)
        }</span>

        // Set as default if this is the first remote
        <span class="cov4" title="5">if len(cfg.Remotes) == 0 &amp;&amp; cfg.DefaultRemote == "" </span><span class="cov4" title="5">{
                cfg.DefaultRemote = name
        }</span>

        <span class="cov4" title="5">cfg.Remotes[name] = remote

        // overwrite the file using config
        file.Seek(0, 0)
        file.Truncate(0)
        if err := yaml.NewEncoder(file).Encode(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write config file: %w", err)
        }</span>
        <span class="cov4" title="5">return &amp;cfg, nil</span>
}

// load an existing config
func LoadConfig() (*Config, error) <span class="cov9" title="47">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="47">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config file does not exist. Please run 'git drs init', see 'git drs init --help' for more details")
        }</span>

        <span class="cov9" title="46">reader, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open config file at %s", configPath)
        }</span>
        <span class="cov9" title="46">defer reader.Close()

        b, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read config file at %s", configPath)
        }</span>

        <span class="cov9" title="46">conf := Config{}
        err = yaml.Unmarshal(b, &amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config file at %s is invalid: %w", configPath, err)
        }</span>

        // Validate: if remotes exist but no default, error with migration instructions
        // FIXME: can be deleted after internal dev team ports over
        <span class="cov9" title="46">if len(conf.Remotes) &gt; 0 &amp;&amp; conf.DefaultRemote == "" </span><span class="cov1" title="1">{
                remoteNames := make([]string, 0, len(conf.Remotes))
                for name := range conf.Remotes </span><span class="cov1" title="1">{
                        remoteNames = append(remoteNames, string(name))
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf(
                        "configuration migration required.\n\n" +
                                "Your config has remotes but no default_remote field.\n" +
                                "Add this line to .git/drs/config.yaml:\n\n" +
                                "  default_remote: &lt;remote-name&gt;\n\n" +
                                "or delete and recreate the config file by re-running\n\n" +
                                "  git drs remote add \n\n",
                )</span>
        }

        <span class="cov9" title="45">return &amp;conf, nil</span>
}

func CreateEmptyConfig() error <span class="cov4" title="5">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov4" title="5">{
                if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // create empty config file
        <span class="cov4" title="5">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">defer file.Close()

        return nil</span>
}

func GetProjectId(remote Remote) (string, error) <span class="cov0" title="0">{
        cfg, err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>
        <span class="cov0" title="0">rmt := cfg.GetRemote(remote)
        if rmt == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov0" title="0">return rmt.GetProjectId(), nil</span>
}

// SaveConfig writes the configuration to disk
func SaveConfig(cfg *Config) error <span class="cov1" title="1">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        if err := yaml.NewEncoder(file).Encode(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package hash

import (
        "encoding/json"
        "fmt"
)

// ChecksumType represents the digest method used to create the checksum
type ChecksumType string

// IANA Named Information Hash Algorithm Registry values and other common types
const (
        ChecksumTypeSHA1     ChecksumType = "sha1"
        ChecksumTypeSHA256   ChecksumType = "sha256"
        ChecksumTypeSHA512   ChecksumType = "sha512"
        ChecksumTypeMD5      ChecksumType = "md5"
        ChecksumTypeETag     ChecksumType = "etag"
        ChecksumTypeCRC32C   ChecksumType = "crc32c"
        ChecksumTypeTrunc512 ChecksumType = "trunc512"
)

var SupportedChecksums = map[string]bool{
        string(ChecksumTypeSHA1):     true,
        string(ChecksumTypeSHA256):   true,
        string(ChecksumTypeSHA512):   true,
        string(ChecksumTypeMD5):      true,
        string(ChecksumTypeETag):     true,
        string(ChecksumTypeCRC32C):   true,
        string(ChecksumTypeTrunc512): true,
}

// IsValid checks if the checksum type is a known/recommended value
func (ct ChecksumType) IsValid() bool <span class="cov6" title="10">{
        switch ct </span>{
        case ChecksumTypeSHA256, ChecksumTypeSHA512, ChecksumTypeSHA1, ChecksumTypeMD5,
                ChecksumTypeETag, ChecksumTypeCRC32C, ChecksumTypeTrunc512:<span class="cov5" title="7">
                return true</span>
        default:<span class="cov3" title="3">
                return false</span>
        }
}

// String returns the string representation of the checksum type
func (ct ChecksumType) String() string <span class="cov7" title="15">{
        return string(ct)
}</span>

type Checksum struct {
        Checksum string       `json:"checksum"`
        Type     ChecksumType `json:"type"`
}

// HashInfo represents file hash information as per OpenAPI spec
// Patterns are documented for reference, but not enforced at struct level
// md5:    ^[0-9a-f]{32}$
// sha:    ^[0-9a-f]{40}$
// sha256: ^[0-9a-f]{64}$
// sha512: ^[0-9a-f]{128}$
// crc:    ^[0-9a-f]{8}$
// etag:   ^[0-9a-f]{32}(-\d+)?$
type HashInfo struct {
        MD5    string `json:"md5,omitempty"`
        SHA    string `json:"sha,omitempty"`
        SHA256 string `json:"sha256,omitempty"`
        SHA512 string `json:"sha512,omitempty"`
        CRC    string `json:"crc,omitempty"`
        ETag   string `json:"etag,omitempty"`
}

// UnmarshalJSON accepts both the DRS map-based schema and the array-of-checksums schema.
func (h *HashInfo) UnmarshalJSON(data []byte) error <span class="cov8" title="33">{
        if string(data) == "null" </span><span class="cov0" title="0">{
                *h = HashInfo{}
                return nil
        }</span>

        <span class="cov8" title="33">var mapPayload map[string]string
        if err := json.Unmarshal(data, &amp;mapPayload); err == nil </span><span class="cov8" title="32">{
                *h = ConvertStringMapToHashInfo(mapPayload)
                return nil
        }</span>

        <span class="cov1" title="1">var checksumPayload []Checksum
        if err := json.Unmarshal(data, &amp;checksumPayload); err == nil </span><span class="cov1" title="1">{
                *h = ConvertChecksumsToHashInfo(checksumPayload)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("unsupported HashInfo payload: %s", string(data))</span>
}

func ConvertStringMapToHashInfo(inputHashes map[string]string) HashInfo <span class="cov9" title="42">{
        hashInfo := HashInfo{}

        for key, value := range inputHashes </span><span class="cov10" title="53">{
                if !SupportedChecksums[key] </span><span class="cov4" title="4">{
                        continue</span> // Disregard unsupported types
                }
                // We use the string key directly in the switch statement.
                <span class="cov9" title="49">switch key </span>{
                case string(ChecksumTypeMD5):<span class="cov4" title="5">
                        hashInfo.MD5 = value</span>
                case string(ChecksumTypeSHA1):<span class="cov2" title="2">
                        hashInfo.SHA = value</span> // Maps to SHA field
                case string(ChecksumTypeSHA256):<span class="cov9" title="35">
                        hashInfo.SHA256 = value</span>
                case string(ChecksumTypeSHA512):<span class="cov2" title="2">
                        hashInfo.SHA512 = value</span>
                case string(ChecksumTypeCRC32C):<span class="cov2" title="2">
                        hashInfo.CRC = value</span> // Maps to CRC field
                case string(ChecksumTypeETag):<span class="cov2" title="2">
                        hashInfo.ETag = value</span>
                default:<span class="cov1" title="1"></span>
                }
        }

        <span class="cov9" title="42">return hashInfo</span>
}

// convertHashInfoToMap converts HashInfo struct to map[string]string
func ConvertHashInfoToMap(hashes HashInfo) map[string]string <span class="cov5" title="7">{
        result := make(map[string]string)
        if hashes.MD5 != "" </span><span class="cov4" title="4">{
                result["md5"] = hashes.MD5
        }</span>
        <span class="cov5" title="7">if hashes.SHA != "" </span><span class="cov1" title="1">{
                result["sha"] = hashes.SHA
        }</span>
        <span class="cov5" title="7">if hashes.SHA256 != "" </span><span class="cov4" title="4">{
                result["sha256"] = hashes.SHA256
        }</span>
        <span class="cov5" title="7">if hashes.SHA512 != "" </span><span class="cov1" title="1">{
                result["sha512"] = hashes.SHA512
        }</span>
        <span class="cov5" title="7">if hashes.CRC != "" </span><span class="cov1" title="1">{
                result["crc"] = hashes.CRC
        }</span>
        <span class="cov5" title="7">if hashes.ETag != "" </span><span class="cov1" title="1">{
                result["etag"] = hashes.ETag
        }</span>
        <span class="cov5" title="7">return result</span>
}

func ConvertChecksumsToMap(checksums []Checksum) map[string]string <span class="cov5" title="9">{
        result := make(map[string]string, len(checksums))
        for _, c := range checksums </span><span class="cov7" title="18">{
                // Uses the Checksum's Type (e.g., "sha256") as the key
                // and the Checksum's Checksum value as the map value.
                result[string(c.Type)] = c.Checksum
        }</span>
        <span class="cov5" title="9">return result</span>
}

// convertChecksumsToHashInfo is the main conversion logic needed for the structs.
// It converts the []Checksum slice to the HashInfo struct.
func ConvertChecksumsToHashInfo(checksums []Checksum) HashInfo <span class="cov5" title="6">{
        // 1. Convert the slice of Checksums into a map[string]string
        checksumMap := ConvertChecksumsToMap(checksums)

        // 2. Use the existing utility function to convert the map to HashInfo
        return ConvertStringMapToHashInfo(checksumMap)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package drs

import "github.com/calypr/git-drs/drs/hash"

type AccessURL struct {
        URL     string   `json:"url"`
        Headers []string `json:"headers"`
}

type Authorizations struct {
        //This structure is not stored in the file system
        Value string `json:"value"`
}

type AccessMethod struct {
        Type           string          `json:"type"`
        AccessURL      AccessURL       `json:"access_url"`
        AccessID       string          `json:"access_id,omitempty"`
        Cloud          string          `json:"cloud,omitempty"`
        Region         string          `json:"region,omitempty"`
        Available      string          `json:"available,omitempty"`
        Authorizations *Authorizations `json:"Authorizations,omitempty"`
}

type Contents struct {
}

type DRSPage struct {
        DRSObjects []DRSObject `json:"drs_objects"`
}

type DRSObjectResult struct {
        Object *DRSObject
        Error  error
}

type OutputObject struct {
        Id            string          `json:"id"`
        Name          string          `json:"name"`
        SelfURI       string          `json:"self_uri,omitempty"`
        Size          int64           `json:"size"`
        CreatedTime   string          `json:"created_time,omitempty"`
        UpdatedTime   string          `json:"updated_time,omitempty"`
        Version       string          `json:"version,omitempty"`
        MimeType      string          `json:"mime_type,omitempty"`
        Checksums     []hash.Checksum `json:"checksums"`
        AccessMethods []AccessMethod  `json:"access_methods"`
        Contents      []Contents      `json:"contents,omitempty"`
        Description   string          `json:"description,omitempty"`
        Aliases       []string        `json:"aliases,omitempty"`
}

type DRSObject struct {
        Id            string         `json:"id"`
        Name          string         `json:"name"`
        SelfURI       string         `json:"self_uri,omitempty"`
        Size          int64          `json:"size"`
        CreatedTime   string         `json:"created_time,omitempty"`
        UpdatedTime   string         `json:"updated_time,omitempty"`
        Version       string         `json:"version,omitempty"`
        MimeType      string         `json:"mime_type,omitempty"`
        Checksums     hash.HashInfo  `json:"checksums"`
        AccessMethods []AccessMethod `json:"access_methods"`
        Contents      []Contents     `json:"contents,omitempty"`
        Description   string         `json:"description,omitempty"`
        Aliases       []string       `json:"aliases,omitempty"`
}

// ConvertOutputObjectToDRSObject converts the OutputObject struct to a DRSObject struct.
func ConvertOutputObjectToDRSObject(in *OutputObject) *DRSObject <span class="cov10" title="3">{
        if in == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // 1. Convert the slice of Checksum structs to the HashInfo struct.
        <span class="cov6" title="2">hashInfo := hash.ConvertChecksumsToHashInfo(in.Checksums)

        // 2. Map all fields directly.
        return &amp;DRSObject{
                Id:          in.Id,
                Name:        in.Name,
                SelfURI:     in.SelfURI,
                Size:        in.Size,
                CreatedTime: in.CreatedTime,
                UpdatedTime: in.UpdatedTime,
                Version:     in.Version,
                MimeType:    in.MimeType,
                // The key conversion:
                Checksums: hashInfo,
                // Direct mapping for other fields:
                AccessMethods: in.AccessMethods,
                Contents:      in.Contents,
                Description:   in.Description,
                Aliases:       in.Aliases,
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package drs

import (
        "fmt"
        "path/filepath"

        "github.com/calypr/git-drs/drs/hash"
        "github.com/calypr/git-drs/utils"
)

type ObjectBuilder struct {
        Bucket     string
        ProjectID  string
        AccessType string
}

func NewObjectBuilder(bucket, projectID string) ObjectBuilder <span class="cov9" title="8">{
        return ObjectBuilder{
                Bucket:     bucket,
                ProjectID:  projectID,
                AccessType: "s3",
        }
}</span>

func (b ObjectBuilder) Build(fileName string, checksum string, size int64, drsID string) (*DRSObject, error) <span class="cov10" title="10">{
        if b.Bucket == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error: bucket name is empty in config file")
        }</span>
        <span class="cov9" title="9">accessType := b.AccessType
        if accessType == "" </span><span class="cov1" title="1">{
                accessType = "s3"
        }</span>

        <span class="cov9" title="9">fileURL := fmt.Sprintf("s3://%s", filepath.Join(b.Bucket, drsID, checksum))

        authzStr, err := utils.ProjectToResource(b.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="9">authorizations := Authorizations{
                Value: authzStr,
        }

        drsObj := DRSObject{
                Id:   drsID,
                Name: fileName,
                AccessMethods: []AccessMethod{{
                        Type:           accessType,
                        AccessURL:      AccessURL{URL: fileURL},
                        Authorizations: &amp;authorizations,
                }},
                Checksums: hash.HashInfo{SHA256: checksum},
                Size:      size,
        }

        return &amp;drsObj, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package drs

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/projectdir"
)

// This file contains functions that pertain to .git/drs/lfs/objects directory walk
type PendingObject struct {
        OID  string
        Path string
}

type ObjectStore struct {
        BasePath string
        Logger   *slog.Logger
}

func NewObjectStore(basePath string, logger *slog.Logger) *ObjectStore <span class="cov10" title="28">{
        return &amp;ObjectStore{
                BasePath: basePath,
                Logger:   logger,
        }
}</span>

func (s *ObjectStore) ObjectPath(oid string) (string, error) <span class="cov10" title="28">{
        // check that oid is a valid sha256 hash
        if len(oid) != 64 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error: %s is not a valid sha256 hash", oid)
        }</span>

        <span class="cov9" title="27">return filepath.Join(s.BasePath, oid[:2], oid[2:4], oid), nil</span>
}

func (s *ObjectStore) WriteObject(drsObj *DRSObject, oid string) error <span class="cov7" title="10">{
        indexdObjBytes, err := sonic.ConfigFastest.Marshal(drsObj)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshalling indexd object for oid %s: %v", oid, err)
        }</span>

        <span class="cov7" title="10">drsObjPath, err := s.ObjectPath(oid)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="10">if err := os.MkdirAll(filepath.Dir(drsObjPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating directory for %s: %v", drsObjPath, err)
        }</span>

        <span class="cov7" title="10">if err := os.WriteFile(drsObjPath, indexdObjBytes, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing %s: %v", drsObjPath, err)
        }</span>
        <span class="cov7" title="10">return nil</span>
}

func (s *ObjectStore) ReadObject(oid string) (*DRSObject, error) <span class="cov6" title="8">{
        path, err := s.ObjectPath(oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span>

        <span class="cov6" title="8">drsObjBytes, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov6" title="8">var drsObject DRSObject
        if err := sonic.ConfigFastest.Unmarshal(drsObjBytes, &amp;drsObject); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov6" title="8">return &amp;drsObject, nil</span>
}

// getPendingObjects walks .git/drs/lfs/objects/ to find all pending records
func GetPendingObjects(logger *slog.Logger) ([]*PendingObject, error) <span class="cov1" title="1">{
        var objects []*PendingObject
        objectsDir := projectdir.DRS_OBJS_PATH

        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov5" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="5">if info.IsDir() </span><span class="cov3" title="3">{
                        return nil
                }</span>
                <span class="cov2" title="2">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov1" title="1">oid := parts[2] // GetObjectPath stores full OID in the 3rd directory level
                objects = append(objects, &amp;PendingObject{
                        OID: oid,
                })
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found %d pending objects in %s", len(objects), objectsDir))
        return objects, nil</span>
}

func GetDrsLfsObjects(logger *slog.Logger) (map[string]*DRSObject, error) <span class="cov1" title="1">{
        objects := map[string]*DRSObject{}
        objectsDir := projectdir.DRS_OBJS_PATH
        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("DRS objects directory not found: %s", objectsDir))
                return nil, nil
        }</span>

        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov5" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error accessing path %s: %v", path, err))
                        return err
                }</span>
                <span class="cov5" title="6">if info.IsDir() </span><span class="cov3" title="3">{
                        return nil
                }</span>
                <span class="cov3" title="3">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="3">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov2" title="2">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error reading file %s: %v", path, err))
                        return err
                }</span>
                <span class="cov2" title="2">var drsObject DRSObject
                if err := sonic.ConfigFastest.Unmarshal(data, &amp;drsObject); err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("Error unmarshalling JSON from %s: %v", path, err))
                        return nil
                }</span>

                // This could be problematic
                <span class="cov1" title="1">if drsObject.Checksums.SHA256 != "" </span><span class="cov1" title="1">{
                        objects[drsObject.Checksums.SHA256] = &amp;drsObject
                }</span>

                <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Successfully unmarshaled DRSObject from %s:\n%+v", path, drsObject))
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found and unmarshaled %d DRS objects.", len(objects)))
        return objects, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package drs

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/utils"
)

const DRS_DIR = ".git/drs"

type DrsWalkFunc func(path string, d *DRSObject) error

func BaseDir() (string, error) <span class="cov1" title="1">{
        gitTopLevel, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(gitTopLevel, DRS_DIR), nil</span>
}

type dirWalker struct {
        baseDir  string
        userFunc DrsWalkFunc
}

func (d *dirWalker) call(path string, dir fs.DirEntry, cErr error) error <span class="cov10" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov6" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">obj := DRSObject{}
        err = sonic.ConfigFastest.Unmarshal(data, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">relPath, err := filepath.Rel(d.baseDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return d.userFunc(relPath, &amp;obj)</span>
}

func ObjectWalk(f DrsWalkFunc) error <span class="cov1" title="1">{
        baseDir, err := BaseDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">ud := dirWalker{baseDir, f}
        return filepath.WalkDir(baseDir, ud.call)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package drslog

import (
        "log"
        "log/slog"
        "strings"
)

// AsStdLogger adapts a slog.Logger to the standard library log.Logger interface.
func AsStdLogger(logger *slog.Logger) *log.Logger <span class="cov10" title="71">{
        return log.New(slogWriter{logger: logger}, "", 0)
}</span>

type slogWriter struct {
        logger *slog.Logger
}

// Write implements io.Writer and is invoked by the standard library log functions
// (for example, the logger returned by AsStdLogger). Documented calls inside:
//
//   - `string(p)`
//     Converts the incoming byte slice to a string for processing.
//
//   - `strings.TrimSpace(...)`
//     Removes leading/trailing whitespace (including trailing newlines) so that
//     empty or whitespace-only log lines are dropped.
//
//   - `w.logger.Info(...)`
//     Emits the trimmed message to the wrapped `slog.Logger` at Info level.
//
//   - `len(p)`
//     Returned to satisfy the io.Writer contract; indicates the number of bytes
//     "written". This implementation never returns an error.
//
// Note: This implementation deliberately ignores write errors and drops messages
// that are empty after trimming.
func (w slogWriter) Write(p []byte) (int, error) <span class="cov8" title="28">{
        message := strings.TrimSpace(string(p))
        if message != "" </span><span class="cov8" title="28">{
                w.logger.Info(message)
        }</span>
        <span class="cov8" title="28">return len(p), nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// go
package drslog

import (
        "io"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"

        "github.com/calypr/git-drs/projectdir"
)

var globalLogger *slog.Logger
var globalLogFile io.Closer
var globalLoggerOnce sync.Once
var globalLoggerMu sync.RWMutex
var GIT_TRANSFER_TRACE int
var modulePathSuffixOnce sync.Once
var modulePathSuffixValue string
var repoRootOnce sync.Once
var repoRootValue string

const (
        levelDebugStr   = "DEBUG"
        levelInfoStr    = "INFO"
        levelWarnStr    = "WARN"
        levelWarningStr = "WARNING"
        levelErrorStr   = "ERROR"
)

// init initializes package-level settings from the environment.
//
// Documented calls inside:
//   - os.Getenv("GIT_TRANSFER_TRACE")
//     Reads environment variable to optionally enable trace logging.
//   - strconv.Atoi(envValue)
//     Parses the numeric env value.
//
// Side-effects:
// - sets package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - runtime automatically invokes init(); no external callers needed.
func init() <span class="cov6" title="58">{
        GIT_TRANSFER_TRACE = 0
        if envValue := os.Getenv("GIT_TRANSFER_TRACE"); envValue != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(envValue); err == nil </span><span class="cov0" title="0">{
                        GIT_TRANSFER_TRACE = parsed
                }</span>
        }
}

// TraceEnabled returns whether transfer trace logging is enabled.
//
// Documented calls inside:
// - reads package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - logging setup and callsites that want to be verbose only when trace is enabled.
func TraceEnabled() bool <span class="cov6" title="54">{
        return GIT_TRANSFER_TRACE == 1
}</span>

// NewLogger creates and installs a global slog.Logger that writes to the specified file
// and optionally to stderr. It is safe to call multiple times; the first successful call
// establishes the global logger.
//
// Documented calls inside:
//   - projectdir.DRS_DIR usage
//     Uses projectdir.DRS_DIR to create log directory.
//   - os.MkdirAll(projectdir.DRS_DIR, 0755)
//     Ensures the directory exists; returns error on failure.
//   - filepath.Join(projectdir.DRS_DIR, "git-drs.log")
//     Constructs default filename when none provided.
//   - os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
//     Opens/creates the log file (returns *os.File).
//   - io.MultiWriter(writers...)
//     Combines file and optionally os.Stderr into a single Writer.
//   - slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{...})
//     Creates the text handler for slog that writes to the combined writer.
//   - slog.New(handler).With("pid", os.Getpid())
//     Builds the logger and attaches pid attribute.
//   - globalLoggerMu.Lock()/Unlock()
//     Protects globalLogFile and globalLogger assignment.
//
// Side-effects:
// - sets package-level globalLogger and globalLogFile.
// Typical callers:
// - application startup code that wants to initialize logging (e.g. main).
func NewLogger(filename string, logToStderr bool) (*slog.Logger, error) <span class="cov6" title="54">{
        var writers []io.Writer

        if filename == "" </span><span class="cov6" title="54">{
                // create drs dir if it doesn't exist
                if err := os.MkdirAll(projectdir.DRS_DIR, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov6" title="54">filename = filepath.Join(projectdir.DRS_DIR, "git-drs.log")</span>
        }

        <span class="cov6" title="54">file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="54">writers = append(writers, file)

        if logToStderr </span><span class="cov6" title="46">{
                writers = append(writers, os.Stderr)
        }</span>

        <span class="cov6" title="54">multiWriter := io.MultiWriter(writers...)

        handler := slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{
                AddSource:   true,
                Level:       resolveLogLevel(),
                ReplaceAttr: replaceSourceAttr,
        })
        core := slog.New(handler).With("pid", os.Getpid())

        globalLoggerMu.Lock()
        globalLogFile = file
        globalLogger = core
        globalLoggerMu.Unlock()

        return globalLogger, nil</span>
}

// GetLogger returns the global logger, initializing a no-op logger on first access.
//
// Documented calls inside:
//   - globalLoggerOnce.Do(func() { ... })
//     Ensures initialization runs only once.
//   - NewNoOpLogger()
//     Creates a logger that discards output if no global logger was set.
//
// Typical callers:
// - any package code that needs access to the package-level logger.
func GetLogger() *slog.Logger <span class="cov6" title="41">{
        globalLoggerOnce.Do(func() </span><span class="cov6" title="41">{
                if globalLogger == nil </span><span class="cov0" title="0">{
                        globalLogger = NewNoOpLogger()
                }</span>
        })
        <span class="cov6" title="41">return globalLogger</span>
}

// Close closes the active log file if one was opened.
//
// Documented calls inside:
//   - globalLoggerMu.Lock()/Unlock()
//     Protects access to globalLogFile.
//   - globalLogFile.Close()
//     Closes the underlying file and returns any error.
//
// Side-effects:
// - sets globalLogFile to nil.
// Typical callers:
// - application shutdown code or tests that want to release file handles.
func Close() error <span class="cov1" title="1">{
        globalLoggerMu.Lock()
        defer globalLoggerMu.Unlock()
        if globalLogFile != nil </span><span class="cov1" title="1">{
                err := globalLogFile.Close()

                globalLogFile = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewNoOpLogger returns a logger that discards all output.
//
// Documented calls inside:
//   - slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{Level: slog.LevelDebug})
//     Creates a text handler writing to io.Discard.
//   - slog.New(handler)
//     Builds the logger.
//
// Typical callers:
// - GetLogger on first access when no global logger was configured.
// - tests that need a deterministic logger that produces no output.
func NewNoOpLogger() *slog.Logger <span class="cov4" title="13">{
        handler := slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        return slog.New(handler)
}</span>

// resolveLogLevel determines the effective log level.
//
// Documented calls inside:
//   - TraceEnabled()
//     If trace is enabled, returns Debug level immediately.
//   - readLogLevelFromGitConfig()
//     Attempts to read configured level from git config; returns level and ok.
//   - defaults to slog.LevelInfo when nothing else matches.
//
// Typical callers:
// - NewLogger -&gt; used when creating slog.HandlerOptions.Level.
func resolveLogLevel() slog.Level <span class="cov6" title="54">{
        if TraceEnabled() </span><span class="cov0" title="0">{
                return slog.LevelDebug
        }</span>

        <span class="cov6" title="54">level, ok := readLogLevelFromGitConfig()
        if ok </span><span class="cov0" title="0">{
                return level
        }</span>

        <span class="cov6" title="54">return slog.LevelInfo</span>
}

// readLogLevelFromGitConfig queries git configuration for a custom log level.
//
// Documented calls inside:
//   - exec.Command("git", "config", "--get", "lfs.customtransfer.drs.loglevel")
//     Constructs the command to query git config.
//   - cmd.Output()
//     Executes the command and returns raw output or an error.
//   - strings.TrimSpace(string(output))
//     Trims whitespace/newlines from git output.
//   - parseLogLevel(value)
//     Parses the trimmed value into a slog.Level.
//
// Behavior:
// - On any error or empty output, returns (slog.LevelInfo, false) to indicate no valid config was found.
// Typical callers:
// - resolveLogLevel when initializing a logger.
func readLogLevelFromGitConfig() (slog.Level, bool) <span class="cov6" title="54">{
        cmd := exec.Command("git", "config", "--get", "lfs.customtransfer.drs.loglevel")
        output, err := cmd.Output()
        if err != nil </span><span class="cov6" title="54">{
                return slog.LevelInfo, false
        }</span>

        <span class="cov0" title="0">value := strings.TrimSpace(string(output))
        if value == "" </span><span class="cov0" title="0">{
                return slog.LevelInfo, false
        }</span>

        <span class="cov0" title="0">parsed, ok := parseLogLevel(value)
        if !ok </span><span class="cov0" title="0">{
                return slog.LevelInfo, false
        }</span>
        <span class="cov0" title="0">return parsed, true</span>
}

// parseLogLevel maps textual level names to slog.Level.
//
// Documented calls inside:
//   - strings.ToUpper(strings.TrimSpace(value))
//     Normalizes the input for comparison.
//   - switch on normalized value to return corresponding slog.Level constants.
//
// Typical callers:
// - readLogLevelFromGitConfig
// - resolveLogLevel indirectly.

func parseLogLevel(value string) (slog.Level, bool) <span class="cov0" title="0">{
        switch strings.ToUpper(strings.TrimSpace(value)) </span>{
        case levelDebugStr:<span class="cov0" title="0">
                return slog.LevelDebug, true</span>
        case levelInfoStr:<span class="cov0" title="0">
                return slog.LevelInfo, true</span>
        case levelWarnStr, levelWarningStr:<span class="cov0" title="0">
                return slog.LevelWarn, true</span>
        case levelErrorStr:<span class="cov0" title="0">
                return slog.LevelError, true</span>
        default:<span class="cov0" title="0">
                return slog.LevelDebug, false</span>
        }
}

// replaceSourceAttr rewrites the slog.Source attr to a shorter path suitable for logs.
//
// Documented calls inside:
//   - attr.Key comparison with slog.SourceKey
//     Determines whether the attribute is the source attribute.
//   - attr.Value.Any().(*slog.Source)
//     Retrieves and type-asserts the attribute value to *slog.Source.
//   - formatSourcePath(source.File)
//     Formats the file path according to module or repo root heuristics.
//   - attr.Value = slog.AnyValue(source)
//     Replaces attribute value with modified source.
//
// Typical callers:
// - passed as ReplaceAttr to slog.HandlerOptions in NewLogger.
func replaceSourceAttr(_ []string, attr slog.Attr) slog.Attr <span class="cov10" title="662">{
        if attr.Key != slog.SourceKey </span><span class="cov9" title="510">{
                return attr
        }</span>
        <span class="cov7" title="152">source, ok := attr.Value.Any().(*slog.Source)
        if !ok || source == nil </span><span class="cov0" title="0">{
                return attr
        }</span>
        <span class="cov7" title="152">source.File = formatSourcePath(source.File)
        attr.Value = slog.AnyValue(source)
        return attr</span>
}

// formatSourcePath shortens file paths using module suffix or repo root heuristics.
//
// Documented calls inside:
//   - filepath.ToSlash(path)
//     Normalizes OS-specific separators to forward slashes.
//   - modulePathSuffix()
//     Gets the module path suffix (derived from build info).
//   - strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
//     Normalizes module suffix.
//   - strings.Index(pathSlash, "/"+moduleSuffixSlash+"/")
//     Searches for module suffix within the path to trim leading segments.
//   - strings.HasPrefix(pathSlash, moduleSuffixSlash+"/")
//     Handles case where path already starts with module suffix.
//   - repoRootPath()
//     Attempts to resolve the repository root (by locating go.mod).
//   - strings.HasPrefix(pathSlash, repoRootSlash+"/")
//     Trims repository-root prefix to produce a relative path.
//   - filepath.ToSlash(filepath.Join(moduleSuffix, rel))
//     Reconstructs path when combining module suffix and relative path.
//
// Typical callers:
// - replaceSourceAttr when rewriting source file paths for log output.
func formatSourcePath(path string) string <span class="cov7" title="152">{
        pathSlash := filepath.ToSlash(path)
        moduleSuffix := modulePathSuffix()
        if moduleSuffix != "" </span><span class="cov7" title="152">{
                moduleSuffixSlash := strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
                if idx := strings.Index(pathSlash, "/"+moduleSuffixSlash+"/"); idx &gt;= 0 </span><span class="cov7" title="152">{
                        return pathSlash[idx+1:]
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(pathSlash, moduleSuffixSlash+"/") </span><span class="cov0" title="0">{
                        return pathSlash
                }</span>
        }
        <span class="cov0" title="0">repoRoot := repoRootPath()
        if repoRoot != "" </span><span class="cov0" title="0">{
                repoRootSlash := filepath.ToSlash(repoRoot)
                if strings.HasPrefix(pathSlash, repoRootSlash+"/") </span><span class="cov0" title="0">{
                        rel := strings.TrimPrefix(pathSlash, repoRootSlash+"/")
                        if moduleSuffix != "" </span><span class="cov0" title="0">{
                                return filepath.ToSlash(filepath.Join(moduleSuffix, rel))
                        }</span>
                        <span class="cov0" title="0">return rel</span>
                }
        }
        <span class="cov0" title="0">return pathSlash</span>
}

// modulePathSuffix returns the module path suffix derived from build info.
//
// Documented calls inside:
//   - runtime/debug.ReadBuildInfo()
//     Reads build info at runtime; used to extract Main.Path.
//   - strings.Split(info.Main.Path, "/")
//     Splits module path to drop the first element (typically hostname).
//
// Side-effects:
// - caches computed value via modulePathSuffixOnce.
// Typical callers:
// - formatSourcePath to help shorten file paths.
func modulePathSuffix() string <span class="cov7" title="152">{
        modulePathSuffixOnce.Do(func() </span><span class="cov5" title="36">{
                if info, ok := debug.ReadBuildInfo(); ok &amp;&amp; info.Main.Path != "" </span><span class="cov5" title="36">{
                        parts := strings.Split(info.Main.Path, "/")
                        if len(parts) &gt; 1 </span><span class="cov5" title="36">{
                                modulePathSuffixValue = strings.Join(parts[1:], "/")
                        }</span>
                }
        })
        <span class="cov7" title="152">return modulePathSuffixValue</span>
}

// repoRootPath attempts to locate the repository root by searching for go.mod upward.
//
// Documented calls inside:
//   - os.Getwd()
//     Retrieves current working directory as a starting point.
//   - os.Stat(filepath.Join(dir, "go.mod"))
//     Checks for presence of go.mod in each directory while walking up.
//   - filepath.Dir(dir)
//     Moves up one directory level on each iteration.
//
// Side-effects:
// - caches resolved repo root via repoRootOnce.
// Typical callers:
// - formatSourcePath when computing shorter file paths for logs.
func repoRootPath() string <span class="cov0" title="0">{
        repoRootOnce.Do(func() </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">dir := cwd
                for </span><span class="cov0" title="0">{
                        if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov0" title="0">{
                                repoRootValue = dir
                                return
                        }</span>
                        <span class="cov0" title="0">parent := filepath.Dir(dir)
                        if parent == dir </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">dir = parent</span>
                }
        })
        <span class="cov0" title="0">return repoRootValue</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package drsmap

// Utilities to map between Git LFS files and DRS objects

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
        drslfs "github.com/calypr/git-drs/drsmap/lfs"
        drsstore "github.com/calypr/git-drs/drsmap/store"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "github.com/google/uuid"
)

// NAMESPACE is the UUID namespace used for generating DRS UUIDs
var NAMESPACE = uuid.NewMD5(uuid.NameSpaceURL, []byte("calypr.org"))

func PushLocalDrsObjects(drsClient client.DRSClient, myLogger *slog.Logger) error <span class="cov0" title="0">{
        // Gather all objects in .git/drs/lfs/objects store
        drsLfsObjs, err := drs.GetDrsLfsObjects(myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make this a map if it does not exist when hitting the server
        <span class="cov0" title="0">sums := make([]*hash.Checksum, 0)
        for _, obj := range drsLfsObjs </span><span class="cov0" title="0">{
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                sums = append(sums, &amp;hash.Checksum{
                                        Checksum: sum,
                                        Type:     hash.ChecksumTypeSHA256,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">outobjs := map[string]*drs.DRSObject{}
        for _, sum := range sums </span><span class="cov0" title="0">{
                records, err := drsClient.GetObjectByHash(sum)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                        continue</span>
                }
                <span class="cov0" title="0">found := false
                // Warning: The loop overwrites map entries if multiple records have the same SHA256 hash.
                // If there are multiple records with SHA256 checksums, only the last one will be stored in the map
                for i, rec := range records </span><span class="cov0" title="0">{
                        if rec.Checksums.SHA256 != "" </span><span class="cov0" title="0">{
                                found = true
                                outobjs[rec.Checksums.SHA256] = &amp;records[i]
                        }</span>
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                }</span>
        }

        <span class="cov0" title="0">for drsObjKey := range outobjs </span><span class="cov0" title="0">{
                val, ok := drsLfsObjs[drsObjKey]
                if !ok </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Drs record not found in sha256 map %s", drsObjKey))
                }</span>
                <span class="cov0" title="0">if _, statErr := os.Stat(val.Name); os.IsNotExist(statErr) </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error: Object record found locally, but file does not exist locally. Registering Record %s", val.Name))
                        _, err = drsClient.RegisterRecord(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                } else<span class="cov0" title="0"> {
                        _, err = drsClient.RegisterFile(drsObjKey, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func PullRemoteDrsObjects(drsClient client.DRSClient, logger *slog.Logger) error <span class="cov0" title="0">{
        objChan, err := drsClient.ListObjectsByProject(drsClient.GetProjectId())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">writtenObjs := 0
        for drsObj := range objChan </span><span class="cov0" title="0">{
                if drsObj.Object == nil </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("OBJ is nil: %#v, continuing...", drsObj))
                        continue</span>
                }
                <span class="cov0" title="0">sumMap := hash.ConvertHashInfoToMap(drsObj.Object.Checksums)
                if len(sumMap) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: drs Object '%s' does not contain a checksum", drsObj.Object.Id)
                }</span>
                <span class="cov0" title="0">var drsObjPath, oid string = "", ""
                for sumType, sum := range sumMap </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                oid = sum
                                drsObjPath, err = GetObjectPath(projectdir.DRS_OBJS_PATH, oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error getting object path for oid %s: %v", oid, err)
                                }</span>
                        }
                }
                // Only write a record if there exists a proper checksum to use. Checksums besides sha256 are not used
                <span class="cov0" title="0">if drsObjPath != "" &amp;&amp; oid != "" </span><span class="cov0" title="0">{
                        writtenObjs++
                        // write drs objects to DRS_OBJS_PATH
                        err = WriteDrsObj(drsObj.Object, oid, drsObjPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error writing DRS object for oid %s: %v", oid, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Wrote %d new objs to object store", writtenObjs))
        return nil</span>
}

func UpdateDrsObjects(builder drs.ObjectBuilder, gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) error <span class="cov3" title="4">{

        logger.Debug("Update to DRS objects started")

        // get all lfs files
        lfsFiles, err := drslfs.GetAllLfsFiles(gitRemoteName, gitRemoteLocation, branches, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting all LFS files: %v", err)
        }</span>

        // get project
        <span class="cov3" title="4">if builder.ProjectID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no project configured")
        }</span>

        // create a DRS object for each LFS file
        // which will be used at push-time
        <span class="cov3" title="4">for _, file := range lfsFiles </span><span class="cov3" title="4">{

                drsObj, err2 := WriteDrsFile(builder, file, nil)
                if err2 != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Could not WriteDrsFile for %s OID %s %v", file.Name, file.Oid, err2))
                        continue</span>
                }
                <span class="cov3" title="4">logger.Info(fmt.Sprintf("Prepared File %s OID %s with DRS ID %s for commit", file.Name, file.Oid, drsObj.Id))</span>
        }

        <span class="cov3" title="4">return nil</span>
}

// WriteDrsFile creates drsObject record from LFS file info
func WriteDrsFile(builder drs.ObjectBuilder, file drslfs.LfsFileInfo, objectPath *string) (*drs.DRSObject, error) <span class="cov4" title="8">{

        // determine drs object path: use provided objectPath if non-nil/non-empty, otherwise compute default

        // if file is in cache, hasn't been committed to git or pushed to indexd
        // create a local DRS object for it
        // TODO: determine git to gen3 project hierarchy mapping (eg repo name to project ID)
        drsId := DrsUUID(builder.ProjectID, file.Oid)
        // logger.Printf("File: %s, OID: %s, DRS ID: %s\n", file.Name, file.Oid, drsId)

        // get file info needed to create indexd record
        //path, err := GetObjectPath(projectdir.LFS_OBJS_PATH, file.Oid)
        //if err != nil {
        //        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
        //}
        //if _, err := os.Stat(path); os.IsNotExist(err) {
        //        return fmt.Errorf("error: File %s does not exist in LFS objects path %s. Aborting", file.Name, path)
        //}

        drsObj, err := builder.Build(file.Name, file.Oid, file.Size, drsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error building DRS object for oid %s: %v", file.Oid, err)
        }</span>
        <span class="cov4" title="8">if objectPath != nil &amp;&amp; *objectPath != "" </span><span class="cov3" title="3">{
                drsObj.AccessMethods[0].AccessURL = drs.AccessURL{URL: *objectPath}
        }</span>

        // write drs objects to DRS_OBJS_PATH
        <span class="cov4" title="8">err = drsstore.WriteObject(projectdir.DRS_OBJS_PATH, drsObj, file.Oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error writing DRS object for oid %s: %v", file.Oid, err)
        }</span>
        <span class="cov4" title="8">return drsObj, nil</span>
}

func WriteDrsObj(drsObj *drs.DRSObject, oid string, drsObjPath string) error <span class="cov1" title="1">{
        basePath := filepath.Dir(filepath.Dir(filepath.Dir(drsObjPath)))
        return drsstore.WriteObject(basePath, drsObj, oid)
}</span>

func DrsUUID(projectId string, hash string) string <span class="cov10" title="118">{
        // create UUID based on project ID and hash
        hashStr := fmt.Sprintf("%s:%s", projectId, hash)
        return uuid.NewSHA1(NAMESPACE, []byte(hashStr)).String()
}</span>

// creates drsObject record from file
func DrsInfoFromOid(oid string) (*drs.DRSObject, error) <span class="cov4" title="7">{
        return drsstore.ReadObject(projectdir.DRS_OBJS_PATH, oid)
}</span>

func GetObjectPath(basePath string, oid string) (string, error) <span class="cov5" title="9">{
        return drsstore.ObjectPath(basePath, oid)
}</span>

// CreateCustomPath creates a custom path based on the DRS URI
// For example, DRS URI drs://&lt;namespace&gt;:&lt;drs_id&gt;
// create custom path &lt;baseDir&gt;/&lt;namespace&gt;/&lt;drs_id&gt;
func CreateCustomPath(baseDir, drsURI string) (string, error) <span class="cov0" title="0">{
        const prefix = "drs://"
        if len(drsURI) &lt;= len(prefix) || drsURI[:len(prefix)] != prefix </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid DRS URI: %s", drsURI)
        }</span>
        <span class="cov0" title="0">rest := drsURI[len(prefix):]

        // Split by first colon
        colonIdx := -1
        for i, c := range rest </span><span class="cov0" title="0">{
                if c == ':' </span><span class="cov0" title="0">{
                        colonIdx = i
                        break</span>
                }
        }
        <span class="cov0" title="0">if colonIdx == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("DRS URI missing colon: %s", drsURI)
        }</span>
        <span class="cov0" title="0">namespace := rest[:colonIdx]
        drsId := rest[colonIdx+1:]
        return filepath.Join(baseDir, namespace, drsId), nil</span>
}

// FindMatchingRecord finds a record from the list that matches the given project ID authz
// If no matching record is found return nil
func FindMatchingRecord(records []drs.DRSObject, projectId string) (*drs.DRSObject, error) <span class="cov4" title="5">{
        if len(records) == 0 </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        // Convert project ID to resource path format for comparison
        <span class="cov3" title="4">expectedAuthz, err := utils.ProjectToResource(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting project ID to resource format: %v", err)
        }</span>

        // Get the first record with matching authz if exists

        <span class="cov3" title="4">for _, record := range records </span><span class="cov3" title="4">{
                for _, access := range record.AccessMethods </span><span class="cov3" title="4">{
                        // assert access has Authorizations
                        if access.Authorizations == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("access method for record %v missing authorizations", record)
                        }</span>
                        <span class="cov3" title="4">if access.Authorizations.Value == expectedAuthz </span><span class="cov3" title="4">{
                                return &amp;record, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package lfs

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/drs"
        "github.com/calypr/git-drs/drs/hash"
)

type DryRunSpec struct {
        Remote string // e.g. "origin"
        Ref    string // e.g. "refs/heads/main" or "HEAD"
}

// RunPushDryRun executes: git lfs push --dry-run &lt;remote&gt; &lt;ref&gt;
func RunPushDryRun(ctx context.Context, repoDir string, spec DryRunSpec, logger *slog.Logger) (string, error) <span class="cov7" title="4">{
        if spec.Remote == "" || spec.Ref == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing remote or ref")
        }</span>

        // Debug-print the command to stderr
        <span class="cov7" title="4">fullCmd := []string{"git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref}
        logger.Debug(fmt.Sprintf("running command: %v", fullCmd))

        cmd := exec.CommandContext(ctx, "git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref)
        cmd.Dir = repoDir

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        out := stdout.String()
        if err != nil </span><span class="cov0" title="0">{
                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span>
                <span class="cov0" title="0">return out, fmt.Errorf("git lfs push --dry-run failed: %s", msg)</span>
        }
        <span class="cov7" title="4">return out, nil</span>
}

// output of git lfs ls-files
type lsOutput struct {
        Files []LfsFileInfo `json:"files"`
}

// LfsFileInfo represents the information about an LFS file
type LfsFileInfo struct {
        Name       string `json:"name"`
        Size       int64  `json:"size"`
        Checkout   bool   `json:"checkout"`
        Downloaded bool   `json:"downloaded"`
        OidType    string `json:"oid_type"`
        Oid        string `json:"oid"`
        Version    string `json:"version"`
}

// CheckIfLfsFile checks if a given file is tracked by Git LFS.
// Returns true and file info if it's an LFS file, false otherwise.
func CheckIfLfsFile(fileName string) (bool, *LfsFileInfo, error) <span class="cov0" title="0">{
        // Use git lfs ls-files -I to check if specific file is LFS tracked
        cmd := exec.Command("git", "lfs", "ls-files", "-I", fileName, "--json")
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If git lfs ls-files returns error, the file is not LFS tracked
                return false, nil, nil
        }</span>

        // If output is empty, file is not LFS tracked
        <span class="cov0" title="0">if len(strings.TrimSpace(string(out))) == 0 </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        // Parse the JSON output
        <span class="cov0" title="0">var output lsOutput
        err = sonic.ConfigFastest.Unmarshal(out, &amp;output)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("error unmarshaling git lfs ls-files output for %s: %v", fileName, err)
        }</span>

        // If no files in output, not LFS tracked
        <span class="cov0" title="0">if len(output.Files) == 0 </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        // Convert to our LfsFileInfo struct
        <span class="cov0" title="0">file := output.Files[0]
        lfsInfo := &amp;LfsFileInfo{
                Name:       file.Name,
                Size:       file.Size,
                Checkout:   file.Checkout,
                Downloaded: file.Downloaded,
                OidType:    file.OidType,
                Oid:        file.Oid,
                Version:    file.Version,
        }

        return true, lfsInfo, nil</span>
}

func getStagedFiles() ([]string, error) <span class="cov0" title="0">{
        // chose exec here for performance over using go-git
        // tradeoff is very rare concurrency problems which currently aren't relevant to the pre-commit
        // FIXME: filter out files that have been deleted? Bug: if git rm, the DRS object still created
        cmd := exec.Command("git", "diff", "--name-only", "--cached")
        cmdOut, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error running git command: %w: out: '%s'", err, string(cmdOut))
        }</span>
        <span class="cov0" title="0">stagedFiles := strings.Split(strings.TrimSpace(string(cmdOut)), "\n")
        return stagedFiles, nil</span>
}

func GetRepoNameFromGit(remote string) (string, error) <span class="cov0" title="0">{
        // prefer simple os.Exec over using go-git
        cmd := exec.Command("git", "config", "--get", fmt.Sprintf("remote.%s.url", remote))
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">remoteURL := strings.TrimSpace(string(out))
        repoName := strings.TrimSuffix(filepath.Base(remoteURL), ".git")
        return repoName, nil</span>
}

func GetAllLfsFiles(gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) (map[string]LfsFileInfo, error) <span class="cov7" title="4">{
        if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger is required")
        }</span>
        <span class="cov7" title="4">repoDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // no timeout for now
        <span class="cov7" title="4">ctx := context.Background()
        // If needed, can re-enable timeout
        // Set a timeout context for git commands, 3 minutes should be enough
        //ctx, cancel := context.WithTimeout(context.Background(), 180*time.Second)
        //defer cancel()

        if gitRemoteName == "" </span><span class="cov0" title="0">{
                gitRemoteName = "origin"
        }</span>
        <span class="cov7" title="4">if gitRemoteLocation != "" </span><span class="cov7" title="4">{
                logger.Debug(fmt.Sprintf("Using git remote %s at %s for LFS dry-run", gitRemoteName, gitRemoteLocation))
        }</span> else<span class="cov0" title="0"> {
                logger.Debug(fmt.Sprintf("Using git remote %s for LFS dry-run", gitRemoteName))
        }</span>

        <span class="cov7" title="4">refs := buildRefs(branches)
        lfsFileMap := make(map[string]LfsFileInfo)
        for _, ref := range refs </span><span class="cov7" title="4">{
                spec := DryRunSpec{
                        Remote: gitRemoteName,
                        Ref:    ref,
                }
                out, err := RunPushDryRun(ctx, repoDir, spec, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov7" title="4">if err := addFilesFromDryRun(out, repoDir, logger, lfsFileMap); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov7" title="4">return lfsFileMap, nil</span>
}

func buildRefs(branches []string) []string <span class="cov7" title="4">{
        if len(branches) == 0 </span><span class="cov0" title="0">{
                return []string{"HEAD"}
        }</span>
        <span class="cov7" title="4">refs := make([]string, 0, len(branches))
        seen := make(map[string]struct{})
        for _, branch := range branches </span><span class="cov7" title="4">{
                branch = strings.TrimSpace(branch)
                if branch == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="4">ref := branch
                if branch != "HEAD" &amp;&amp; !strings.HasPrefix(branch, "refs/") </span><span class="cov7" title="4">{
                        ref = fmt.Sprintf("refs/heads/%s", branch)
                }</span>
                <span class="cov7" title="4">if _, ok := seen[ref]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="4">seen[ref] = struct{}{}
                refs = append(refs, ref)</span>
        }
        <span class="cov7" title="4">if len(refs) == 0 </span><span class="cov0" title="0">{
                return []string{"HEAD"}
        }</span>
        <span class="cov7" title="4">return refs</span>
}

func addFilesFromDryRun(out, repoDir string, logger *slog.Logger, lfsFileMap map[string]LfsFileInfo) error <span class="cov7" title="4">{
        // Log when dry-run returns no output to help with debugging
        if strings.TrimSpace(out) == "" </span><span class="cov0" title="0">{
                logger.Debug("No LFS files to push (dry-run returned no output)")
                return nil
        }</span>

        // accept lowercase or uppercase hex
        <span class="cov7" title="4">sha256Re := regexp.MustCompile(`(?i)^[a-f0-9]{64}$`)

        for _, line := range strings.Split(strings.TrimSpace(string(out)), "\n") </span><span class="cov10" title="6">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="6">parts := strings.Fields(line)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="6">oid := parts[1]
                path := parts[len(parts)-1]

                // Validate OID looks like a SHA256 hex string.
                if !sha256Re.MatchString(oid) </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("skipping LFS line with invalid oid %q: %q", oid, line))
                        continue</span>
                }

                // see https://github.com/calypr/git-drs/issues/124#issuecomment-3721837089
                <span class="cov10" title="6">if oid == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" &amp;&amp; strings.Contains(path, ".gitattributes") </span><span class="cov4" title="2">{
                        logger.Debug(fmt.Sprintf("skipping empty LFS pointer for %s", path))
                        continue</span>
                }
                // Remove a trailing parenthetical suffix from p, e.g.:
                // "path/to/file.dat (100 KB)" -&gt; "path/to/file.dat"
                <span class="cov7" title="4">if idx := strings.LastIndex(path, " ("); idx != -1 &amp;&amp; strings.HasSuffix(path, ")") </span><span class="cov0" title="0">{
                        path = strings.TrimSpace(path[:idx])
                }</span>
                <span class="cov7" title="4">size := int64(0)
                absPath := path
                if repoDir != "" &amp;&amp; !filepath.IsAbs(path) </span><span class="cov7" title="4">{
                        absPath = filepath.Join(repoDir, path)
                }</span>
                <span class="cov7" title="4">if stat, err := os.Stat(absPath); err == nil </span><span class="cov7" title="4">{
                        size = stat.Size()
                }</span> else<span class="cov0" title="0"> {
                        logger.Error(fmt.Sprintf("could not stat file %s: %v", path, err))
                        continue</span>
                }

                // If the file is small, read it and detect LFS pointer signature.
                // Pointer files are textual and include the LFS spec version + an oid line.
                <span class="cov7" title="4">if size &gt; 0 &amp;&amp; size &lt; 2048 </span><span class="cov4" title="2">{
                        if data, readErr := os.ReadFile(absPath); readErr == nil </span><span class="cov4" title="2">{
                                s := strings.TrimSpace(string(data))
                                if strings.Contains(s, "version https://git-lfs.github.com/spec/v1") &amp;&amp; strings.Contains(s, "oid sha256:") </span><span class="cov0" title="0">{
                                        logger.Warn(fmt.Sprintf("WARNING: Detected upload of lfs pointer file %s skipping", path))
                                        continue</span>
                                }
                        }
                }

                <span class="cov7" title="4">lfsFileMap[path] = LfsFileInfo{
                        Name:    path,
                        Size:    size,
                        OidType: "sha256",
                        Oid:     oid,
                        Version: "https://git-lfs.github.com/spec/v1",
                }</span>
                //logger.Printf("GetAllLfsFiles added LFS file %s", path)
        }

        <span class="cov7" title="4">return nil</span>
}

// CreateLfsPointer creates a Git LFS pointer file for the given DRS object.
func CreateLfsPointer(drsObj *drs.DRSObject, dst string) error <span class="cov6" title="3">{
        sumMap := hash.ConvertHashInfoToMap(drsObj.Checksums)
        if len(sumMap) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no checksums found for DRS object")
        }</span>

        // find sha256 checksum
        <span class="cov4" title="2">var shaSum string
        for csType, cs := range sumMap </span><span class="cov4" title="2">{
                if csType == hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                        shaSum = cs
                        break</span>
                }
        }
        <span class="cov4" title="2">if shaSum == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("no sha256 checksum found for DRS object")
        }</span>

        // create pointer file content
        <span class="cov1" title="1">pointerContent := "version https://git-lfs.github.com/spec/v1\n"
        pointerContent += fmt.Sprintf("oid sha256:%s\n", shaSum)
        pointerContent += fmt.Sprintf("size %d\n", drsObj.Size)

        // write to file
        err := os.WriteFile(dst, []byte(pointerContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write LFS pointer file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package store

import "github.com/calypr/git-drs/drs"

func ObjectPath(basePath string, oid string) (string, error) <span class="cov10" title="10">{
        store := drs.NewObjectStore(basePath, nil)
        return store.ObjectPath(oid)
}</span>

func WriteObject(basePath string, drsObj *drs.DRSObject, oid string) error <span class="cov10" title="10">{
        store := drs.NewObjectStore(basePath, nil)
        return store.WriteObject(drsObj, oid)
}</span>

func ReadObject(basePath string, oid string) (*drs.DRSObject, error) <span class="cov9" title="8">{
        store := drs.NewObjectStore(basePath, nil)
        return store.ReadObject(oid)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/cmd"
        "github.com/calypr/git-drs/drslog"
)

func main() <span class="cov10" title="46">{

        _, err := drslog.NewLogger("", true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open log file: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov10" title="46">if err := cmd.RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                drslog.Close() // closes log file if there was one
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package testutils

import (
        "os"
        "os/exec"
        "path/filepath"
        "testing"

        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/projectdir"
        "github.com/stretchr/testify/require"
        "gopkg.in/yaml.v3"
)

// SetupTestGitRepo creates a temp directory mocking a real git repo
func SetupTestGitRepo(t *testing.T) string <span class="cov10" title="2">{
        t.Helper()

        tmpDir, err := os.MkdirTemp("", "git-drs-test-*")
        require.NoError(t, err)

        originalDir, err := os.Getwd()
        require.NoError(t, err)

        err = os.Chdir(tmpDir)
        require.NoError(t, err)

        cmd := exec.Command("git", "init")
        cmd.Dir = tmpDir
        err = cmd.Run()
        require.NoError(t, err)

        cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        cmd = exec.Command("git", "config", "user.name", "Test User")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        t.Cleanup(func() </span><span class="cov10" title="2">{
                os.Chdir(originalDir)
                os.RemoveAll(tmpDir)
        }</span>)

        <span class="cov10" title="2">return tmpDir</span>
}

// CreateTestConfig creates a test Git DRS config file with the given content
func CreateTestConfig(t *testing.T, tmpDir string, cfg *config.Config) string <span class="cov0" title="0">{
        t.Helper()

        configDir := filepath.Join(tmpDir, projectdir.DRS_DIR)
        err := os.MkdirAll(configDir, 0755)
        require.NoError(t, err)

        configPath := filepath.Join(configDir, projectdir.CONFIG_YAML)
        file, err := os.Create(configPath)
        require.NoError(t, err)
        defer file.Close()

        encoder := yaml.NewEncoder(file)
        err = encoder.Encode(cfg)
        require.NoError(t, err)

        return configPath
}</span>

// CreateDefaultTestConfig creates a standard test configuration
func CreateDefaultTestConfig(t *testing.T, tmpDir string) *config.Config <span class="cov0" title="0">{
        t.Helper()

        testConfig := &amp;config.Config{
                Remotes: map[config.Remote]config.RemoteSelect{
                        config.Remote(config.ORIGIN): {
                                Gen3: &amp;indexd_client.Gen3Remote{
                                        Endpoint:  "https://test.gen3.org",
                                        ProjectID: "test-project",
                                        Bucket:    "test",
                                },
                        },
                },
        }

        CreateTestConfig(t, tmpDir, testConfig)
        return testConfig
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package testutils

import (
        "bytes"
        "io"
        "os"
        "testing"

        "github.com/stretchr/testify/require"
)

// CaptureStdout captures stdout during test execution
func CaptureStdout(t *testing.T, f func()) string <span class="cov10" title="5">{
        t.Helper()

        r, w, err := os.Pipe()
        require.NoError(t, err)

        oldStdout := os.Stdout
        os.Stdout = w

        defer func() </span><span class="cov10" title="5">{
                os.Stdout = oldStdout
        }</span>()

        <span class="cov10" title="5">outC := make(chan string)
        go func() </span><span class="cov10" title="5">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, r)
                outC &lt;- buf.String()
        }</span>()

        <span class="cov10" title="5">f()

        w.Close()
        output := &lt;-outC

        return output</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package lfs

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// UpsertDRSRouteLines adds or updates .gitattributes lines of the form:
//
//        &lt;pattern&gt; drs.route=&lt;ro|rw&gt;
//
// Returns changed=true if the file was modified.
func UpsertDRSRouteLines(gitattributesPath string, mode string, patterns []string) (changed bool, err error) <span class="cov5" title="5">{
        mode = strings.ToLower(strings.TrimSpace(mode))
        if mode != "ro" &amp;&amp; mode != "rw" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid mode %q", mode)
        }</span>

        // Normalize patterns (preserve original spelling except trim).
        <span class="cov5" title="5">want := make(map[string]string, len(patterns))
        order := make([]string, 0, len(patterns))
        for _, p := range patterns </span><span class="cov5" title="5">{
                p = strings.TrimSpace(p)
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="5">if _, ok := want[p]; !ok </span><span class="cov5" title="5">{
                        want[p] = p
                        order = append(order, p)
                }</span>
        }
        <span class="cov5" title="5">if len(order) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no patterns provided")
        }</span>

        // Read existing file if present.
        <span class="cov5" title="5">var lines []string
        data, readErr := os.ReadFile(gitattributesPath)
        if readErr == nil </span><span class="cov4" title="4">{
                sc := bufio.NewScanner(strings.NewReader(string(data)))
                for sc.Scan() </span><span class="cov7" title="9">{
                        lines = append(lines, sc.Text())
                }</span>
                <span class="cov4" title="4">if err := sc.Err(); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("read %s: %w", gitattributesPath, err)
                }</span>
        } else<span class="cov1" title="1"> if !os.IsNotExist(readErr) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("read %s: %w", gitattributesPath, readErr)
        }</span>

        // Build index of existing drs.route lines.
        // We match "pattern ... drs.route=&lt;x&gt;" in a whitespace-tolerant way, but only update
        // if the first token equals the pattern exactly.
        <span class="cov5" title="5">seen := make(map[string]int) // pattern -&gt; line index
        for i, line := range lines </span><span class="cov7" title="9">{
                pat, _, ok := parseRouteLine(line)
                if ok </span><span class="cov4" title="3">{
                        seen[pat] = i
                }</span>
        }

        // Apply upserts.
        <span class="cov5" title="5">for _, pat := range order </span><span class="cov5" title="5">{
                newLine := fmt.Sprintf("%s drs.route=%s", pat, mode)

                if idx, ok := seen[pat]; ok </span><span class="cov2" title="2">{
                        // Update only if different
                        if strings.TrimSpace(lines[idx]) != newLine </span><span class="cov1" title="1">{
                                lines[idx] = newLine
                                changed = true
                        }</span>
                } else<span class="cov4" title="3"> {
                        lines = append(lines, newLine)
                        changed = true
                }</span>
        }

        <span class="cov5" title="5">if !changed &amp;&amp; readErr == nil </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        // Ensure directory exists (it should, but be safe).
        <span class="cov4" title="4">if err := os.MkdirAll(filepath.Dir(gitattributesPath), 0o755); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("mkdir %s: %w", filepath.Dir(gitattributesPath), err)
        }</span>

        // Write back with trailing newline.
        <span class="cov4" title="4">out := strings.Join(lines, "\n")
        if !strings.HasSuffix(out, "\n") </span><span class="cov4" title="4">{
                out += "\n"
        }</span>
        <span class="cov4" title="4">if err := os.WriteFile(gitattributesPath, []byte(out), 0o644); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("write %s: %w", gitattributesPath, err)
        }</span>
        <span class="cov4" title="4">return true, nil</span>
}

// parseRouteLine returns (pattern, mode, ok) for lines like:
//
//        scratch/** drs.route=rw
//
// It ignores comments and blank lines.
func parseRouteLine(line string) (pattern string, mode string, ok bool) <span class="cov7" title="10">{
        s := strings.TrimSpace(line)
        if s == "" || strings.HasPrefix(s, "#") </span><span class="cov1" title="1">{
                return "", "", false
        }</span>

        // Tokenize by whitespace.
        <span class="cov7" title="9">parts := strings.Fields(s)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return "", "", false
        }</span>

        <span class="cov7" title="9">pat := parts[0]
        for _, tok := range parts[1:] </span><span class="cov10" title="24">{
                if strings.HasPrefix(tok, "drs.route=") </span><span class="cov4" title="4">{
                        val := strings.TrimPrefix(tok, "drs.route=")
                        val = strings.ToLower(strings.TrimSpace(val))
                        if val == "ro" || val == "rw" </span><span class="cov4" title="4">{
                                return pat, val, true
                        }</span>
                        // present but invalid -&gt; treat as not-ok to avoid fixing unknown formats silently
                        <span class="cov0" title="0">return "", "", false</span>
                }
        }
        <span class="cov5" title="5">return "", "", false</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package lfs

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/calypr/git-drs/utils"
)

// runGitAllowMissing treats "key not found" as empty output, not an error.
func runGitAllowMissing(ctx context.Context, args ...string) (string, error) <span class="cov8" title="7">{
        cmd := exec.CommandContext(ctx, "git", args...)
        b, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov6" title="4">{
                // "git config --get missing.key" exits 1 with empty output.
                s := strings.TrimSpace(string(b))
                if s == "" </span><span class="cov6" title="4">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("%v: %s", err, s)</span>
        }
        <span class="cov5" title="3">return string(b), nil</span>
}

// resolveLFSRoot implements:
// - if `git config --get lfs.storage` is set: use it
//   - if relative: resolve relative to GitCommonDir (this is how git-lfs treats it in practice)
//
// - else: &lt;GitCommonDir&gt;/lfs
func resolveLFSRoot(ctx context.Context, gitCommonDir string) (string, error) <span class="cov8" title="7">{
        // NOTE: git config --get returns exit status 1 if key not found.
        out, err := runGitAllowMissing(ctx, "config", "--get", "lfs.storage")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git config --get lfs.storage failed: %w", err)
        }</span>
        <span class="cov8" title="7">val := strings.TrimSpace(out)

        if val == "" </span><span class="cov6" title="4">{
                return filepath.Clean(filepath.Join(gitCommonDir, "lfs")), nil
        }</span>

        // Expand ~ if present (nice-to-have).
        <span class="cov5" title="3">if strings.HasPrefix(val, "~") &amp;&amp; (len(val) == 1 || val[1] == '/' || val[1] == '\\') </span><span class="cov1" title="1">{
                home, herr := userHomeDir()
                if herr == nil &amp;&amp; home != "" </span><span class="cov1" title="1">{
                        val = filepath.Join(home, strings.TrimPrefix(val, "~"))
                }</span>
        }

        <span class="cov5" title="3">if !filepath.IsAbs(val) </span><span class="cov1" title="1">{
                val = filepath.Join(gitCommonDir, val)
        }</span>
        <span class="cov5" title="3">return filepath.Clean(val), nil</span>
}

func runGit(ctx context.Context, args ...string) (string, error) <span class="cov10" title="9">{
        cmd := exec.CommandContext(ctx, "git", args...)
        b, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%v: %s", err, strings.TrimSpace(string(b)))
        }</span>
        <span class="cov10" title="9">return string(b), nil</span>
}

func userHomeDir() (string, error) <span class="cov1" title="1">{
        // Avoid os/user on some cross-compile scenarios; keep it simple.
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Not your target, but safe fallback.
                return "", errors.New("home expansion not supported on windows in this helper")
        }</span>
        <span class="cov1" title="1">if home := strings.TrimSpace(os.Getenv("HOME")); home != "" </span><span class="cov1" title="1">{
                return home, nil
        }</span>
        // macOS/Linux
        <span class="cov0" title="0">out, err := exec.Command("sh", "-lc", "printf %s \"$HOME\"").CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}

func GetGitAttribute(ctx context.Context, attr string, path string) (string, error) <span class="cov0" title="0">{
        out, err := runGit(ctx, "check-attr", attr, "--", path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git check-attr failed: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

//
// --- Git helpers ---
//

func GitLFSTrack(ctx context.Context, path string) (bool, error) <span class="cov3" title="2">{
        out, err := runGit(ctx, "lfs", "track", path)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("git lfs track failed: %w", err)
        }</span>
        <span class="cov3" title="2">return strings.Contains(out, path), nil</span>
}

func GitLFSTrackReadOnly(ctx context.Context, path string) (bool, error) <span class="cov3" title="2">{
        _, err := GitLFSTrack(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("git lfs track failed: %w", err)
        }</span>

        <span class="cov3" title="2">repoRoot, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="2">attrPath := filepath.Join(repoRoot, ".gitattributes")
        changed, err := UpsertDRSRouteLines(attrPath, "ro", []string{path})
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="2">return changed, nil</span>
}

func gitRevParseGitCommonDir(ctx context.Context) (string, error) <span class="cov8" title="7">{
        out, err := runGit(ctx, "rev-parse", "--git-common-dir")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git rev-parse --git-common-dir failed: %w", err)
        }</span>
        <span class="cov8" title="7">dir := strings.TrimSpace(out)
        if dir == "" </span><span class="cov0" title="0">{
                return "", errors.New("git rev-parse returned empty --git-common-dir")
        }</span>
        // If relative, resolve it against current working directory.
        <span class="cov8" title="7">if !filepath.IsAbs(dir) </span><span class="cov8" title="7">{
                abs, err := filepath.Abs(dir)
                if err == nil </span><span class="cov8" title="7">{
                        dir = abs
                }</span>
        }
        <span class="cov8" title="7">return dir, nil</span>
}

// GetGitRootDirectories
// returns (gitCommonDir, lfsRoot, error).
func GetGitRootDirectories(ctx context.Context) (string, string, error) <span class="cov5" title="3">{
        gitCommonDir, err := gitRevParseGitCommonDir(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov5" title="3">lfsRoot, err := resolveLFSRoot(ctx, gitCommonDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov5" title="3">if lfsRoot == "" </span><span class="cov0" title="0">{
                lfsRoot = filepath.Join(gitCommonDir, "lfs")
        }</span>
        <span class="cov5" title="3">return gitCommonDir, lfsRoot, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package lfs

import (
        "bytes"
        "fmt"
        "os/exec"
        "path/filepath"
        "strings"
)

// IsLFSTracked returns true if the given path is tracked by Git LFS
// (i.e. has `filter=lfs` via git attributes).
func IsLFSTracked(path string) (bool, error) <span class="cov10" title="4">{
        if path == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("path is empty")
        }</span>

        // Git prefers forward slashes, even on macOS/Linux
        <span class="cov10" title="4">cleanPath := filepath.ToSlash(path)

        cmd := exec.Command(
                "git",
                "check-attr",
                "filter",
                "--",
                cleanPath,
        )

        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;out

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("git check-attr failed: %w (%s)", err, out.String())
        }</span>

        // Expected output:
        // path: filter: lfs
        // path: filter: unspecified
        //
        // Format is stable and documented.
        <span class="cov10" title="4">fields := strings.Split(out.String(), ":")
        if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov10" title="4">value := strings.TrimSpace(fields[2])
        return value == "lfs", nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package lfs

import (
        "github.com/bytedance/sonic/encoder"
)

// InitMessage represents the structure of the initiation data
type InitMessage struct {
        Event               string `json:"event"`               // Always "init" to identify this message
        Operation           string `json:"operation"`           // "upload" or "download" depending on transfer direction
        Remote              string `json:"remote"`              // Git remote name or URL
        Concurrent          bool   `json:"concurrent"`          // Reflects lfs.customtransfer.&lt;name&gt;.concurrent
        ConcurrentTransfers int    `json:"concurrenttransfers"` // Reflects lfs.concurrenttransfers value
}

// CompleteMessage is a minimal response to signal transfer is "complete"
type CompleteMessage struct {
        Event string `json:"event"`
        Oid   string `json:"oid"`
        Path  string `json:"path,omitempty"`
}

// UploadMessage represents a request to upload an object.
type UploadMessage struct {
        Event  string  `json:"event"`  // "upload"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Path   string  `json:"path"`   // Local path to file
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
}

// DownloadMessage represents a request to download an object.
type DownloadMessage struct {
        Event  string  `json:"event"`  // "download"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
        Path   string  `json:"path"`   // Where to store the downloaded file
}

// TerminateMessage is sent when the agent should terminate.
type TerminateMessage struct {
        Event string `json:"event"` // "terminate"
}

// ErrorMessage is sent when an error occurs during a transfer.
type ErrorMessage struct {
        Event string `json:"event"` // "error"
        Oid   string `json:"oid"`   // Object ID involved in the error
        Error Error  `json:"error"` // Error details
}

type InitErrorMessage struct {
        Error Error `json:"error"` // Error details
}

type Error struct {
        Code    int    `json:"code"`    // Error code (standard or custom)
        Message string `json:"message"` // Human-readable error message
}

// ProgressResponse provides progress updates for an object transfer.
type ProgressResponse struct {
        Event          string `json:"event"`          // "progress"
        Oid            string `json:"oid"`            // Object ID being transferred
        BytesSoFar     int64  `json:"bytesSoFar"`     // Bytes transferred so far
        BytesSinceLast int64  `json:"bytesSinceLast"` // Bytes transferred since last progress message
}

// TerminateResponse signals the agent has completed termination.
type TerminateResponse struct {
        Event string `json:"event"` // "terminate"
}

// Action is an optional struct representing transfer actions (upload/download URLs, etc.)
type Action struct {
        Href      string            `json:"href"`
        Header    map[string]string `json:"header,omitempty"`
        ExpiresIn int               `json:"expires_in,omitempty"`
}

func WriteInitErrorMessage(encoder *encoder.StreamEncoder, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := InitErrorMessage{
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteErrorMessage(encoder *encoder.StreamEncoder, oid string, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := ErrorMessage{
                Event: "complete",
                Oid:   oid,
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteCompleteMessage(encoder *encoder.StreamEncoder, oid string, path string) <span class="cov10" title="9">{
        // create success message and send it back
        completeResponse := CompleteMessage{
                Event: "complete",
                Oid:   oid,
                Path:  path,
        }
        encoder.Encode(completeResponse)
}</span>

func WriteProgressMessage(encoder *encoder.StreamEncoder, oid string, bytesSoFar int64, bytesSinceLast int64) <span class="cov8" title="7">{
        progressResponse := ProgressResponse{
                Event:          "progress",
                Oid:            oid,
                BytesSoFar:     bytesSoFar,
                BytesSinceLast: bytesSinceLast,
        }
        encoder.Encode(progressResponse)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// helpers for pre-push (reading .git/drs/pre-commit cache)
// ---------------------------------------------------------
// LFS-only local cache readers for pre-push validation.
//
// These helpers expose NON-AUTHORITATIVE hints recorded by pre-commit.
// Pre-push is expected to resolve truth via Indexd / DRS and compare.
//
// Cache layout (per ADR):
//   .git/drs/pre-commit/v1/paths/&lt;encoded-path&gt;.json   (Path -&gt; OID)
//   .git/drs/pre-commit/v1/oids/&lt;oid-hash&gt;.json        (OID -&gt; paths[] + external_url hint)
//
// NOTE:
// OID files are named by sha256(oid string), not the raw oid.
// These helpers reproduce that mapping exactly.

package precommit_cache

import (
        "context"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io/fs"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

const (
        cacheVersionDir = "drs/pre-commit/v1"
)

type PathEntry struct {
        Path      string `json:"path"`
        LFSOID    string `json:"lfs_oid"`
        UpdatedAt string `json:"updated_at"`
}

type OIDEntry struct {
        LFSOID        string   `json:"lfs_oid"`
        Paths         []string `json:"paths"`
        ExternalURL   string   `json:"external_url,omitempty"` // non-authoritative hint
        UpdatedAt     string   `json:"updated_at"`
        ContentChange bool     `json:"content_changed"`
}

// Cache provides read-only access to .git/drs/pre-commit cache.
type Cache struct {
        GitDir    string
        Root      string
        PathsDir  string
        OIDsDir   string
        StatePath string
}

func Open(ctx context.Context) (*Cache, error) <span class="cov0" title="0">{
        gitDir, err := gitRevParseGitDir(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">root := filepath.Join(gitDir, cacheVersionDir)
        return &amp;Cache{
                GitDir:    gitDir,
                Root:      root,
                PathsDir:  filepath.Join(root, "paths"),
                OIDsDir:   filepath.Join(root, "oids"),
                StatePath: filepath.Join(root, "state.json"),
        }, nil</span>
}

//
// Primary lookup helpers
//

// LookupOIDByPath returns the cached LFS OID for a repo-relative path.
func (c *Cache) LookupOIDByPath(path string) (string, bool, error) <span class="cov0" title="0">{
        pe, ok, err := c.ReadPathEntry(path)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return "", ok, err
        }</span>
        <span class="cov0" title="0">if pe.LFSOID == "" </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>
        <span class="cov0" title="0">return pe.LFSOID, true, nil</span>
}

// LookupPathsByOID returns advisory paths that recently referenced this OID.
func (c *Cache) LookupPathsByOID(oid string) ([]string, bool, error) <span class="cov0" title="0">{
        oe, ok, err := c.ReadOIDEntry(oid)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return nil, ok, err
        }</span>
        <span class="cov0" title="0">paths := append([]string(nil), oe.Paths...)
        sort.Strings(paths)
        return paths, true, nil</span>
}

// LookupExternalURLByOID returns the cached external URL hint (if any).
// Returns ("", false, nil) if the OID entry is missing OR the hint is empty.
func (c *Cache) LookupExternalURLByOID(oid string) (string, bool, error) <span class="cov0" title="0">{
        oe, ok, err := c.ReadOIDEntry(oid)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return "", ok, err
        }</span>
        <span class="cov0" title="0">u := strings.TrimSpace(oe.ExternalURL)
        if u == "" </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>
        <span class="cov0" title="0">return u, true, nil</span>
}

// ResolveExternalURLByPath maps:
//
//        path -&gt; oid -&gt; external_url (hint)
//
// Returns ("", false, nil) if any step is missing.
func (c *Cache) ResolveExternalURLByPath(path string) (string, bool, error) <span class="cov0" title="0">{
        oid, ok, err := c.LookupOIDByPath(path)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov0" title="0">return c.LookupExternalURLByOID(oid)</span>
}

//
// Lower-level file access
//

func (c *Cache) ReadPathEntry(path string) (*PathEntry, bool, error) <span class="cov0" title="0">{
        f := c.pathEntryFile(path)
        b, err := os.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov0" title="0">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("read path entry %q: %w", f, err)</span>
        }
        <span class="cov0" title="0">var pe PathEntry
        if err := json.Unmarshal(b, &amp;pe); err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("parse path entry %q: %w", f, err)
        }</span>
        <span class="cov0" title="0">return &amp;pe, true, nil</span>
}

func (c *Cache) ReadOIDEntry(oid string) (*OIDEntry, bool, error) <span class="cov0" title="0">{
        f := c.oidEntryFile(oid)
        b, err := os.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov0" title="0">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("read oid entry %q: %w", f, err)</span>
        }
        <span class="cov0" title="0">var oe OIDEntry
        if err := json.Unmarshal(b, &amp;oe); err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("parse oid entry %q: %w", f, err)
        }</span>
        <span class="cov0" title="0">return &amp;oe, true, nil</span>
}

//
// Validation helpers (optional)
//

// CheckExternalURLMismatch compares a cached external URL hint against an authoritative URL.
func CheckExternalURLMismatch(localHint, authoritative string) error <span class="cov0" title="0">{
        l := strings.TrimSpace(localHint)
        a := strings.TrimSpace(authoritative)
        if l == "" || a == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if l != a </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "external URL mismatch: cache=%q authoritative=%q",
                        l, a,
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// StaleAfter reports whether a cache timestamp is older than maxAge.
func StaleAfter(updatedAt string, maxAge time.Duration) bool <span class="cov0" title="0">{
        t, err := time.Parse(time.RFC3339, updatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return time.Since(t) &gt; maxAge</span>
}

//
// Filename / encoding helpers
//

func (c *Cache) pathEntryFile(path string) string <span class="cov0" title="0">{
        return filepath.Join(c.PathsDir, EncodePath(path)+".json")
}</span>

func (c *Cache) oidEntryFile(oid string) string <span class="cov0" title="0">{
        sum := sha256.Sum256([]byte(oid))
        return filepath.Join(c.OIDsDir, fmt.Sprintf("%x.json", sum[:]))
}</span>

func EncodePath(path string) string <span class="cov0" title="0">{
        return base64.RawURLEncoding.EncodeToString([]byte(path))
}</span>

func DecodePath(encoded string) (string, error) <span class="cov0" title="0">{
        b, err := base64.RawURLEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(b), nil</span>
}

//
// Git helpers
//

func gitRevParseGitDir(ctx context.Context) (string, error) <span class="cov0" title="0">{
        out, err := git(ctx, "rev-parse", "--git-dir")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">gitDir := strings.TrimSpace(string(out))
        if gitDir == "" </span><span class="cov0" title="0">{
                return "", errors.New("could not determine .git dir")
        }</span>
        <span class="cov0" title="0">if !filepath.IsAbs(gitDir) </span><span class="cov0" title="0">{
                rootOut, err := git(ctx, "rev-parse", "--show-toplevel")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">root := strings.TrimSpace(string(rootOut))
                gitDir = filepath.Join(root, gitDir)</span>
        }
        <span class="cov0" title="0">return gitDir, nil</span>
}

func git(ctx context.Context, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Env = os.Environ()
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "git %s: %s",
                        strings.Join(args, " "),
                        strings.TrimSpace(string(out)),
                )
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Creates directories from stdin lines, each with 16 `sub-directory-N` subfolders, each containing 1001000 files of 1 KiB whose contents are the relative file path. Save as `generate-fixtures.go`.

package main

import (
        "bufio"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

const (
        minSubDirs = 1
        maxSubDirs = 6

        minFilesPerSub = 100
        maxFilesPerSub = 1000

        fileSizeBytes = 1024
)

// main reads directory names from stdin (one per line) and creates a set of
// "fixture" directories and files for each input name. For each top-level
// directory it creates between minSubDirs and maxSubDirs subdirectories
// named "sub-directory-N". Each subdirectory receives between minFilesPerSub
// and maxFilesPerSub files. File contents are written as the relative path
// bytes. The program prints progress and errors to stderr and exits with a
// non-zero code on read errors or when no input is provided.
func main() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())

        // Flags: if &gt;0 they override randomness
        numSubdirsFlag := flag.Int("number-of-subdirectories", 0, "fixed number of subdirectories per top-level directory (overrides random)")
        numFilesFlag := flag.Int("number-of-files", 0, "fixed number of files per subdirectory (overrides random)")
        flag.Parse()

        scanner := bufio.NewScanner(os.Stdin)
        entries := []string{}
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">entries = append(entries, line)</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "reading stdin: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "no input lines; provide one directory name per line on stdin")
                os.Exit(1)
        }</span>

        // Determine digits for file name padding based on configured or default max
        <span class="cov0" title="0">maxFilesConsidered := maxFilesPerSub
        if *numFilesFlag &gt; 0 &amp;&amp; *numFilesFlag &gt; maxFilesConsidered </span><span class="cov0" title="0">{
                maxFilesConsidered = *numFilesFlag
        }</span>
        <span class="cov0" title="0">maxFilesDigits := len(strconv.Itoa(maxFilesConsidered))

        for _, name := range entries </span><span class="cov0" title="0">{
                // Clean the path and disallow absolute paths for safety
                clean := filepath.Clean(name)
                if filepath.IsAbs(clean) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping absolute path: %s\n", name)
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(clean, ".."+string(os.PathSeparator)) || clean == ".." </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping path outside current tree: %s\n", name)
                        continue</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(clean, 0o755); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", clean, err)
                        continue</span>
                }

                // Choose number of subdirectories
                <span class="cov0" title="0">var nSub int
                if *numSubdirsFlag &gt; 0 </span><span class="cov0" title="0">{
                        if *numSubdirsFlag &lt; 1 </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "invalid --number-of-subdirectories: %d (must be &gt;= 1)\n", *numSubdirsFlag)
                                continue</span>
                        }
                        <span class="cov0" title="0">nSub = *numSubdirsFlag</span>
                } else<span class="cov0" title="0"> {
                        nSub = rand.Intn(maxSubDirs-minSubDirs+1) + minSubDirs
                }</span>

                <span class="cov0" title="0">for si := 1; si &lt;= nSub; si++ </span><span class="cov0" title="0">{
                        subdir := filepath.Join(clean, fmt.Sprintf("sub-directory-%d", si))
                        if err := os.MkdirAll(subdir, 0o755); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", subdir, err)
                                continue</span>
                        }

                        // Choose number of files per subdirectory
                        <span class="cov0" title="0">var nFiles int
                        if *numFilesFlag &gt; 0 </span><span class="cov0" title="0">{
                                if *numFilesFlag &lt; 1 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "invalid --number-of-files: %d (must be &gt;= 1)\n", *numFilesFlag)
                                        continue</span>
                                }
                                <span class="cov0" title="0">nFiles = *numFilesFlag</span>
                        } else<span class="cov0" title="0"> {
                                nFiles = rand.Intn(maxFilesPerSub-minFilesPerSub+1) + minFilesPerSub
                        }</span>

                        <span class="cov0" title="0">for fi := 1; fi &lt;= nFiles; fi++ </span><span class="cov0" title="0">{
                                filename := fmt.Sprintf("file-%0*d.dat", maxFilesDigits, fi)
                                path := filepath.Join(subdir, filename)
                                pathBytes := []byte(path)
                                if err := os.WriteFile(path, pathBytes, 0o644); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "write %s: %v\n", path, err)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "created %d files in %s\n", nFiles, subdir)</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "done: %s (%d subdirs)\n", clean, nSub)</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package utils

import (
        "fmt"
        "strings"
)

const (
        DRS_DIR = ".git/drs"
)

func ProjectToResource(project string) (string, error) <span class="cov10" title="22">{
        if !strings.Contains(project, "-") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error: invalid project ID %s in config file, ID should look like &lt;program&gt;-&lt;project&gt;", project)
        }</span>
        <span class="cov9" title="21">projectIdArr := strings.SplitN(project, "-", 2)
        return "/programs/" + projectIdArr[0] + "/projects/" + projectIdArr[1], nil</span>
}

// AddUnique appends items from 'toAdd' to 'existing' only if they're not already present.
// Returns the updated slice with unique items.
func AddUnique[T comparable](existing []T, toAdd []T) []T <span class="cov4" title="3">{
        // seen map uses struct{} as the value for memory efficiency
        seen := make(map[T]struct{}, len(existing))

        // Populate the set with existing items
        for _, item := range existing </span><span class="cov5" title="4">{
                seen[item] = struct{}{}
        }</span>

        <span class="cov4" title="3">for _, item := range toAdd </span><span class="cov5" title="4">{
                // check if item not yet in the set
                if _, found := seen[item]; !found </span><span class="cov3" title="2">{
                        existing = append(existing, item)
                        // Add the new unique item to the set
                        seen[item] = struct{}{}
                }</span>
        }
        <span class="cov4" title="3">return existing</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
)

const (
        // ConfirmationYes is the string users must type to confirm destructive operations
        ConfirmationYes = "yes"
)

// PromptForConfirmation displays a prompt and reads user input to confirm an operation.
// Returns nil if the response matches expectedResponse, error otherwise.
// If caseSensitive is false, comparison is case-insensitive.
func PromptForConfirmation(w io.Writer, prompt string, expectedResponse string, caseSensitive bool) error <span class="cov10" title="2">{
        fmt.Fprintf(w, "%s: ", prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading confirmation: %v", err)
        }</span>

        <span class="cov10" title="2">response = strings.TrimSpace(response)
        if !caseSensitive </span><span class="cov1" title="1">{
                response = strings.ToLower(response)
                expectedResponse = strings.ToLower(expectedResponse)
        }</span>

        <span class="cov10" title="2">if response != expectedResponse </span><span class="cov1" title="1">{
                return fmt.Errorf("operation cancelled: confirmation did not match")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DisplayWarningHeader writes a formatted warning header to the writer
func DisplayWarningHeader(w io.Writer, operation string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\n  WARNING: You are about to %s\n\n", operation)
}</span>

// DisplayField writes a formatted key-value field to the writer
func DisplayField(w io.Writer, key, value string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "%-11s %s\n", key+":", value)
}</span>

// DisplayFooter writes the standard "cannot be undone" footer to the writer
func DisplayFooter(w io.Writer) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\nThis action CANNOT be undone.\n\n")
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// GitAttribute represents a single line in .gitattributes file
type GitAttribute struct {
        Pattern    string
        Attributes map[string]string
}

// ParseGitAttributes parses the content of a .gitattributes file
func ParseGitAttributes(content string) ([]GitAttribute, error) <span class="cov5" title="26">{
        var attributes []GitAttribute
        scanner := bufio.NewScanner(strings.NewReader(content))

        for scanner.Scan() </span><span class="cov9" title="263">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov7" title="108">{
                        continue</span>
                }

                <span class="cov8" title="155">attr, err := parseLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed lines
                }

                <span class="cov8" title="155">attributes = append(attributes, attr)</span>
        }

        <span class="cov5" title="26">return attributes, scanner.Err()</span>
}

// parseLine parses a single line from .gitattributes
func parseLine(line string) (GitAttribute, error) <span class="cov8" title="155">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return GitAttribute{}, nil
        }</span>

        <span class="cov8" title="155">pattern := parts[0]
        attributes := make(map[string]string)

        for _, attr := range parts[1:] </span><span class="cov10" title="416">{
                if strings.Contains(attr, "=") </span><span class="cov9" title="284">{
                        // Handle key=value attributes
                        kv := strings.SplitN(attr, "=", 2)
                        attributes[kv[0]] = kv[1]
                }</span> else<span class="cov8" title="132"> if strings.HasPrefix(attr, "-") </span><span class="cov7" title="87">{
                        // Handle negated attributes (-attr)
                        attributes[attr[1:]] = "false"
                }</span> else<span class="cov6" title="45"> {
                        // Handle simple attributes (attr)
                        attributes[attr] = "true"
                }</span>
        }

        <span class="cov8" title="155">return GitAttribute{
                Pattern:    pattern,
                Attributes: attributes,
        }, nil</span>
}

func IsLFSTracked(gitattributesFilePath, filePath string) (bool, error) <span class="cov0" title="0">{
        gitattributesContent, err := os.ReadFile(gitattributesFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read .gitattributes file: %w", err)
        }</span>

        <span class="cov0" title="0">return isLFSTracked(string(gitattributesContent), filePath)</span>
}

// isLFSTracked determines if a given file path is tracked by Git LFS
func isLFSTracked(gitattributesContent string, filePath string) (bool, error) <span class="cov5" title="25">{
        attributes, err := ParseGitAttributes(gitattributesContent)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Process attributes in order, later rules override earlier ones
        <span class="cov5" title="25">isLFS := false

        for _, attr := range attributes </span><span class="cov7" title="107">{
                if matchesPattern(attr.Pattern, filePath) </span><span class="cov5" title="15">{
                        // Check for LFS attributes
                        if filter, exists := attr.Attributes["filter"]; exists </span><span class="cov4" title="13">{
                                return filter == "lfs", nil // Return immediately on filter match
                        }</span>
                }
        }

        <span class="cov4" title="12">return isLFS, nil</span>
}

// matchesPattern checks if a file path matches a gitattributes pattern
func matchesPattern(pattern, filePath string) bool <span class="cov8" title="125">{
        // Handle exact matches first
        if pattern == filePath </span><span class="cov2" title="3">{
                return true
        }</span>

        // Handle directory patterns ending with /
        <span class="cov8" title="122">if strings.HasSuffix(pattern, "/") </span><span class="cov2" title="2">{
                return strings.HasPrefix(filePath+"/", pattern)
        }</span>

        // Handle ** patterns (match any number of directories)
        <span class="cov8" title="120">if strings.Contains(pattern, "**") </span><span class="cov5" title="20">{
                return matchesDoubleStarPattern(pattern, filePath)
        }</span>

        // Handle patterns with explicit path separators
        <span class="cov7" title="100">if strings.Contains(pattern, "/") </span><span class="cov5" title="18">{
                // Pattern contains path separator, do full path matching
                matched, err := filepath.Match(pattern, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov5" title="18">return matched</span>
        }

        // For simple glob patterns without path separators (like *.bin),
        // only match against the filename, not the full path
        // filename := filepath.Base(filePath)
        <span class="cov7" title="82">matched, err := filepath.Match(pattern, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="82">return matched</span>
}

// matchesDoubleStarPattern handles ** patterns in gitattributes
func matchesDoubleStarPattern(pattern, filePath string) bool <span class="cov5" title="20">{
        // Handle ** patterns by splitting on ** and matching each part
        parts := strings.Split(pattern, "**")

        // If no ** found, fall back to regular matching
        if len(parts) == 1 </span><span class="cov0" title="0">{
                matched, err := filepath.Match(pattern, filePath)
                return err == nil &amp;&amp; matched
        }</span>

        // For patterns with **, we need to match each part
        // Example: "docs/**/*.pdf" becomes ["docs/", "/*.pdf"]
        // Example: "**/*.bin" becomes ["", "/*.bin"]

        <span class="cov5" title="20">currentPath := filePath

        for i, part := range parts </span><span class="cov5" title="27">{
                if part == "" </span><span class="cov2" title="2">{
                        continue</span> // Skip empty parts
                }

                <span class="cov5" title="25">if i == 0 </span><span class="cov5" title="18">{
                        // First part - must match the beginning
                        if strings.HasSuffix(part, "/") </span><span class="cov5" title="18">{
                                // Directory prefix
                                if !strings.HasPrefix(currentPath, part) </span><span class="cov4" title="13">{
                                        return false
                                }</span>
                                <span class="cov3" title="5">currentPath = currentPath[len(part):]</span>
                        } else<span class="cov0" title="0"> {
                                // File pattern at the beginning
                                matched, err := filepath.Match(part, currentPath)
                                return err == nil &amp;&amp; matched
                        }</span>
                } else<span class="cov3" title="7"> if i == len(parts)-1 </span><span class="cov3" title="7">{
                        // Last part - must match the end or remaining path
                        part = strings.TrimPrefix(part, "/")

                        // For the last part, try to match against the filename or remaining path
                        if strings.Contains(part, "/") </span><span class="cov0" title="0">{
                                // Pattern has path components, match against remaining path
                                matched, err := filepath.Match(part, currentPath)
                                return err == nil &amp;&amp; matched
                        }</span> else<span class="cov3" title="7"> {
                                // Simple filename pattern, match against just the filename
                                filename := filepath.Base(currentPath)
                                matched, err := filepath.Match(part, filename)
                                return err == nil &amp;&amp; matched
                        }</span>
                }
                // Middle parts would be handled here if we had more complex patterns
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package utils

import (
        "fmt"
        "net/http"
        "net/url"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

func GitTopLevel() (string, error) <span class="cov9" title="65">{
        path, err := SimpleRun([]string{"git", "rev-parse", "--show-toplevel"})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="65">return strings.TrimSuffix(path, "\n"), nil</span>
}

func SimpleRun(cmds []string) (string, error) <span class="cov10" title="66">{
        exePath, err := exec.LookPath(cmds[0])
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("command not found: %s: %w", cmds[0], err)
        }</span>
        <span class="cov9" title="65">cmd := exec.Command(exePath, cmds[1:]...)
        cmdOut, err := cmd.Output()
        return string(cmdOut), err</span>
}

func DrsTopLevel() (string, error) <span class="cov0" title="0">{
        base, err := GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(base, DRS_DIR), nil</span>
}

// CanDownloadFile checks if a file can be downloaded from the given signed URL
// by issuing a ranged GET for a single byte to mimic HEAD behavior.
func CanDownloadFile(signedURL string) error <span class="cov3" title="4">{
        req, err := http.NewRequest("GET", signedURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov3" title="4">req.Header.Set("Range", "bytes=0-0")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while sending the request: %v", err)
        }</span>
        <span class="cov3" title="4">defer resp.Body.Close()

        if resp.StatusCode == http.StatusPartialContent || resp.StatusCode == http.StatusOK </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov2" title="2">return fmt.Errorf("failed to access file, HTTP status: %d", resp.StatusCode)</span>
}

func ParseEmailFromToken(tokenString string) (string, error) <span class="cov4" title="5">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode token in ParseEmailFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov3" title="4">context, ok := claims["context"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context' claim structure")
        }</span>
        <span class="cov3" title="3">user, ok := context["user"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user' claim structure")
        }</span>
        <span class="cov2" title="2">name, ok := user["name"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user.name' claim")
        }</span>
        <span class="cov1" title="1">return name, nil</span>
}

func ParseAPIEndpointFromToken(tokenString string) (string, error) <span class="cov5" title="7">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token in ParseAPIEndpointFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov5" title="7">issUrl, ok := claims["iss"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'iss' claim")
        }</span>
        <span class="cov4" title="6">parsedURL, err := url.Parse(issUrl)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov4" title="5">return fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host), nil</span>
}

func ParseS3URL(s3url string) (string, string, error) <span class="cov7" title="22">{
        s3Prefix := "s3://"
        if !strings.HasPrefix(s3url, s3Prefix) </span><span class="cov4" title="5">{
                return "", "", fmt.Errorf("S3 URL requires prefix 's3://': %s", s3url)
        }</span>
        <span class="cov7" title="17">trimmed := strings.TrimPrefix(s3url, s3Prefix)
        slashIndex := strings.Index(trimmed, "/")
        if slashIndex == -1 || slashIndex == len(trimmed)-1 </span><span class="cov3" title="4">{
                return "", "", fmt.Errorf("invalid S3 file URL: %s", s3url)
        }</span>
        <span class="cov6" title="13">return trimmed[:slashIndex], trimmed[slashIndex+1:], nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Package version reports the Git-DRS version.
package version

import "fmt"

// Build and version details
var (
        GitCommit   = ""
        GitBranch   = ""
        GitUpstream = ""
        BuildDate   = ""
        Version     = ""
)

var tpl = `git commit: %s
git branch: %s
git upstream: %s
build date: %s
version: %s`

// String formats a string with version details.
func String() string <span class="cov0" title="0">{
        return fmt.Sprintf(tpl, GitCommit, GitBranch, GitUpstream, BuildDate, Version)
}</span>

// LogFields logs build and version information to the given logger.
func LogFields() []any <span class="cov0" title="0">{
        return []any{
                "GitCommit", GitCommit,
                "GitBranch", GitBranch,
                "GitUpstream", GitUpstream,
                "BuildDate", BuildDate,
                "Version", Version,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
