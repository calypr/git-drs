
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anvil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/calypr/git-drs/client/anvil/anvil_client.go (0.0%)</option>
				
				<option value="file1">github.com/calypr/git-drs/client/anvil/remote.go (100.0%)</option>
				
				<option value="file2">github.com/calypr/git-drs/client/indexd/add_url.go (0.0%)</option>
				
				<option value="file3">github.com/calypr/git-drs/client/indexd/client.go (55.6%)</option>
				
				<option value="file4">github.com/calypr/git-drs/client/indexd/gen3_remote.go (90.9%)</option>
				
				<option value="file5">github.com/calypr/git-drs/client/indexd/register.go (79.3%)</option>
				
				<option value="file6">github.com/calypr/git-drs/client/tests/mock_types.go (0.0%)</option>
				
				<option value="file7">github.com/calypr/git-drs/cloud/agent_fetch_reader.go (42.4%)</option>
				
				<option value="file8">github.com/calypr/git-drs/cloud/download.go (75.0%)</option>
				
				<option value="file9">github.com/calypr/git-drs/cloud/downloader.go (71.4%)</option>
				
				<option value="file10">github.com/calypr/git-drs/cloud/inspect.go (81.3%)</option>
				
				<option value="file11">github.com/calypr/git-drs/cloud/s3.go (57.7%)</option>
				
				<option value="file12">github.com/calypr/git-drs/cloud/validate.go (100.0%)</option>
				
				<option value="file13">github.com/calypr/git-drs/cmd/addref/add-ref.go (36.2%)</option>
				
				<option value="file14">github.com/calypr/git-drs/cmd/addurl/cache.go (75.5%)</option>
				
				<option value="file15">github.com/calypr/git-drs/cmd/addurl/io.go (69.7%)</option>
				
				<option value="file16">github.com/calypr/git-drs/cmd/addurl/main.go (77.3%)</option>
				
				<option value="file17">github.com/calypr/git-drs/cmd/addurl/service.go (69.5%)</option>
				
				<option value="file18">github.com/calypr/git-drs/cmd/delete/main.go (24.4%)</option>
				
				<option value="file19">github.com/calypr/git-drs/cmd/deleteproject/main.go (4.3%)</option>
				
				<option value="file20">github.com/calypr/git-drs/cmd/fetch/main.go (78.3%)</option>
				
				<option value="file21">github.com/calypr/git-drs/cmd/initialize/main.go (77.9%)</option>
				
				<option value="file22">github.com/calypr/git-drs/cmd/precommit/main.go (67.0%)</option>
				
				<option value="file23">github.com/calypr/git-drs/cmd/prepush/main.go (76.6%)</option>
				
				<option value="file24">github.com/calypr/git-drs/cmd/push/main.go (54.2%)</option>
				
				<option value="file25">github.com/calypr/git-drs/cmd/query/main.go (37.5%)</option>
				
				<option value="file26">github.com/calypr/git-drs/cmd/remote/add/anvil.go (0.0%)</option>
				
				<option value="file27">github.com/calypr/git-drs/cmd/remote/add/gen3.go (57.6%)</option>
				
				<option value="file28">github.com/calypr/git-drs/cmd/remote/add/init.go (100.0%)</option>
				
				<option value="file29">github.com/calypr/git-drs/cmd/remote/list.go (78.6%)</option>
				
				<option value="file30">github.com/calypr/git-drs/cmd/remote/remove.go (88.9%)</option>
				
				<option value="file31">github.com/calypr/git-drs/cmd/remote/root.go (100.0%)</option>
				
				<option value="file32">github.com/calypr/git-drs/cmd/remote/set.go (20.0%)</option>
				
				<option value="file33">github.com/calypr/git-drs/cmd/root.go (100.0%)</option>
				
				<option value="file34">github.com/calypr/git-drs/cmd/transfer/main.go (50.7%)</option>
				
				<option value="file35">github.com/calypr/git-drs/cmd/transferref/main.go (0.0%)</option>
				
				<option value="file36">github.com/calypr/git-drs/cmd/version/main.go (57.9%)</option>
				
				<option value="file37">github.com/calypr/git-drs/common/common.go (100.0%)</option>
				
				<option value="file38">github.com/calypr/git-drs/common/confirmation.go (93.3%)</option>
				
				<option value="file39">github.com/calypr/git-drs/common/jwt.go (96.0%)</option>
				
				<option value="file40">github.com/calypr/git-drs/config/config.go (36.7%)</option>
				
				<option value="file41">github.com/calypr/git-drs/drslog/logger.go (75.2%)</option>
				
				<option value="file42">github.com/calypr/git-drs/drsmap/drs_map.go (36.3%)</option>
				
				<option value="file43">github.com/calypr/git-drs/git-drs.go (42.9%)</option>
				
				<option value="file44">github.com/calypr/git-drs/gitrepo/repo.go (73.8%)</option>
				
				<option value="file45">github.com/calypr/git-drs/internal/testutils/config.go (95.2%)</option>
				
				<option value="file46">github.com/calypr/git-drs/internal/testutils/output.go (100.0%)</option>
				
				<option value="file47">github.com/calypr/git-drs/internal/testutils/test_helpers.go (100.0%)</option>
				
				<option value="file48">github.com/calypr/git-drs/lfs/gitattributes.go (85.5%)</option>
				
				<option value="file49">github.com/calypr/git-drs/lfs/helpers.go (71.2%)</option>
				
				<option value="file50">github.com/calypr/git-drs/lfs/lfs.go (60.9%)</option>
				
				<option value="file51">github.com/calypr/git-drs/lfs/lfs_tracked.go (52.9%)</option>
				
				<option value="file52">github.com/calypr/git-drs/lfs/messages.go (100.0%)</option>
				
				<option value="file53">github.com/calypr/git-drs/lfs/store.go (78.4%)</option>
				
				<option value="file54">github.com/calypr/git-drs/lfs/util.go (80.0%)</option>
				
				<option value="file55">github.com/calypr/git-drs/precommit_cache/helpers.go (76.7%)</option>
				
				<option value="file56">github.com/calypr/git-drs/tests/monorepos/generate-fixtures.go (0.0%)</option>
				
				<option value="file57">github.com/calypr/git-drs/version/version.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anvil_client

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/bytedance/sonic"
        drs "github.com/calypr/data-client/drs"
        hash "github.com/calypr/data-client/hash"
        "golang.org/x/oauth2/google"
)

type AnvilClient struct {
        Endpoint string
        SConfig  sonic.API
}

func (an *AnvilClient) GetObject(ctx context.Context, objectID string) (*drs.DRSObject, error) <span class="cov0" title="0">{
        // get auth token
        token, err := GetAuthToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auth token: %w", err)
        }</span>

        <span class="cov0" title="0">reqBody := map[string]any{
                "url":    objectID,
                "fields": []string{"hashes", "size", "fileName"},
        }
        bodyBytes, err := an.SConfig.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", an.Endpoint, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, _ := io.ReadAll(resp.Body)
        if resp.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                // Try to extract error message
                var errResp map[string]any
                an.SConfig.Unmarshal(respBody, &amp;errResp)
                msg := fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(respBody))
                if m, ok := errResp["message"].(string); ok </span><span class="cov0" title="0">{
                        msg = m
                }</span>
                <span class="cov0" title="0">return &amp;drs.DRSObject{}, errors.New(msg)</span>
        }

        // Parse expected response
        // subset of ResourceMetadata
        // https://github.com/DataBiosphere/terra-drs-hub/blob/dev/common/openapi.yml#L123
        <span class="cov0" title="0">var parsed struct {
                Hashes   map[string]string `json:"hashes"`
                Size     int64             `json:"size"`
                FileName string            `json:"fileName"`
        }
        if err := an.SConfig.Unmarshal(respBody, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.DRSObject{
                SelfURI:   objectID,
                Id:        objectID,
                Checksums: hash.ConvertStringMapToHashInfo(parsed.Hashes),
                Size:      parsed.Size,
                Name:      parsed.FileName,
        }, nil</span>
}

// GetAuthToken fetches a Google Cloud authentication token using Application Default Credentials.
// The user must run `gcloud auth application-default login` before using this.
func GetAuthToken() (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        creds, err := google.FindDefaultCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">ts := creds.TokenSource
        token, err := ts.Token()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid() || token.AccessToken == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no token retrieved")
        }</span>

        <span class="cov0" title="0">return token.AccessToken, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package anvil_client

import (
        "fmt"
        "log/slog"

        "github.com/calypr/data-client/g3client"
        "github.com/calypr/git-drs/client"
)

// AnvilAuth holds authentication info for Anvil
type AnvilAuth struct {
        TerraProject string `yaml:"terra_project"`
}

// AnvilRemote holds Anvil remote config
type AnvilRemote struct {
        Endpoint string    `yaml:"endpoint"`
        Auth     AnvilAuth `yaml:",inline"`
}

func (s AnvilRemote) GetProjectId() string <span class="cov8" title="1">{
        return s.Auth.TerraProject
}</span>

func (s AnvilRemote) GetEndpoint() string <span class="cov8" title="1">{
        return s.Endpoint
}</span>

func (s AnvilRemote) GetBucketName() string <span class="cov8" title="1">{
        return ""
}</span>

func (s AnvilRemote) GetClient(remoteName string, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov8" title="1">{
        return nil, fmt.Errorf(("AnVIL Client needs to be implemented"))
        // return NewAnvilClient(s, logger)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package indexd

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "slices"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/fence"
        "github.com/calypr/data-client/hash"
        "github.com/calypr/data-client/indexd"
        "github.com/calypr/data-client/s3utils"
        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/messages"
)

// getBucketDetails fetches bucket details from Gen3 using data-client.
func (inc *GitDrsIdxdClient) getBucketDetails(ctx context.Context, bucket string, httpClient *http.Client) (*fence.S3Bucket, error) <span class="cov0" title="0">{
        return inc.G3.Fence().GetBucketDetails(ctx, bucket)
}</span>

// FetchS3MetadataWithBucketDetails fetches S3 metadata given bucket details.
func FetchS3MetadataWithBucketDetails(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, bucketDetails *fence.S3Bucket, s3Client *s3.Client, logger *slog.Logger) (int64, string, error) <span class="cov0" title="0">{
        bucket, key, err := cloud.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">if s3Client == nil </span><span class="cov0" title="0">{
                cfg, err := awsConfig.LoadDefaultConfig(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", fmt.Errorf("unable to load base AWS SDK config: %v. %s", err, messages.ADDURL_HELP_MSG)
                }</span>

                <span class="cov0" title="0">var configOptions []func(*awsConfig.LoadOptions) error
                if awsAccessKey != "" &amp;&amp; awsSecretKey != "" </span><span class="cov0" title="0">{
                        configOptions = append(configOptions,
                                awsConfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(awsAccessKey, awsSecretKey, "")),
                        )
                }</span>

                <span class="cov0" title="0">regionToUse := ""
                if region != "" </span><span class="cov0" title="0">{
                        regionToUse = region
                }</span> else<span class="cov0" title="0"> if bucketDetails != nil &amp;&amp; bucketDetails.Region != "" </span><span class="cov0" title="0">{
                        regionToUse = bucketDetails.Region
                }</span>
                <span class="cov0" title="0">if regionToUse != "" </span><span class="cov0" title="0">{
                        configOptions = append(configOptions, awsConfig.WithRegion(regionToUse))
                }</span>

                <span class="cov0" title="0">if len(configOptions) &gt; 0 </span><span class="cov0" title="0">{
                        cfg, err = awsConfig.LoadDefaultConfig(ctx, configOptions...)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, "", fmt.Errorf("unable to load AWS SDK config with overrides: %v. %s", err, messages.ADDURL_HELP_MSG)
                        }</span>
                }

                <span class="cov0" title="0">endpointToUse := ""
                if endpoint != "" </span><span class="cov0" title="0">{
                        endpointToUse = endpoint
                }</span> else<span class="cov0" title="0"> if bucketDetails != nil &amp;&amp; bucketDetails.EndpointURL != "" </span><span class="cov0" title="0">{
                        endpointToUse = bucketDetails.EndpointURL
                }</span>

                <span class="cov0" title="0">s3Client = s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov0" title="0">{
                        if endpointToUse != "" </span><span class="cov0" title="0">{
                                o.BaseEndpoint = aws.String(endpointToUse)
                        }</span>
                        <span class="cov0" title="0">o.UsePathStyle = true</span>
                })
        }

        <span class="cov0" title="0">input := &amp;s3.HeadObjectInput{
                Bucket: &amp;bucket,
                Key:    aws.String(key),
        }

        resp, err := s3Client.HeadObject(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to head object, %v", err)
        }</span>

        <span class="cov0" title="0">var contentLength int64
        if resp.ContentLength != nil </span><span class="cov0" title="0">{
                contentLength = *resp.ContentLength
        }</span>

        <span class="cov0" title="0">return contentLength, resp.LastModified.Format(time.RFC3339), nil</span>
}

func (inc *GitDrsIdxdClient) fetchS3Metadata(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, s3Client *s3.Client, httpClient *http.Client, logger *slog.Logger) (int64, string, error) <span class="cov0" title="0">{
        bucket, _, err := cloud.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">bucketDetails, err := inc.getBucketDetails(ctx, bucket, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("Warning: unable to get bucket details from Gen3: %v", err))
        }</span>

        <span class="cov0" title="0">return FetchS3MetadataWithBucketDetails(ctx, s3URL, awsAccessKey, awsSecretKey, region, endpoint, bucketDetails, s3Client, logger)</span>
}

func (inc *GitDrsIdxdClient) upsertIndexdRecord(ctx context.Context, url string, sha256 string, fileSize int64, logger *slog.Logger) (*drs.DRSObject, error) <span class="cov0" title="0">{
        projectId := inc.GetProjectId()
        uuid := drsmap.DrsUUID(projectId, sha256)

        records, err := inc.GetObjectByHash(ctx, &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: sha256})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying indexd server: %v", err)
        }</span>

        <span class="cov0" title="0">var matchingRecord *drs.DRSObject
        for i := range records </span><span class="cov0" title="0">{
                if records[i].Id == uuid </span><span class="cov0" title="0">{
                        matchingRecord = &amp;records[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if matchingRecord != nil </span><span class="cov0" title="0">{
                existingURLs := indexd.IndexdURLFromDrsAccessURLs(matchingRecord.AccessMethods)
                if slices.Contains(existingURLs, url) </span><span class="cov0" title="0">{
                        logger.Debug("Nothing to do: file already registered")
                        return matchingRecord, nil
                }</span>

                <span class="cov0" title="0">logger.Debug("updating existing record with new url")
                updatedRecord := drs.DRSObject{AccessMethods: []drs.AccessMethod{{AccessURL: drs.AccessURL{URL: url}}}}
                return inc.UpdateRecord(ctx, &amp;updatedRecord, matchingRecord.Id)</span>
        }

        // If no record exists, create one
        <span class="cov0" title="0">logger.Debug("creating new record")
        _, relPath, _ := cloud.ParseS3URL(url)

        drsObj, err := drs.BuildDrsObj(relPath, sha256, fileSize, uuid, inc.Config.BucketName, projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add authz explicitly since BuildDrsObj might not set it exactly as needed for all cases
        // Actually BuildDrsObj does set authz.
        <span class="cov0" title="0">return inc.RegisterRecord(ctx, drsObj)</span>
}

func (inc *GitDrsIdxdClient) AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, regionFlag, endpointFlag string, opts ...cloud.AddURLOption) (s3utils.S3Meta, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cfg := &amp;cloud.AddURLConfig{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        <span class="cov0" title="0">if inc.Logger == nil </span><span class="cov0" title="0">{
                inc.Logger = drslog.NewNoOpLogger()
        }</span>

        <span class="cov0" title="0">if err := s3utils.ValidateInputs(s3URL, sha256); err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, err
        }</span>

        <span class="cov0" title="0">_, relPath, err := cloud.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">isLFS, err := lfs.IsLFSTracked(relPath)
        if err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, fmt.Errorf("unable to determine if file is tracked by LFS: %w", err)
        }</span>
        <span class="cov0" title="0">if !isLFS </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, fmt.Errorf("file is not tracked by LFS")
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug("Fetching S3 metadata...")
        fileSize, modifiedDate, err := inc.fetchS3Metadata(ctx, s3URL, awsAccessKey, awsSecretKey, regionFlag, endpointFlag, cfg.S3Client, cfg.HttpClient, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w", err)
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug(fmt.Sprintf("Fetched S3 metadata successfully: %d bytes, modified: %s", fileSize, modifiedDate))

        inc.Logger.Debug("Processing indexd record...")
        drsObj, err := inc.upsertIndexdRecord(ctx, s3URL, sha256, fileSize, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, fmt.Errorf("failed to create indexd record: %w", err)
        }</span>

        <span class="cov0" title="0">drsObjPath, err := drsmap.GetObjectPath(common.DRS_OBJS_PATH, drsObj.Checksums.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, err
        }</span>
        <span class="cov0" title="0">if err := drsmap.WriteDrsObj(drsObj, sha256, drsObjPath); err != nil </span><span class="cov0" title="0">{
                return s3utils.S3Meta{}, err
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug("Indexd updated")

        return s3utils.S3Meta{
                Size:         fileSize,
                LastModified: modifiedDate,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package indexd

import (
        "context"
        "fmt"
        "log/slog"
        "net/url"

        "github.com/calypr/data-client/common"
        "github.com/calypr/data-client/conf"
        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/hash"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/gitrepo"
)

// Config holds configuration parameters for the GitDrsIdxdClient.
type Config struct {
        ProjectId          string
        BucketName         string
        Upsert             bool
        MultiPartThreshold int64
}

type GitDrsIdxdClient struct {
        Base   *url.URL
        Logger *slog.Logger
        G3     g3client.Gen3Interface
        Config *Config
}

func NewGitDrsIdxdClient(profileConfig conf.Credential, remote Gen3Remote, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov10" title="74">{
        baseUrl, err := url.Parse(profileConfig.APIEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="74">projectId := remote.GetProjectId()
        if projectId == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no gen3 project specified")
        }</span>

        <span class="cov9" title="73">bucketName := remote.GetBucketName()

        // Initialize data-client Gen3Interface with slog-adapted logger if needed,
        // or assume we use the one passed in if we update data-client to take slog.
        // For now we assume data-client/logs/TeeLogger is still used by data-client internals,
        // so we bridge it.
        // Initialize data-client Gen3Interface with slog-adapted logger.
        // We disable data-client's console output because drslog already handles stderr/file logging.
        // We also disable data-client's separate message file by default to aggregate logs in git-drs.log,
        // but allow re-enabling it via config.
        // but allow re-enabling it via config.
        enableDataClientLogs := gitrepo.GetGitConfigBool("lfs.customtransfer.drs.enable-data-client-logs", false)

        logOpts := []logs.Option{
                logs.WithBaseLogger(logger),
                logs.WithNoConsole(), // drslog already writes to stderr if configured
        }

        if enableDataClientLogs </span><span class="cov0" title="0">{
                logOpts = append(logOpts, logs.WithMessageFile())
        }</span> else<span class="cov9" title="73"> {
                logOpts = append(logOpts, logs.WithNoMessageFile())
        }</span>

        <span class="cov9" title="73">dLogger, closer := logs.New(profileConfig.Profile, logOpts...)
        _ = closer

        // If no options provided, use defaults for GitDrsIdxdClient
        if len(opts) == 0 </span><span class="cov9" title="73">{
                opts = append(opts, g3client.WithClients(g3client.IndexdClient, g3client.FenceClient, g3client.SowerClient))
        }</span>
        <span class="cov9" title="73">g3 := g3client.NewGen3InterfaceFromCredential(&amp;profileConfig, dLogger, opts...)

        upsert := gitrepo.GetGitConfigBool("lfs.customtransfer.drs.upsert", false)
        multiPartThresholdInt := gitrepo.GetGitConfigInt("lfs.customtransfer.drs.multipart-threshold", 500)
        var multiPartThreshold int64 = multiPartThresholdInt * common.MB

        config := &amp;Config{
                ProjectId:          projectId,
                BucketName:         bucketName,
                Upsert:             upsert,
                MultiPartThreshold: multiPartThreshold,
        }

        return &amp;GitDrsIdxdClient{
                Base:   baseUrl,
                Logger: logger,
                G3:     g3,
                Config: config,
        }, nil</span>
}

func (cl *GitDrsIdxdClient) GetProjectId() string <span class="cov4" title="5">{
        return cl.Config.ProjectId
}</span>

func (cl *GitDrsIdxdClient) GetObject(ctx context.Context, id string) (*drs.DRSObject, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().GetObject(ctx, id)
}</span>

func (cl *GitDrsIdxdClient) ListObjects(ctx context.Context) (chan drs.DRSObjectResult, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().ListObjects(ctx)
}</span>

func (cl *GitDrsIdxdClient) ListObjectsByProject(ctx context.Context, projectId string) (chan drs.DRSObjectResult, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().ListObjectsByProject(ctx, projectId)
}</span>

func (cl *GitDrsIdxdClient) GetDownloadURL(ctx context.Context, oid string) (*drs.AccessURL, error) <span class="cov0" title="0">{
        cl.Logger.Debug(fmt.Sprintf("Try to get download url for file OID %s", oid))

        // get the DRS object using the OID
        records, err := cl.GetObjectByHash(ctx, &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error getting DRS object for OID %s: %s", oid, err))
                return nil, fmt.Errorf("error getting DRS object for OID %s: %v", oid, err)
        }</span>
        <span class="cov0" title="0">return cl.getDownloadURLFromRecords(ctx, oid, records)</span>
}

func (cl *GitDrsIdxdClient) getDownloadURLFromRecords(ctx context.Context, oid string, records []drs.DRSObject) (*drs.AccessURL, error) <span class="cov0" title="0">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no DRS object found for OID %s", oid))
                return nil, fmt.Errorf("no DRS object found for OID %s", oid)
        }</span>

        // Find a record that matches the client's project ID
        <span class="cov0" title="0">matchingRecord, err := drsmap.FindMatchingRecord(records, cl.Config.ProjectId)
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error finding matching record for project %s: %s", cl.Config.ProjectId, err))
                return nil, fmt.Errorf("error finding matching record for project %s: %v", cl.Config.ProjectId, err)
        }</span>
        <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no matching record found for project %s", cl.Config.ProjectId))
                return nil, fmt.Errorf("no matching record found for project %s", cl.Config.ProjectId)
        }</span>

        <span class="cov0" title="0">cl.Logger.Debug(fmt.Sprintf("Matching record: %#v for oid %s", matchingRecord, oid))
        drsObj := matchingRecord

        // Check if access methods exist
        if len(drsObj.AccessMethods) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no access methods available for DRS object %s", drsObj.Id))
                return nil, fmt.Errorf("no access methods available for DRS object %s", drsObj.Id)
        }</span>

        // naively get access ID from splitting first path into :
        <span class="cov0" title="0">accessType := drsObj.AccessMethods[0].Type
        if accessType == "" </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0]))
                return nil, fmt.Errorf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0])
        }</span>
        <span class="cov0" title="0">did := drsObj.Id

        accessUrl, err := cl.G3.Indexd().GetDownloadURL(ctx, did, accessType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.AccessURL{URL: accessUrl.URL, Headers: accessUrl.Headers}, nil</span>
}

func (cl *GitDrsIdxdClient) GetObjectByHash(ctx context.Context, sum *hash.Checksum) ([]drs.DRSObject, error) <span class="cov4" title="5">{
        res, err := cl.G3.Indexd().GetObjectByHash(ctx, string(sum.Type), sum.Checksum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by project ID logic is git-drs specific business logic (ensure we only see our project's files)
        <span class="cov4" title="5">resourcePath, err := common.ProjectToResource(cl.Config.ProjectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">filtered := make([]drs.DRSObject, 0)
        for _, o := range res </span><span class="cov4" title="5">{
                found := false
                for _, am := range o.AccessMethods </span><span class="cov4" title="5">{
                        if am.Authorizations != nil &amp;&amp; am.Authorizations.Value == resourcePath </span><span class="cov4" title="5">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov4" title="5">if found </span><span class="cov4" title="5">{
                        filtered = append(filtered, o)
                }</span>
        }
        <span class="cov4" title="5">return filtered, nil</span>
}

func (cl *GitDrsIdxdClient) DeleteRecordsByProject(ctx context.Context, projectId string) error <span class="cov0" title="0">{
        return cl.G3.Indexd().DeleteRecordsByProject(ctx, projectId)
}</span>

func (cl *GitDrsIdxdClient) DeleteRecord(ctx context.Context, oid string) error <span class="cov2" title="2">{
        return cl.G3.Indexd().DeleteRecordByHash(ctx, oid, cl.Config.ProjectId)
}</span>

func (cl *GitDrsIdxdClient) GetProjectSample(ctx context.Context, projectId string, limit int) ([]drs.DRSObject, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().GetProjectSample(ctx, projectId, limit)
}</span>

func (c *GitDrsIdxdClient) RegisterRecord(ctx context.Context, record *drs.DRSObject) (*drs.DRSObject, error) <span class="cov5" title="9">{
        return c.G3.Indexd().RegisterRecord(ctx, record)
}</span>

func (c *GitDrsIdxdClient) UpdateRecord(ctx context.Context, updateInfo *drs.DRSObject, did string) (*drs.DRSObject, error) <span class="cov1" title="1">{
        return c.G3.Indexd().UpdateRecord(ctx, updateInfo, did)
}</span>

func (c *GitDrsIdxdClient) BuildDrsObj(fileName string, checksum string, size int64, drsId string) (*drs.DRSObject, error) <span class="cov0" title="0">{
        return drs.BuildDrsObj(fileName, checksum, size, drsId, c.Config.BucketName, c.Config.ProjectId)
}</span>

func (cl *GitDrsIdxdClient) GetGen3Interface() g3client.Gen3Interface <span class="cov3" title="4">{
        return cl.G3
}</span>

func (cl *GitDrsIdxdClient) GetBucketName() string <span class="cov1" title="1">{
        return cl.Config.BucketName
}</span>

func (cl *GitDrsIdxdClient) GetUpsert() bool <span class="cov1" title="1">{
        return cl.Config.Upsert
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package indexd

import (
        "context"
        "log/slog"

        "github.com/calypr/data-client/conf"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client"
)

// Gen3Server holds Gen3 server config
type Gen3Remote struct {
        Endpoint  string `yaml:"endpoint"`
        ProjectID string `yaml:"project_id"`
        Bucket    string `yaml:"bucket"`
}

func (s Gen3Remote) GetProjectId() string <span class="cov10" title="85">{
        return s.ProjectID
}</span>

func (s Gen3Remote) GetEndpoint() string <span class="cov2" title="2">{
        return s.Endpoint
}</span>

func (s Gen3Remote) GetBucketName() string <span class="cov9" title="84">{
        return s.Bucket
}</span>

func (s Gen3Remote) GetClient(remoteName string, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov9" title="73">{
        manager := conf.NewConfigure(logger)
        cred, err := manager.Load(remoteName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="72">gen3Logger := logs.NewGen3Logger(logger, "", remoteName)
        if err := g3client.EnsureValidCredential(context.Background(), cred, manager, gen3Logger, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="72">return NewGitDrsIdxdClient(*cred, s, logger, opts...)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package indexd

import (
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/calypr/data-client/common"
        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/upload"
        "github.com/calypr/git-drs/drsmap"
)

// RegisterFile implements DRSClient.RegisterFile
// It registers (or reuses) an indexd record for the oid, uploads the object if it
// is not already available in the bucket, and returns the resulting DRS object.
func (cl *GitDrsIdxdClient) RegisterFile(ctx context.Context, oid string, path string) (*drs.DRSObject, error) <span class="cov10" title="6">{
        cl.Logger.DebugContext(ctx, fmt.Sprintf("register file started for oid: %s", oid))

        // load the DRS object from oid created by prepush
        drsObject, err := drsmap.DrsInfoFromOid(oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting drs object for oid %s: %v", oid, err)
        }</span>

        <span class="cov10" title="6">cl.Logger.InfoContext(ctx, fmt.Sprintf("registering record for oid %s in indexd (did: %s)", oid, drsObject.Id))
        _, err = cl.RegisterRecord(ctx, drsObject)
        if err != nil </span><span class="cov4" title="2">{
                // handle "already exists" error ie upsert behavior
                if strings.Contains(err.Error(), "already exists") </span><span class="cov4" title="2">{
                        if !cl.Config.Upsert </span><span class="cov0" title="0">{
                                cl.Logger.DebugContext(ctx, fmt.Sprintf("indexd record already exists, proceeding for oid %s: did: %s err: %v", oid, drsObject.Id, err))
                        }</span> else<span class="cov4" title="2"> {
                                cl.Logger.DebugContext(ctx, fmt.Sprintf("indexd record already exists, deleting and re-adding for oid %s: did: %s", oid, drsObject.Id))
                                err = cl.DeleteRecord(ctx, oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error deleting existing indexd record oid %s: did: %s err: %v", oid, drsObject.Id, err)
                                }</span>
                                <span class="cov4" title="2">_, err = cl.RegisterRecord(ctx, drsObject)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error re-saving indexd record after deletion: oid %s: did: %s err: %v", oid, drsObject.Id, err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("error saving oid %s indexd record: %v", oid, err)
                }</span>
        }
        <span class="cov10" title="6">cl.Logger.InfoContext(ctx, fmt.Sprintf("indexd record registration complete for oid %s", oid))

        // Now attempt to upload the file if not already available
        cl.Logger.InfoContext(ctx, fmt.Sprintf("checking if oid %s is already downloadable", oid))
        downloadable, err := cl.isFileDownloadable(ctx, drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error checking if file is downloadable: oid %s %v", oid, err)
        }</span>
        <span class="cov10" title="6">if downloadable </span><span class="cov4" title="2">{
                cl.Logger.DebugContext(ctx, fmt.Sprintf("file %s is already available for download, skipping upload", oid))
                return drsObject, nil
        }</span>
        <span class="cov7" title="4">cl.Logger.InfoContext(ctx, fmt.Sprintf("file %s is not downloadable, proceeding to upload", oid))

        // Proceed to upload the file
        // Reuse the Gen3 interface
        g3 := cl.G3

        filePath := path
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov7" title="4">defer func(file *os.File) </span><span class="cov7" title="4">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cl.Logger.DebugContext(ctx, fmt.Sprintf("warning: error closing file %s: %v", filePath, err))
                }</span>
        }(file)

        // Use multipart threshold from config or default to 5GB
        <span class="cov7" title="4">multiPartThreshold := int64(5 * 1024 * 1024 * 1024) // 5GB default
        if cl.Config.MultiPartThreshold &gt; 0 </span><span class="cov7" title="4">{
                multiPartThreshold = cl.Config.MultiPartThreshold
        }</span>

        <span class="cov7" title="4">if drsObject.Size &lt; multiPartThreshold </span><span class="cov6" title="3">{
                cl.Logger.DebugContext(ctx, fmt.Sprintf("UploadSingle size: %d path: %s", drsObject.Size, filePath))
                req := common.FileUploadRequestObject{
                        SourcePath: filePath,
                        ObjectKey:  drsObject.Checksums.SHA256,
                        GUID:       drsObject.Id,
                        Bucket:     cl.Config.BucketName,
                }
                err := upload.UploadSingle(ctx, g3, req, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("UploadSingle error: %s", err)
                }</span>
        } else<span class="cov1" title="1"> {
                cl.Logger.DebugContext(ctx, fmt.Sprintf("MultipartUpload size: %d path: %s", drsObject.Size, filePath))
                err = upload.MultipartUpload(
                        ctx,
                        g3,
                        common.FileUploadRequestObject{
                                SourcePath:   filePath,
                                ObjectKey:    drsObject.Checksums.SHA256,
                                GUID:         drsObject.Id,
                                FileMetadata: common.FileMetadata{},
                                Bucket:       cl.Config.BucketName,
                        },
                        file, false,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("MultipartUpload error: %s", err)
                }</span>
        }
        <span class="cov7" title="4">return drsObject, nil</span>
}

// isFileDownloadable checks if a file is already available for download
func (cl *GitDrsIdxdClient) isFileDownloadable(ctx context.Context, drsObject *drs.DRSObject) (bool, error) <span class="cov10" title="6">{
        // Try to get a download URL - if successful, file is downloadable
        if len(drsObject.AccessMethods) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov10" title="6">accessType := drsObject.AccessMethods[0].Type
        res, err := cl.G3.Indexd().GetDownloadURL(ctx, drsObject.Id, accessType)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get a download URL, assume file is not downloadable
                return false, nil
        }</span>
        // Check if the URL is accessible
        <span class="cov10" title="6">err = common.CanDownloadFile(res.URL)
        return err == nil, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package indexd_tests

import (
        "net/http"
        "sync"
)

// MockIndexdRecord represents a test record in the mock server
type MockIndexdRecord struct {
        Did      string
        FileName string
        Size     int64
        Hashes   map[string]string
        URLs     []string
        Authz    []string
}

// MockIndexdServer is a mock server for testing
type MockIndexdServer struct {
        records     map[string]*MockIndexdRecord
        hashIndex   map[string][]string
        recordMutex sync.RWMutex
        server      *http.Server
}

// MockAuthHandler is a mock authentication handler for testing
type MockAuthHandler struct{}

func (m *MockAuthHandler) RefreshAccessToken() (string, error) <span class="cov0" title="0">{
        return "mock-token", nil
}</span>

func (m *MockAuthHandler) GetAccessToken() string <span class="cov0" title="0">{
        return "mock-token"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cloud

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "strings"
        "sync/atomic"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

// progressReader wraps an io.ReadCloser and periodically writes progress to stderr.
type progressReader struct {
        rc     io.ReadCloser
        label  string
        start  time.Time
        total  int64 // accessed atomically
        quit   chan struct{}
        done   chan struct{}
        ticker time.Duration
}

func newProgressReader(rc io.ReadCloser, label string) io.ReadCloser <span class="cov10" title="2">{
        p := &amp;progressReader{
                rc:     rc,
                label:  label,
                start:  time.Now(),
                quit:   make(chan struct{}),
                done:   make(chan struct{}),
                ticker: 500 * time.Millisecond,
        }

        go func() </span><span class="cov10" title="2">{
                t := time.NewTicker(p.ticker)
                defer t.Stop()
                var last int64
                for </span><span class="cov10" title="2">{
                        select </span>{
                        case &lt;-t.C:<span class="cov0" title="0">
                                total := atomic.LoadInt64(&amp;p.total)
                                elapsed := time.Since(p.start).Seconds()
                                var rate float64
                                if elapsed &gt; 0 </span><span class="cov0" title="0">{
                                        rate = float64(total) / elapsed
                                }</span>
                                // \r to overwrite the same line like git pull; no newline until done
                                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\r%s: %d bytes (%.1f KiB/s)", p.label, total, rate/1024)
                                last = total</span>
                        case &lt;-p.quit:<span class="cov10" title="2">
                                // final line (replace same line, then newline)
                                total := atomic.LoadInt64(&amp;p.total)
                                _ = last // in case we want to use last for something later
                                fmt.Fprintf(os.Stderr, "\r%s: %d bytes\n", p.label, total)
                                close(p.done)
                                return</span>
                        }
                }
        }()

        <span class="cov10" title="2">return p</span>
}

func (p *progressReader) Read(b []byte) (int, error) <span class="cov10" title="2">{
        n, err := p.rc.Read(b)
        if n &gt; 0 </span><span class="cov10" title="2">{
                atomic.AddInt64(&amp;p.total, int64(n))
        }</span>
        <span class="cov10" title="2">return n, err</span>
}

func (p *progressReader) Close() error <span class="cov10" title="2">{
        // Close underlying reader first, then stop progress goroutine and wait for completion.
        err := p.rc.Close()
        close(p.quit)
        &lt;-p.done
        return err
}</span>

// AgentFetchReader fetches the object described by `input` and returns an io.ReadCloser.
// It accepts `s3://bucket/key` URLs and converts them to HTTPS URLs. If `input.AWSEndpoint`
// is set it will use that endpoint in path-style (endpoint/bucket/key); otherwise it
// uses the default virtual-hosted AWS form: https://{bucket}.s3.amazonaws.com/{key}.
func AgentFetchReader(ctx context.Context, input S3ObjectParameters) (io.ReadCloser, error) <span class="cov10" title="2">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov10" title="2">raw := strings.TrimSpace(input.S3URL)
        if raw == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: S3ObjectParameters.S3URL is empty")
        }</span>

        <span class="cov10" title="2">useSignedFetch := strings.TrimSpace(input.AWSAccessKey) != "" ||
                strings.TrimSpace(input.AWSSecretKey) != "" ||
                strings.TrimSpace(input.AWSRegion) != ""
        if useSignedFetch </span><span class="cov10" title="2">{
                if strings.TrimSpace(input.AWSAccessKey) == "" || strings.TrimSpace(input.AWSSecretKey) == "" || strings.TrimSpace(input.AWSRegion) == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: AWSAccessKey, AWSSecretKey, and AWSRegion are required for signed fetch")
                }</span>

                <span class="cov10" title="2">bucket, key, err := parseS3URL(raw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: parse s3 url %q: %w", raw, err)
                }</span>

                <span class="cov10" title="2">s3Client, err := newS3Client(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: init s3 client: %w", err)
                }</span>

                <span class="cov10" title="2">out, err := s3Client.GetObject(ctx, &amp;s3.GetObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(key),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: s3 GetObject failed (bucket=%q key=%q): %w", bucket, key, err)
                }</span>
                <span class="cov10" title="2">if out.Body == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: response body is nil for s3://%s/%s", bucket, key)
                }</span>

                <span class="cov10" title="2">label := fmt.Sprintf("fetch s3://%s/%s", bucket, key)
                return newProgressReader(out.Body, label), nil</span>
        }

        <span class="cov0" title="0">u, err := url.Parse(raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: parse url %q: %w", raw, err)
        }</span>

        <span class="cov0" title="0">var s3url string
        switch u.Scheme </span>{
        case "s3":<span class="cov0" title="0">
                bucket := u.Host
                key := strings.TrimPrefix(u.Path, "/")
                if bucket == "" || key == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: invalid s3 URL %q", raw)
                }</span>
                <span class="cov0" title="0">if ep := strings.TrimSpace(input.AWSEndpoint); ep != "" </span><span class="cov0" title="0">{
                        // ensure endpoint has a scheme
                        if !strings.HasPrefix(ep, "http://") &amp;&amp; !strings.HasPrefix(ep, "https://") </span><span class="cov0" title="0">{
                                ep = "https://" + ep
                        }</span>
                        <span class="cov0" title="0">s3url = strings.TrimRight(ep, "/") + "/" + bucket + "/" + key</span>
                } else<span class="cov0" title="0"> {
                        s3url = fmt.Sprintf("https://%s.s3.amazonaws.com/%s", bucket, key)
                }</span>
        case "", "http", "https":<span class="cov0" title="0">
                // allow bare host/path (no scheme) by assuming https, otherwise use as-is
                if u.Scheme == "" </span><span class="cov0" title="0">{
                        s3url = "https://" + raw
                }</span> else<span class="cov0" title="0"> {
                        s3url = raw
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("AgentFetchReader: unsupported URL scheme %q", u.Scheme)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodGet, s3url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: http get %s: %w", s3url, err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                if _, copyErr := io.Copy(io.Discard, resp.Body); copyErr != nil </span><span class="cov0" title="0">{
                        _ = resp.Body.Close()
                        return nil, fmt.Errorf("AgentFetchReader: unexpected status %d fetching %s; failed to drain body: %w", resp.StatusCode, s3url, copyErr)
                }</span>
                <span class="cov0" title="0">if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AgentFetchReader: unexpected status %d fetching %s; failed to close body: %w", resp.StatusCode, s3url, closeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("AgentFetchReader: unexpected status %d fetching %s", resp.StatusCode, s3url)</span>
        }

        <span class="cov0" title="0">if resp.Body == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AgentFetchReader: response body is nil for %s", s3url)
        }</span>
        // wrap response body with progress reporting that writes to stderr
        <span class="cov0" title="0">label := fmt.Sprintf("fetch %s", s3url)
        return newProgressReader(resp.Body, label), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cloud

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
)

// downloads a file to a specified path using a signed URL
func DownloadSignedUrl(signedURL string, dstPath string) error <span class="cov10" title="2">{
        // Download the file using the signed URL
        fileResponse, err := http.Get(signedURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">defer fileResponse.Body.Close()

        // Check if the response status is OK
        if fileResponse.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, err := io.ReadAll(fileResponse.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download file using signed URL: %s", fileResponse.Status)
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("failed to download file using signed URL: %s. Full error: %s", fileResponse.Status, string(body))</span>
        }

        // Create the destination directory if it doesn't exist
        <span class="cov1" title="1">err = os.MkdirAll(filepath.Dir(dstPath), os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the destination file
        <span class="cov1" title="1">dstFile, err := os.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer dstFile.Close()

        // Write the file content to the destination file
        _, err = io.Copy(dstFile, fileResponse.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cloud

import (
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
)

// Download downloads the S3 object to a temporary file while computing its SHA256 hash.
// returns the computed SHA256 hash, temporary path and any error encountered.
func Download(ctx context.Context, info *S3Object, s3Input S3ObjectParameters, lfsRoot string) (string, string, error) <span class="cov10" title="2">{
        // 2) object destination
        etag := info.ETag
        subdir1, subdir2 := "xx", "yy"
        if len(etag) &gt;= 4 </span><span class="cov10" title="2">{
                subdir1 = etag[0:2]
                subdir2 = etag[2:4]
        }</span>
        <span class="cov10" title="2">objName := etag
        if objName == "" </span><span class="cov0" title="0">{
                objName = "unknown-etag"
        }</span>
        <span class="cov10" title="2">tmpDir := filepath.Join(lfsRoot, "tmp-objects", subdir1, subdir2)
        tmpObj := filepath.Join(tmpDir, objName)

        // 3) fetch bytes -&gt; tmp, compute sha+count

        // Create the temporary directory and file where the S3 object will be streamed while computing its hash and size.
        if err := os.MkdirAll(tmpDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("mkdir %s: %w", tmpDir, err)
        }</span>

        <span class="cov10" title="2">f, err := os.Create(tmpObj)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("create %s: %w", tmpObj, err)
        }</span>
        // ensure any leftover file is closed and error propagated via named return
        <span class="cov10" title="2">defer func() </span><span class="cov10" title="2">{
                if f != nil </span><span class="cov0" title="0">{
                        if cerr := f.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("close tmp file: %w", cerr)
                        }</span>
                }
        }()

        <span class="cov10" title="2">h := sha256.New()

        var reader io.ReadCloser
        reader, err = AgentFetchReader(ctx, s3Input)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("fetch reader: %w", err)
        }</span>
        // ensure close on any early return; propagate close error via named return
        <span class="cov10" title="2">defer func() </span><span class="cov10" title="2">{
                if reader != nil </span><span class="cov0" title="0">{
                        if cerr := reader.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("close reader: %w", cerr)
                        }</span>
                }
        }()

        <span class="cov10" title="2">n, err := io.Copy(io.MultiWriter(f, h), reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("copy bytes to %s: %w", tmpObj, err)
        }</span>

        // explicitly close reader and handle error
        <span class="cov10" title="2">if cerr := reader.Close(); cerr != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("close reader: %w", cerr)
        }</span>
        <span class="cov10" title="2">reader = nil

        // ensure data is flushed to disk
        if err = f.Sync(); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("sync %s: %w", tmpObj, err)
        }</span>

        // explicitly close tmp file before rename
        <span class="cov10" title="2">if cerr := f.Close(); cerr != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("close %s: %w", tmpObj, cerr)
        }</span>
        <span class="cov10" title="2">f = nil

        // use n (bytes written) to avoid unused var warnings
        _ = n

        // compute hex SHA256 of the fetched content
        computedSHA := fmt.Sprintf("%x", h.Sum(nil))
        return computedSHA, tmpObj, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package lfss3 provides a small helper for Git-LFS + S3 object introspection.
//
// It:
//  1. determines the effective Git LFS storage root (.git/lfs vs git config lfs.storage)
//  2. derives a working-tree filename from the S3 object key (basename of key)
//  3. performs an S3 HEAD Object to retrieve size and user metadata (sha256 if present)
package cloud

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "regexp"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

// S3ObjectParameters container for S3 object identification and access.
type S3ObjectParameters struct {
        S3URL           string
        AWSAccessKey    string
        AWSSecretKey    string
        AWSRegion       string
        AWSEndpoint     string // optional: custom endpoint (Ceph/MinIO/etc.)
        SHA256          string // optional expected hex (64 chars). Can be "sha256:&lt;hex&gt;" or "&lt;hex&gt;"
        DestinationPath string // optional override URL path (worktree filename)
}

// S3Object is what we return.
type S3Object struct {

        // Object identity
        Bucket string
        Key    string
        Path   string // basename of Key (filename), or override from input

        // HEAD-derived info
        SizeBytes   int64
        MetaSHA256  string // from user-defined object metadata (if present)
        ETag        string
        LastModTime time.Time
}

// InspectS3ForLFS does all 3 requested tasks.
func InspectS3ForLFS(ctx context.Context, in S3ObjectParameters) (*S3Object, error) <span class="cov5" title="3">{
        if strings.TrimSpace(in.S3URL) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("S3URL is required")
        }</span>
        <span class="cov5" title="3">if strings.TrimSpace(in.AWSRegion) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("AWSRegion is required")
        }</span>
        <span class="cov5" title="3">if in.AWSAccessKey == "" || in.AWSSecretKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("AWSAccessKey and AWSSecretKey are required")
        }</span>

        // 2) Parse S3 URL + derive working tree filename.
        <span class="cov5" title="3">bucket, key, err := parseS3URL(in.S3URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">worktreeName := strings.TrimSpace(in.DestinationPath)
        if worktreeName == "" </span><span class="cov0" title="0">{
                worktreeName = path.Base(key)
                if worktreeName == "." || worktreeName == "/" || worktreeName == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not derive worktree name from key %q", key)
                }</span>
        } else<span class="cov5" title="3"> if worktreeName == "." || worktreeName == "/" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid worktree name override %q", worktreeName)
        }</span>

        // 3) HEAD on S3 to determine size and meta.SHA256.
        <span class="cov5" title="3">s3Client, err := newS3Client(ctx, in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">head, err := s3Client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("s3 HeadObject failed (bucket=%q key=%q): %w", bucket, key, err)
        }</span>

        <span class="cov5" title="3">metaSHA := extractSHA256FromMetadata(head.Metadata)

        // Optional: validate provided SHA256 against metadata if both exist.
        expected := normalizeSHA256(in.SHA256)
        if expected != "" &amp;&amp; metaSHA != "" &amp;&amp; !strings.EqualFold(expected, metaSHA) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sha256 mismatch: expected=%s head.meta=%s", expected, metaSHA)
        }</span>

        <span class="cov5" title="3">var lm time.Time
        if head.LastModified != nil </span><span class="cov5" title="3">{
                lm = *head.LastModified
        }</span>

        <span class="cov5" title="3">if head.ContentLength == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("s3 HeadObject missing ContentLength (bucket=%q key=%q)", bucket, key)
        }</span>
        <span class="cov5" title="3">sizeBytes := *head.ContentLength

        var etag string
        if head.ETag != nil </span><span class="cov5" title="3">{
                etag = strings.Trim(*head.ETag, `"`)
        }</span>

        <span class="cov5" title="3">out := &amp;S3Object{
                Bucket:      bucket,
                Key:         key,
                Path:        worktreeName,
                SizeBytes:   sizeBytes,
                MetaSHA256:  metaSHA,
                ETag:        etag,
                LastModTime: lm,
        }
        return out, nil</span>
}

//
// --- S3 parsing + client ---
//

var virtualHostedRE = regexp.MustCompile(`^(.+?)\.s3(?:[.-]|$)`)

// parseS3URL parses s3://bucket/key, virtual-hosted HTTPS (bucket.s3.../key)
// and path-style HTTPS (s3.../bucket/key). Returns bucket and key.
func parseS3URL(raw string) (string, string, error) <span class="cov9" title="8">{
        u, err := url.Parse(raw)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov9" title="8">switch u.Scheme </span>{
        case "s3":<span class="cov8" title="6">
                bucket := u.Host
                key := strings.TrimPrefix(u.Path, "/")
                return bucket, key, nil</span>
        case "http", "https":<span class="cov3" title="2">
                host := u.Hostname()

                // virtual-hosted: bucket.s3.amazonaws.com or bucket.s3-region.amazonaws.com
                if m := virtualHostedRE.FindStringSubmatch(host); m != nil </span><span class="cov1" title="1">{
                        bucket := m[1]
                        key := strings.TrimPrefix(u.Path, "/")
                        return bucket, key, nil
                }</span>

                // path-style: s3.../bucket/key
                <span class="cov1" title="1">path := strings.TrimPrefix(u.Path, "/")
                if path == "" </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("no bucket in URL: %s", raw)
                }</span>
                <span class="cov1" title="1">parts := strings.SplitN(path, "/", 2)
                bucket := parts[0]
                key := ""
                if len(parts) == 2 </span><span class="cov1" title="1">{
                        key = parts[1]
                }</span>
                <span class="cov1" title="1">return bucket, key, nil</span>
        default:<span class="cov0" title="0">
                return "", "", fmt.Errorf("unsupported scheme: %s", u.Scheme)</span>
        }
}

func newS3Client(ctx context.Context, in S3ObjectParameters) (*s3.Client, error) <span class="cov7" title="5">{
        creds := credentials.NewStaticCredentialsProvider(in.AWSAccessKey, in.AWSSecretKey, "")

        // Custom HTTP client is useful for S3-compatible endpoints.
        httpClient := &amp;http.Client{
                Timeout: 60 * time.Second,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                MinVersion: tls.VersionTLS12,
                        },
                },
        }

        cfg, err := config.LoadDefaultConfig(ctx,
                config.WithRegion(in.AWSRegion),
                config.WithCredentialsProvider(creds),
                config.WithHTTPClient(httpClient),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aws config init failed: %w", err)
        }</span>

        <span class="cov7" title="5">opts := []func(*s3.Options){}
        if strings.TrimSpace(in.AWSEndpoint) != "" </span><span class="cov7" title="5">{
                ep := strings.TrimRight(in.AWSEndpoint, "/")
                opts = append(opts, func(o *s3.Options) </span><span class="cov7" title="5">{
                        o.UsePathStyle = true // usually required for Ceph/MinIO/custom endpoints
                        o.BaseEndpoint = aws.String(ep)
                }</span>)
        }

        <span class="cov7" title="5">return s3.NewFromConfig(cfg, opts...), nil</span>
}

//
// --- SHA256 metadata extraction ---
//

var sha256HexRe = regexp.MustCompile(`(?i)^[0-9a-f]{64}$`)

func normalizeSHA256(s string) string <span class="cov10" title="9">{
        s = strings.TrimSpace(s)
        s = strings.TrimPrefix(strings.ToLower(s), "sha256:")
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov3" title="2">{
                return ""
        }</span>
        <span class="cov8" title="7">if !sha256HexRe.MatchString(s) </span><span class="cov1" title="1">{
                // If caller provided something malformed, treat as empty.
                // Change this to a hard error if you prefer.
                return ""
        }</span>
        <span class="cov8" title="6">return strings.ToLower(s)</span>
}

func extractSHA256FromMetadata(md map[string]string) string <span class="cov8" title="6">{
        if md == nil </span><span class="cov5" title="3">{
                return ""
        }</span>

        // AWS SDK v2 exposes user-defined metadata WITHOUT the "x-amz-meta-" prefix,
        // and normalizes keys to lower-case.
        <span class="cov5" title="3">candidates := []string{
                "sha256",
                "checksum-sha256",
                "content-sha256",
                "oid-sha256",
                "git-lfs-sha256",
        }

        for _, k := range candidates </span><span class="cov9" title="8">{
                if v, ok := md[k]; ok </span><span class="cov3" title="2">{
                        n := normalizeSHA256(v)
                        if n != "" </span><span class="cov3" title="2">{
                                return n
                        }</span>
                }
        }

        // Sometimes people stash "sha256:&lt;hex&gt;"
        <span class="cov1" title="1">for _, v := range md </span><span class="cov1" title="1">{
                if n := normalizeSHA256(v); n != "" </span><span class="cov1" title="1">{
                        return n
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cloud

import (
        "fmt"
        "log/slog"
        "net/http"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

type S3BucketsResponse struct {
        GSBuckets map[string]any       `json:"GS_BUCKETS"`
        S3Buckets map[string]*S3Bucket `json:"S3_BUCKETS"`
}

type S3Bucket struct {
        Region      string   `json:"region,omitempty"`
        EndpointURL string   `json:"endpoint_url,omitempty"`
        Programs    []string `json:"programs,omitempty"`
}

// S3Meta holds S3 object metadata
type S3Meta struct {
        Size         int64
        LastModified string
}

type CustomEndpointResolver struct {
        Endpoint string
}

const (
        AWS_KEY_FLAG_NAME          = "aws-access-key-id"
        AWS_SECRET_FLAG_NAME       = "aws-secret-access-key"
        AWS_KEY_ENV_VAR            = "AWS_ACCESS_KEY_ID"
        AWS_SECRET_ENV_VAR         = "AWS_SECRET_ACCESS_KEY"
        AWS_REGION_FLAG_NAME       = "region"
        AWS_REGION_ENV_VAR         = "AWS_REGION"
        AWS_ENDPOINT_URL_FLAG_NAME = "endpoint-url"
        AWS_ENDPOINT_URL_ENV_VAR   = "AWS_ENDPOINT_URL"
)

func (r *CustomEndpointResolver) ResolveEndpoint(service, region string) (aws.Endpoint, error) <span class="cov1" title="1">{
        return aws.Endpoint{
                URL: r.Endpoint,
        }, nil
}</span>

// AddURLConfig holds optional clients for dependency injection
type AddURLConfig struct {
        S3Client   *s3.Client
        HttpClient *http.Client
        Logger     *slog.Logger
}

// AddURLOption is a functional option for configuring AddURL
type AddURLOption func(*AddURLConfig)

// WithS3Client provides a custom S3 client to AddURL
func WithS3Client(client *s3.Client) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.S3Client = client
        }</span>
}

// WithHTTPClient provides a custom HTTP client to AddURL
func WithHTTPClient(client *http.Client) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.HttpClient = client
        }</span>
}

// WithLogger provides a custom logger to AddURL
func WithLogger(logger *slog.Logger) AddURLOption <span class="cov1" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov1" title="1">{
                cfg.Logger = logger
        }</span>
}

func ParseS3URL(s3url string) (string, string, error) <span class="cov10" title="13">{
        s3Prefix := "s3://"
        if !strings.HasPrefix(s3url, s3Prefix) </span><span class="cov5" title="4">{
                return "", "", fmt.Errorf("S3 URL requires prefix 's3://': %s", s3url)
        }</span>
        <span class="cov8" title="9">trimmed := strings.TrimPrefix(s3url, s3Prefix)
        slashIndex := strings.Index(trimmed, "/")
        if slashIndex == -1 || slashIndex == len(trimmed)-1 </span><span class="cov5" title="4">{
                return "", "", fmt.Errorf("invalid S3 file URL: %s", s3url)
        }</span>
        <span class="cov6" title="5">return trimmed[:slashIndex], trimmed[slashIndex+1:], nil</span>
}

// CanDownloadFile checks if a file can be downloaded from the given signed URL
// by issuing a ranged GET for a single byte to mimic HEAD behavior.
func CanDownloadFile(signedURL string) error <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", signedURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Range", "bytes=0-0")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while sending the request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusPartialContent || resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("failed to access file, HTTP status: %d", resp.StatusCode)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cloud

import (
        "encoding/hex"
        "errors"
        "strings"
)

func ValidateInputs(s3URL string, sha256 string) error <span class="cov10" title="26">{
        if !strings.HasPrefix(s3URL, "s3://") </span><span class="cov6" title="8">{
                return errors.New("invalid S3 URL format. URL should be of the format 's3://bucket/path/to/file'")
        }</span>

        // Normalize case and validate SHA256
        <span class="cov8" title="18">sha256 = strings.ToLower(sha256)
        if len(sha256) != 64 </span><span class="cov5" title="5">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="13">if _, err := hex.DecodeString(sha256); err != nil </span><span class="cov2" title="2">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov7" title="11">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package addref

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "add-ref &lt;drs_uri&gt; &lt;dst path&gt;",
        Short: "Add a reference to an existing DRS object via URI",
        Long:  "Add a reference to an existing DRS object, eg passing a DRS URI from AnVIL. Requires that the sha256 of the file is already in the cache",
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                drsUri := args[0]
                dstPath := args[1]

                logger := drslog.GetLogger()

                logger.Debug(fmt.Sprintf("Adding reference to DRS object %s to %s", drsUri, dstPath))

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">client, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">obj, err := client.GetObject(context.Background(), drsUri)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">objSha := ""
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                objSha = sum
                        }</span>
                }
                <span class="cov0" title="0">if objSha == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("object %s sha256 not available", drsUri)
                }</span>
                <span class="cov0" title="0">dirPath := filepath.Dir(dstPath)
                _, err = os.Stat(dirPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // The directory does not exist
                        os.MkdirAll(dirPath, os.ModePerm)
                }</span>

                <span class="cov0" title="0">err = CreateLfsPointer(obj, dstPath)
                return err</span>
        },
}

func CreateLfsPointer(drsObj *drs.DRSObject, dst string) error <span class="cov3" title="3">{
        sumMap := hash.ConvertHashInfoToMap(drsObj.Checksums)
        if len(sumMap) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no checksums found for DRS object")
        }</span>

        // find sha256 checksum
        <span class="cov2" title="2">var shaSum string
        for csType, cs := range sumMap </span><span class="cov2" title="2">{
                if csType == hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                        shaSum = cs
                        break</span>
                }
        }
        <span class="cov2" title="2">if shaSum == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("no sha256 checksum found for DRS object")
        }</span>

        // create pointer file content
        <span class="cov1" title="1">pointerContent := "version https://git-lfs.github.com/spec/v1\n"
        pointerContent += fmt.Sprintf("oid sha256:%s\n", shaSum)
        pointerContent += fmt.Sprintf("size %d\n", drsObj.Size)

        // write to file
        err := os.WriteFile(dst, []byte(pointerContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write LFS pointer file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func init() <span class="cov10" title="96">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package addurl

import (
        "context"
        "crypto/sha256"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "maps"
        "os"
        "path/filepath"
        "slices"
        "strings"
        "time"

        "github.com/calypr/git-drs/gitrepo"
        "github.com/calypr/git-drs/precommit_cache"
)

// updatePrecommitCache updates the project's pre-commit cache with a mapping
// from a repository-relative `pathArg` to the given LFS `oid` and records the
// external source URL. It will:
//   - require a non-nil `logger`
//   - open the pre-commit cache (`precommit_cache.Open`)
//   - ensure cache directories exist
//   - convert the supplied worktree path to a repository-relative path
//   - create or update the per-path JSON entry with the current OID and timestamp
//   - create or update the per-OID JSON entry listing paths that reference it,
//     the external URL, and a content-change flag when the path's OID changed
//   - remove the path from the previous OID entry when the content changed
//
// Parameters:
//   - ctx: context for operations that may be cancellable
//   - logger: a non-nil `*slog.Logger` used for warnings; if nil the function
//     returns an error
//   - pathArg: the worktree path to record (absolute or relative); must not be empty
//   - oid: the LFS object id (string) to associate with the path
//   - externalURL: optional external source URL for the object; empty string is allowed
//
// Returns an error if any cache operation, path resolution, or I/O fails.
func updatePrecommitCache(ctx context.Context, logger *slog.Logger, pathArg, oid, externalURL string) error <span class="cov8" title="7">{
        if logger == nil </span><span class="cov0" title="0">{
                return errors.New("logger is required")
        }</span>
        // Open pre-commit cache. Returns a configured Cache or error.
        <span class="cov8" title="7">cache, err := precommit_cache.Open(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure cache directories exist.
        <span class="cov8" title="7">if err := ensureCacheDirs(cache, logger); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert worktree path to repository-relative path.
        <span class="cov8" title="7">relPath, err := repoRelativePath(pathArg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Current timestamp in RFC3339 format (UTC).
        <span class="cov8" title="7">now := time.Now().UTC().Format(time.RFC3339)

        // Read previous path entry, if any.
        pathFile := cachePathEntryFile(cache, relPath)
        prevEntry, prevExists, err := readPathEntry(pathFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // track whether content changed for this path
        <span class="cov8" title="7">contentChanged := prevExists &amp;&amp; prevEntry.LFSOID != "" &amp;&amp; prevEntry.LFSOID != oid

        if err := writeJSONAtomic(pathFile, precommit_cache.PathEntry{
                Path:      relPath,
                LFSOID:    oid,
                UpdatedAt: now,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="7">if err := upsertOIDEntry(cache, oid, relPath, externalURL, now, contentChanged); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="7">if contentChanged </span><span class="cov3" title="2">{
                _ = removePathFromOID(cache, prevEntry.LFSOID, relPath, now)
        }</span>

        <span class="cov8" title="7">return nil</span>
}

// ensureCacheDirs verifies and creates the pre-commit cache directory layout
// (paths and oids directories). It logs a warning when creating a missing
// cache root.
func ensureCacheDirs(cache *precommit_cache.Cache, logger *slog.Logger) error <span class="cov8" title="7">{
        if cache == nil </span><span class="cov0" title="0">{
                return errors.New("cache is nil")
        }</span>
        <span class="cov8" title="7">if _, err := os.Stat(cache.Root); err != nil </span><span class="cov5" title="3">{
                if os.IsNotExist(err) </span><span class="cov5" title="3">{
                        logger.Warn("pre-commit cache directory missing; creating", "path", cache.Root)
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="7">if err := os.MkdirAll(cache.PathsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create cache paths dir: %w", err)
        }</span>
        <span class="cov8" title="7">if err := os.MkdirAll(cache.OIDsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create cache oids dir: %w", err)
        }</span>
        <span class="cov8" title="7">return nil</span>
}

// repoRelativePath converts a worktree path (absolute or relative) to a
// repository-relative path. It resolves symlinks and ensures the path is
// contained within the repository root.
func repoRelativePath(pathArg string) (string, error) <span class="cov8" title="7">{
        if pathArg == "" </span><span class="cov0" title="0">{
                return "", errors.New("empty worktree path")
        }</span>
        <span class="cov8" title="7">root, err := gitrepo.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="7">root, err = filepath.EvalSymlinks(root)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="7">clean := filepath.Clean(pathArg)
        if filepath.IsAbs(clean) </span><span class="cov5" title="3">{
                clean, err = filepath.EvalSymlinks(clean)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov5" title="3">rel, err := filepath.Rel(root, clean)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov5" title="3">if strings.HasPrefix(rel, "..") </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("path %s is outside repo root %s", clean, root)
                }</span>
                <span class="cov5" title="3">return filepath.ToSlash(rel), nil</span>
        }
        <span class="cov6" title="4">return filepath.ToSlash(clean), nil</span>
}

// cachePathEntryFile returns the filesystem path to the JSON path-entry file
// for the given repository-relative path within the provided Cache.
func cachePathEntryFile(cache *precommit_cache.Cache, path string) string <span class="cov8" title="7">{
        return filepath.Join(cache.PathsDir, precommit_cache.EncodePath(path)+".json")
}</span>

// cacheOIDEntryFile returns the filesystem path to the JSON OID-entry file
// for the given LFS OID. The file is named by sha256(oid) to avoid filesystem
// restrictions and collisions.
func cacheOIDEntryFile(cache *precommit_cache.Cache, oid string) string <span class="cov10" title="9">{
        sum := sha256.Sum256([]byte(oid))
        return filepath.Join(cache.OIDsDir, fmt.Sprintf("%x.json", sum[:]))
}</span>

// readPathEntry reads and parses a JSON PathEntry from disk. It returns the
// parsed entry, a boolean indicating existence, or an error on I/O/parse
// failure.
func readPathEntry(path string) (*precommit_cache.PathEntry, bool, error) <span class="cov8" title="7">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov7" title="5">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov7" title="5">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, err</span>
        }
        <span class="cov3" title="2">var entry precommit_cache.PathEntry
        if err := json.Unmarshal(data, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov3" title="2">return &amp;entry, true, nil</span>
}

// readOIDEntry reads and parses a JSON OIDEntry from disk. If the file is
// missing it returns a freshly initialized entry (with LFSOID set to the
// supplied oid and UpdatedAt set to now).
func readOIDEntry(path string, oid string, now string) (*precommit_cache.OIDEntry, error) <span class="cov10" title="9">{
        entry := &amp;precommit_cache.OIDEntry{
                LFSOID:    oid,
                Paths:     []string{},
                UpdatedAt: now,
        }
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="7">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="7">{
                        return entry, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov3" title="2">if err := json.Unmarshal(data, entry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">entry.LFSOID = oid
        return entry, nil</span>
}

// upsertOIDEntry creates or updates the OID entry for `oid`, ensuring `path`
// is listed among its Paths, updating ExternalURL when provided, and setting
// content-change/state fields. The updated entry is written atomically.
func upsertOIDEntry(cache *precommit_cache.Cache, oid, path, externalURL, now string, contentChanged bool) error <span class="cov8" title="7">{
        if cache == nil </span><span class="cov0" title="0">{
                return errors.New("cache is nil")
        }</span>
        <span class="cov8" title="7">oidFile := cacheOIDEntryFile(cache, oid)
        entry, err := readOIDEntry(oidFile, oid, now)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="7">pathSet := make(map[string]struct{}, len(entry.Paths)+1)
        for _, p := range entry.Paths </span><span class="cov0" title="0">{
                pathSet[p] = struct{}{}
        }</span>
        <span class="cov8" title="7">if path != "" </span><span class="cov8" title="7">{
                pathSet[path] = struct{}{}
        }</span>
        <span class="cov8" title="7">entry.Paths = sortedKeys(pathSet)
        entry.UpdatedAt = now
        entry.ContentChange = entry.ContentChange || contentChanged
        if strings.TrimSpace(externalURL) != "" </span><span class="cov8" title="7">{
                entry.ExternalURL = externalURL
        }</span>

        <span class="cov8" title="7">return writeJSONAtomic(oidFile, entry)</span>
}

// removePathFromOID removes `path` from the OID entry for `oid` and writes
// the updated entry atomically. Missing entries are treated as empty.
func removePathFromOID(cache *precommit_cache.Cache, oid, path, now string) error <span class="cov3" title="2">{
        if cache == nil </span><span class="cov0" title="0">{
                return errors.New("cache is nil")
        }</span>
        <span class="cov3" title="2">oidFile := cacheOIDEntryFile(cache, oid)
        entry, err := readOIDEntry(oidFile, oid, now)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">pathSet := make(map[string]struct{}, len(entry.Paths))
        for _, p := range entry.Paths </span><span class="cov3" title="2">{
                if p == path </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov0" title="0">pathSet[p] = struct{}{}</span>
        }
        <span class="cov3" title="2">entry.Paths = sortedKeys(pathSet)
        entry.UpdatedAt = now

        return writeJSONAtomic(oidFile, entry)</span>
}

// sortedKeys returns a sorted slice of keys from the provided string-set map.
func sortedKeys(set map[string]struct{}) []string <span class="cov10" title="9">{
        keys := slices.Collect(maps.Keys(set))
        slices.Sort(keys)
        return keys
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package addurl

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/cloud"
        "github.com/spf13/cobra"
)

// writePointerFile writes a Git LFS pointer file at the given worktree path
// referencing the supplied oid and recording sizeBytes. It creates parent
// directories as needed and validates the path is non-empty.
func writePointerFile(pathArg, oid string, sizeBytes int64) error <span class="cov5" title="4">{
        pointer := fmt.Sprintf(
                "version https://git-lfs.github.com/spec/v1\noid sha256:%s\nsize %d\n",
                oid, sizeBytes,
        )
        if pathArg == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("empty worktree path")
        }</span>
        <span class="cov5" title="4">safePath := filepath.Clean(pathArg)
        dir := filepath.Dir(safePath)
        if dir != "." &amp;&amp; dir != "/" </span><span class="cov5" title="4">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mkdir %s: %w", dir, err)
                }</span>
        }
        <span class="cov5" title="4">if err := os.WriteFile(safePath, []byte(pointer), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write %s: %w", safePath, err)
        }</span>

        <span class="cov5" title="4">if _, err := fmt.Fprintf(os.Stderr, "Added Git LFS pointer file at %s\n", safePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stderr write: %w", err)
        }</span>
        <span class="cov5" title="4">return nil</span>
}

// maybeTrackLFS ensures the supplied path is tracked by Git LFS by invoking
// the provided gitLFSTrack callback when the path is not already tracked.
// It reports the addition to stderr for user guidance.
func maybeTrackLFS(ctx context.Context, gitLFSTrack func(context.Context, string) (bool, error), pathArg string, isTracked bool) error <span class="cov5" title="4">{
        if isTracked </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov3" title="2">if _, err := gitLFSTrack(ctx, pathArg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git lfs track %s: %w", pathArg, err)
        }</span>

        <span class="cov3" title="2">if _, err := fmt.Fprintf(os.Stderr, "Info: Added to Git LFS. Remember to `git add %s` and `git commit ...`", pathArg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stderr write: %w", err)
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// printResolvedInfo writes a human-readable summary of resolved Git/LFS and
// S3 object information to the command's stdout for user confirmation.
func printResolvedInfo(cmd *cobra.Command, gitCommonDir, lfsRoot string, s3Info *cloud.S3Object, pathArg string, isTracked bool, sha256 string) error <span class="cov5" title="4">{
        if _, err := fmt.Fprintf(cmd.OutOrStdout(), `
Resolved Git LFS s3Info
---------------------
Git common dir : %s
LFS storage    : %s

S3 object
---------
Bucket         : %s
Key            : %s
Worktree name  : %s
Size (bytes)   : %d
SHA256 (meta)  : %s
ETag           : %s
Last modified  : %s

Worktree
-------------
path           : %s
tracked by LFS : %v
sha256 param  : %s

`,
                gitCommonDir,
                lfsRoot,
                s3Info.Bucket,
                s3Info.Key,
                s3Info.Path,
                s3Info.SizeBytes,
                s3Info.MetaSHA256,
                s3Info.ETag,
                s3Info.LastModTime.Format("2006-01-02T15:04:05Z07:00"),
                pathArg,
                isTracked,
                sha256,
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("print resolved s3Info: %w", err)
        }</span>
        <span class="cov5" title="4">return nil</span>
}

// writeJSONAtomic marshals `value` to JSON and writes it to `path` atomically
// by writing to a temporary file in the same directory and renaming it. It
// ensures parent directories exist.
func writeJSONAtomic(path string, value any) error <span class="cov10" title="16">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="16">tmp := path + ".tmp"
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="16">if err := os.WriteFile(tmp, data, 0o644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="16">return os.Rename(tmp, path)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package addurl

import (
        "context"
        "errors"
        "fmt"
        "net/url"
        "os"
        "strings"

        "github.com/calypr/git-drs/cloud"
        "github.com/spf13/cobra"
)

var Cmd = NewCommand()

// NewCommand constructs the Cobra command for the `add-url` subcommand,
// wiring usage, argument validation and the RunE handler.
func NewCommand() *cobra.Command <span class="cov10" title="97">{
        cmd := &amp;cobra.Command{
                Use:   "add-url &lt;s3-url&gt; [path]",
                Short: "Add a file to the Git DRS repo using an S3 URL",
                Args: func(cmd *cobra.Command, args []string) error </span><span class="cov3" title="3">{
                        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                                return errors.New("usage: add-url &lt;s3-url&gt; [path]")
                        }</span>
                        <span class="cov3" title="3">return nil</span>
                },
                RunE: runAddURL,
        }
        <span class="cov10" title="97">addFlags(cmd)
        return cmd</span>
}

// addFlags registers command-line flags for AWS credentials, endpoint and an
// optional `sha256` expected checksum.
func addFlags(cmd *cobra.Command) <span class="cov10" title="97">{
        cmd.Flags().String(
                cloud.AWS_KEY_FLAG_NAME,
                os.Getenv(cloud.AWS_KEY_ENV_VAR),
                "AWS access key",
        )

        cmd.Flags().String(
                cloud.AWS_SECRET_FLAG_NAME,
                os.Getenv(cloud.AWS_SECRET_ENV_VAR),
                "AWS secret key",
        )

        cmd.Flags().String(
                cloud.AWS_REGION_FLAG_NAME,
                os.Getenv(cloud.AWS_REGION_ENV_VAR),
                "AWS S3 region",
        )

        cmd.Flags().String(
                cloud.AWS_ENDPOINT_URL_FLAG_NAME,
                os.Getenv(cloud.AWS_ENDPOINT_URL_ENV_VAR),
                "AWS S3 endpoint (optional, for Ceph/MinIO)",
        )

        // New flag: optional expected SHA256
        cmd.Flags().String(
                "sha256",
                "",
                "Expected SHA256 checksum (optional)",
        )
}</span>

// runAddURL is the Cobra RunE wrapper that delegates execution to the
func runAddURL(cmd *cobra.Command, args []string) (err error) <span class="cov3" title="3">{
        return NewAddURLService().Run(cmd, args)
}</span>

// download uses cloud.AgentFetchReader to download the S3 object, returning
// the computed SHA256 and the path to the temporary downloaded file.
// The caller is responsible for moving/deleting the temporary file.
// we include this wrapper function to allow mocking in tests.
var download = func(ctx context.Context, info *cloud.S3Object, input cloud.S3ObjectParameters, lfsRoot string) (string, string, error) <span class="cov2" title="2">{
        return cloud.Download(ctx, info, input, lfsRoot)
}</span>

// addURLInput parses CLI args and flags into an addURLInput, validates
// required AWS credentials and region, and constructs cloud.S3ObjectParameters.
type addURLInput struct {
        s3URL    string
        path     string
        sha256   string
        s3Params cloud.S3ObjectParameters
}

func parseAddURLInput(cmd *cobra.Command, args []string) (addURLInput, error) <span class="cov3" title="4">{
        s3URL := args[0]

        pathArg, err := resolvePathArg(s3URL, args)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, err
        }</span>

        <span class="cov3" title="4">sha256Param, err := cmd.Flags().GetString("sha256")
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag sha256: %w", err)
        }</span>

        <span class="cov3" title="4">awsKey, err := cmd.Flags().GetString(cloud.AWS_KEY_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_KEY_FLAG_NAME, err)
        }</span>
        <span class="cov3" title="4">awsSecret, err := cmd.Flags().GetString(cloud.AWS_SECRET_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_SECRET_FLAG_NAME, err)
        }</span>
        <span class="cov3" title="4">awsRegion, err := cmd.Flags().GetString(cloud.AWS_REGION_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_REGION_FLAG_NAME, err)
        }</span>
        <span class="cov3" title="4">awsEndpoint, err := cmd.Flags().GetString(cloud.AWS_ENDPOINT_URL_FLAG_NAME)
        if err != nil </span><span class="cov0" title="0">{
                return addURLInput{}, fmt.Errorf("read flag %s: %w", cloud.AWS_ENDPOINT_URL_FLAG_NAME, err)
        }</span>

        <span class="cov3" title="4">if awsKey == "" || awsSecret == "" </span><span class="cov0" title="0">{
                return addURLInput{}, errors.New("AWS credentials must be provided via flags or environment variables")
        }</span>
        <span class="cov3" title="4">if awsRegion == "" </span><span class="cov0" title="0">{
                return addURLInput{}, errors.New("AWS region must be provided via flag or environment variable")
        }</span>

        <span class="cov3" title="4">s3Input := cloud.S3ObjectParameters{
                S3URL:           s3URL,
                AWSAccessKey:    awsKey,
                AWSSecretKey:    awsSecret,
                AWSRegion:       awsRegion,
                AWSEndpoint:     awsEndpoint,
                SHA256:          sha256Param,
                DestinationPath: pathArg,
        }

        return addURLInput{
                s3URL:    s3URL,
                path:     pathArg,
                sha256:   sha256Param,
                s3Params: s3Input,
        }, nil</span>
}

// resolvePathArg returns the explicit destination path argument when provided,
// otherwise derives the worktree path from the given S3 URL path component.
func resolvePathArg(s3URL string, args []string) (string, error) <span class="cov3" title="4">{
        if len(args) == 2 </span><span class="cov3" title="3">{
                return args[1], nil
        }</span>
        <span class="cov1" title="1">u, err := url.Parse(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return strings.TrimPrefix(u.Path, "/"), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package addurl

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"

        "github.com/calypr/data-client/drs"
        "github.com/calypr/git-drs/cloud"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

// AddURLService groups injectable dependencies used to implement the add-url
// behavior (logger factory, S3 inspection, LFS helpers, config loader, etc.).
type AddURLService struct {
        newLogger    func(string, bool) (*slog.Logger, error)
        inspectS3    func(ctx context.Context, input cloud.S3ObjectParameters) (*cloud.S3Object, error)
        isLFSTracked func(path string) (bool, error)
        getGitRoots  func(ctx context.Context) (string, string, error)
        gitLFSTrack  func(ctx context.Context, path string) (bool, error)
        loadConfig   func() (*config.Config, error)
        download     func(ctx context.Context, info *cloud.S3Object, input cloud.S3ObjectParameters, lfsRoot string) (string, string, error)
}

// NewAddURLService constructs an AddURLService populated with production
// implementations of its dependencies.
func NewAddURLService() *AddURLService <span class="cov10" title="4">{
        return &amp;AddURLService{
                newLogger:    drslog.NewLogger,
                inspectS3:    cloud.InspectS3ForLFS,
                isLFSTracked: lfs.IsLFSTracked,
                getGitRoots:  lfs.GetGitRootDirectories,
                gitLFSTrack:  lfs.GitLFSTrackReadOnly,
                loadConfig:   config.LoadConfig,
                download:     download,
        }
}</span>

// Run executes the add-url workflow: parse CLI input, inspect the S3 object,
// ensure the LFS object exists in local storage, write a Git LFS pointer file,
// update the pre-commit cache (best-effort), optionally add a git-lfs track
// entry, and record the DRS mapping.
func (s *AddURLService) Run(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
        ctx := cmd.Context()
        if ctx == nil </span><span class="cov1" title="1">{
                ctx = context.Background()
        }</span>

        <span class="cov10" title="4">logger, err := s.newLogger("", false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating logger: %v", err)
        }</span>

        <span class="cov10" title="4">input, err := parseAddURLInput(cmd, args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">s3Info, err := s.inspectS3(ctx, input.s3Params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">isTracked, err := s.isLFSTracked(input.path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check LFS tracking for %s: %w", input.path, err)
        }</span>

        <span class="cov10" title="4">gitCommonDir, lfsRoot, err := s.getGitRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get git root directories: %w", err)
        }</span>

        <span class="cov10" title="4">if err := printResolvedInfo(cmd, gitCommonDir, lfsRoot, s3Info, input.path, isTracked, input.sha256); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">oid, err := s.ensureLFSObject(ctx, s3Info, input, lfsRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">if err := writePointerFile(input.path, oid, s3Info.SizeBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">if err := updatePrecommitCache(ctx, logger, input.path, oid, input.s3URL); err != nil </span><span class="cov0" title="0">{
                logger.Warn("pre-commit cache update skipped", "error", err)
        }</span>

        <span class="cov10" title="4">if err := maybeTrackLFS(ctx, s.gitLFSTrack, input.path, isTracked); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">cfg, err := s.loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting config: %v", err)
        }</span>

        <span class="cov10" title="4">remote, err := cfg.GetDefaultRemote()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">remoteConfig := cfg.GetRemote(remote)
        if remoteConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting remote configuration for %s", remote)
        }</span>

        <span class="cov10" title="4">builder := drs.NewObjectBuilder(remoteConfig.GetBucketName(), remoteConfig.GetProjectId())

        file := lfs.LfsFileInfo{
                Name: input.path,
                Size: s3Info.SizeBytes,
                Oid:  oid,
        }
        if _, err := drsmap.WriteDrsFile(builder, file, &amp;input.s3URL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error WriteDrsFile: %v", err)
        }</span>

        <span class="cov10" title="4">return nil</span>
}

// ensureLFSObject ensures the LFS object identified by s3Info exists in the
// repository's LFS storage. If the input includes an explicit SHA256 that is
// returned immediately; otherwise the object is downloaded into a temporary
// file and moved into the LFS `objects` storage, returning the object's oid.
func (s *AddURLService) ensureLFSObject(ctx context.Context, s3Info *cloud.S3Object, input addURLInput, lfsRoot string) (string, error) <span class="cov10" title="4">{
        if input.sha256 != "" </span><span class="cov1" title="1">{
                return input.sha256, nil
        }</span>

        <span class="cov8" title="3">computedSHA, tmpObj, err := s.download(ctx, s3Info, input.s3Params, lfsRoot)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="3">oid := computedSHA
        dstDir := filepath.Join(lfsRoot, "objects", oid[0:2], oid[2:4])
        dstObj := filepath.Join(dstDir, oid)

        if err := os.MkdirAll(dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("mkdir %s: %w", dstDir, err)
        }</span>

        <span class="cov8" title="3">if err := os.Rename(tmpObj, dstObj); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("rename %s to %s: %w", tmpObj, dstObj, err)
        }</span>

        <span class="cov8" title="3">if _, err := fmt.Fprintf(os.Stderr, "Added data file at %s\n", dstObj); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("stderr write: %w", err)
        }</span>

        <span class="cov8" title="3">return computedSHA, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package delete

import (
        "context"
        "fmt"
        "os"

        "github.com/calypr/data-client/hash"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag bool
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete &lt;hash-type&gt; &lt;oid&gt;",
        Short:  "Delete a file using hash and file object ID",
        Long:   "Delete a file using file object ID. Use lfs ls-files to get oid",
        Hidden: true,
        Args:   cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                hashType, oid := args[0], args[1]

                // check hash type is valid Checksum type and sha256
                if hashType != hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                        return fmt.Errorf("only sha256 supported, you requested to remove: %s", hashType)
                }</span>

                <span class="cov1" title="1">logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov1" title="1">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        return err
                }</span>

                // Get record details before deletion for confirmation
                <span class="cov0" title="0">records, err := drsClient.GetObjectByHash(context.Background(), &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting records for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no records found for OID %s", oid)
                }</span>

                // Find matching record for current project
                <span class="cov0" title="0">projectId := drsClient.GetProjectId()
                matchingRecord, err := drsmap.FindMatchingRecord(records, projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
                }</span>
                <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no matching record found for project %s and OID %s", projectId, oid)
                }</span>

                // Show details and get confirmation unless --confirm flag is set
                <span class="cov0" title="0">if !confirmFlag </span><span class="cov0" title="0">{
                        common.DisplayWarningHeader(os.Stderr, "DELETE a DRS record")
                        common.DisplayField(os.Stderr, "Remote", string(remoteName))
                        common.DisplayField(os.Stderr, "Project", projectId)
                        common.DisplayField(os.Stderr, "OID", oid)
                        common.DisplayField(os.Stderr, "Hash Type", hashType)
                        common.DisplayField(os.Stderr, "DID", matchingRecord.Id)
                        if matchingRecord.Name != "" </span><span class="cov0" title="0">{
                                common.DisplayField(os.Stderr, "Filename", matchingRecord.Name)
                        }</span>
                        <span class="cov0" title="0">common.DisplayField(os.Stderr, "Size", fmt.Sprintf("%d bytes", matchingRecord.Size))
                        common.DisplayFooter(os.Stderr)

                        if err := common.PromptForConfirmation(
                                os.Stderr,
                                "Type 'yes' to confirm deletion",
                                common.ConfirmationYes,
                                false,
                        ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching record
                <span class="cov0" title="0">err = drsClient.DeleteRecord(context.Background(), oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting file for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully deleted record for OID %s", oid))
                return nil</span>
        },
}

func init() <span class="cov10" title="96">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVar(&amp;confirmFlag, "confirm", false, "skip interactive confirmation prompt")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package deleteproject

import (
        "context"
        "fmt"
        "os"

        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete-project &lt;project_id&gt;",
        Short:  "Delete all indexd records for a given project",
        Long:   "Delete all indexd records for a given project",
        Hidden: true,
        Args:   cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                projectId := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        return err
                }</span>

                // Cast to GitDrsIdxdClient to access GetProjectSample
                <span class="cov0" title="0">indexdClient, ok := drsClient.(*indexd.GitDrsIdxdClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("client is not an IndexDClient, cannot proceed with delete-project")
                }</span>

                // Get a sample record to show the user what will be deleted
                <span class="cov0" title="0">sampleRecords, err := indexdClient.GetProjectSample(context.Background(), projectId, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting sample records for project %s: %v", projectId, err)
                }</span>

                // Show details and get confirmation unless --confirm flag matches project_id
                <span class="cov0" title="0">if confirmFlag != "" &amp;&amp; confirmFlag != projectId </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: --confirm value '%s' does not match project ID '%s'", confirmFlag, projectId)
                }</span>
                <span class="cov0" title="0">if confirmFlag != projectId </span><span class="cov0" title="0">{
                        common.DisplayWarningHeader(os.Stderr, "DELETE ALL RECORDS for a project")
                        common.DisplayField(os.Stderr, "Remote", string(remoteName))
                        common.DisplayField(os.Stderr, "Project ID", projectId)

                        if len(sampleRecords) &gt; 0 </span><span class="cov0" title="0">{
                                sample := sampleRecords[0]
                                fmt.Fprintf(os.Stderr, "\nSample record from this project:\n")
                                common.DisplayField(os.Stderr, "  DID", sample.Id)
                                if sample.Name != "" </span><span class="cov0" title="0">{
                                        common.DisplayField(os.Stderr, "  Filename", sample.Name)
                                }</span>
                                <span class="cov0" title="0">common.DisplayField(os.Stderr, "  Size", fmt.Sprintf("%d bytes", sample.Size))
                                if sample.CreatedTime != "" </span><span class="cov0" title="0">{
                                        common.DisplayField(os.Stderr, "  Created", sample.CreatedTime)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "\nNo records found for this project.\n")
                        }</span>

                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\nThis will DELETE ALL records in project '%s'.\n", projectId)
                        common.DisplayFooter(os.Stderr)

                        if err := common.PromptForConfirmation(os.Stderr, fmt.Sprintf("Type the project ID '%s' to confirm deletion", projectId), projectId, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching records
                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Deleting all records for project %s...", projectId))
                err = drsClient.DeleteRecordsByProject(context.Background(), projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting project %s: %v", projectId, err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully deleted all records for project %s", projectId))
                return nil</span>
        },
}

func init() <span class="cov10" title="96">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVar(&amp;confirmFlag, "confirm", "", "skip interactive confirmation by providing the project_id (e.g., --confirm my-project)")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package fetch

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "fetch [remote-name]",
        Short: "fetch drs objects from remote",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) &gt; 1 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs fetch --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov6" title="2">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="2">{
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov6" title="2">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov1" title="1">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov1" title="1"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov1" title="1">{
                                logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov1" title="1">drsClient, err := cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PullRemoteDrsObjects(drsClient, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package initialize

import (
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/gitrepo"
        "github.com/spf13/cobra"
)

var (
        transfers            int
        upsert               bool
        multiPartThreshold   int
        enableDataClientLogs bool
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize repo for git-drs",
        Long: "Description:" +
                "\n  Initialize repo for git-drs",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov4" title="6">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs init --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov4" title="5">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov4" title="5">{
                logg := drslog.GetLogger()

                // check if .git dir exists to ensure you're in a git repository
                _, err := gitrepo.GitTopLevel()
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error: not in a git repository. Please run this command in the root of your git repository")
                }</span>

                // create config file if it doesn't exist
                <span class="cov3" title="4">err = config.CreateEmptyConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: unable to create config file: %v", err)
                }</span>

                // load the config
                <span class="cov3" title="4">_, err = config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("We should probably fix this: %v", err))
                        return fmt.Errorf("error: unable to load config file: %v", err)
                }</span>

                <span class="cov3" title="4">err = initGitConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error initializing custom transfer for DRS: %v", err)
                }</span>

                // install pre-push hook
                <span class="cov3" title="4">err = installPrePushHook(logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error installing pre-push hook: %v", err)
                }</span>
                // install pre-commit hook
                <span class="cov3" title="4">err = installPreCommitHook(logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error installing pre-commit hook: %v", err)
                }</span>

                // final logs
                <span class="cov3" title="4">logg.Debug("Git DRS initialized")
                logg.Debug(fmt.Sprintf("Using %d concurrent transfers", transfers))
                return nil</span>
        },
}

func initGitConfig() error <span class="cov4" title="6">{
        configs := map[string]string{
                "lfs.standalonetransferagent":                    "drs",
                "lfs.customtransfer.drs.path":                    "git-drs",
                "lfs.customtransfer.drs.args":                    "transfer",
                "lfs.allowincompletepush":                        "false",
                "lfs.customtransfer.drs.concurrent":              strconv.FormatBool(transfers &gt; 1),
                "lfs.concurrenttransfers":                        strconv.Itoa(transfers),
                "lfs.customtransfer.drs.upsert":                  strconv.FormatBool(upsert),
                "lfs.customtransfer.drs.multipart-threshold":     strconv.Itoa(multiPartThreshold),
                "lfs.customtransfer.drs.enable-data-client-logs": strconv.FormatBool(enableDataClientLogs),
        }

        if err := gitrepo.SetGitConfigOptions(configs); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write git config: %w", err)
        }</span>
        <span class="cov4" title="6">return nil</span>
}

func init() <span class="cov10" title="96">{
        Cmd.Flags().IntVarP(&amp;transfers, "transfers", "t", 1, "Number of concurrent transfers")
        Cmd.Flags().BoolVarP(&amp;upsert, "upsert", "u", false, "Enable upsert for indexd records")
        Cmd.Flags().IntVarP(&amp;multiPartThreshold, "multipart-threshold", "m", 500, "Multipart threshold in MB")
        Cmd.Flags().BoolVar(&amp;enableDataClientLogs, "enable-data-client-logs", false, "Enable data-client internal logs")
}</span>

func installPrePushHook(logger *slog.Logger) error <span class="cov4" title="6">{
        hooksDir, err := gitrepo.GetGitHooksDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get hooks directory: %w", err)
        }</span>

        <span class="cov4" title="6">if err := os.MkdirAll(hooksDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create hooks directory: %w", err)
        }</span>

        <span class="cov4" title="6">hookPath := filepath.Join(hooksDir, "pre-push")
        hookBody := `
# . git/hooks/pre-push
remote="$1"
url="$2"

# Buffer stdin for both commands
TMPFILE="${TMPDIR:-/tmp}/git-drs-$$"
trap "rm -f $TMPFILE" EXIT
cat &gt; "$TMPFILE"

# Run DRS preparation
git drs pre-push-prepare "$remote" "$url" &lt; "$TMPFILE" || exit 1

# Run LFS push
exec git lfs pre-push "$remote" "$url" &lt; "$TMPFILE"
`
        hookScript := "#!/bin/sh\n" + hookBody

        existingContent, err := os.ReadFile(hookPath)
        if err == nil </span><span class="cov3" title="3">{
                // there is an existing hook, rename it, and let the user know
                // Backup existing hook with timestamp
                timestamp := time.Now().Format("20060102T150405")
                backupPath := hookPath + "." + timestamp
                if err := os.WriteFile(backupPath, existingContent, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to back up existing pre-push hook: %w", err)
                }</span>
                <span class="cov3" title="3">if err := os.Remove(hookPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove hook after backing up: %w", err)
                }</span>
                <span class="cov3" title="3">logger.Debug(fmt.Sprintf("pre-push hook updated; backup written to %s", backupPath))</span>
        }
        // If there was an error other than expected not existing, return it
        <span class="cov4" title="6">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to read pre-push hook: %w", err)
        }</span>

        <span class="cov4" title="6">err = os.WriteFile(hookPath, []byte(hookScript), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write pre-push hook: %w", err)
        }</span>
        <span class="cov4" title="6">logger.Debug("pre-push hook installed")
        return nil</span>
}

func installPreCommitHook(logger *slog.Logger) error <span class="cov4" title="6">{
        cmd := exec.Command("git", "rev-parse", "--git-dir")
        cmdOut, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to locate git directory: %w", err)
        }</span>
        <span class="cov4" title="6">gitDir := strings.TrimSpace(string(cmdOut))
        hooksDir := filepath.Join(gitDir, "hooks")
        if err := os.MkdirAll(hooksDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create hooks directory: %w", err)
        }</span>

        <span class="cov4" title="6">hookPath := filepath.Join(hooksDir, "pre-commit")
        hookBody := `
# .git/hooks/pre-commit
exec git drs precommit
`
        hookScript := "#!/bin/sh\n" + hookBody

        existingContent, err := os.ReadFile(hookPath)
        if err == nil </span><span class="cov1" title="1">{
                // there is an existing hook, rename it, and let the user know
                // Backup existing hook with timestamp
                timestamp := time.Now().Format("20060102T150405")
                backupPath := hookPath + "." + timestamp
                if err := os.WriteFile(backupPath, existingContent, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to back up existing pre-commit hook: %w", err)
                }</span>
                <span class="cov1" title="1">if err := os.Remove(hookPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove hook after backing up: %w", err)
                }</span>
                <span class="cov1" title="1">logger.Debug(fmt.Sprintf("pre-commit hook updated; backup written to %s", backupPath))</span>
        }
        // If there was an error other than expected not existing, return it
        <span class="cov4" title="6">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to read pre-commit hook: %w", err)
        }</span>

        <span class="cov4" title="6">err = os.WriteFile(hookPath, []byte(hookScript), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write pre-commit hook: %w", err)
        }</span>
        <span class="cov4" title="6">logger.Debug("pre-commit hook installed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package precommit
// -------------------------------------
// LFS-only local cache updater for:
//   - Path -&gt; OID  : .git/drs/pre-commit/v1/paths/&lt;encoded-path&gt;.json
//   - OID  -&gt; Paths + S3 URL hint : .git/drs/pre-commit/v1/oids/&lt;oid&gt;.json
//
// This hook is intentionally:
//   - LFS-only (non-LFS paths are ignored)
//   - local-only (no network, no server index reads)
//   - index-based (reads STAGED content via `git show :&lt;path&gt;`)
//
// Note: This is a reference implementation. Adjust logging/policy as desired.
package precommit

import (
        "bufio"
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/spf13/cobra"
)

const (
        cacheVersionDir = "drs/pre-commit/v1"
        lfsSpecLine     = "version https://git-lfs.github.com/spec/v1"
)

type PathEntry struct {
        Path      string `json:"path"`
        LFSOID    string `json:"lfs_oid"`
        UpdatedAt string `json:"updated_at"`
}

type OIDEntry struct {
        LFSOID        string   `json:"lfs_oid"`
        Paths         []string `json:"paths"`
        S3URL         string   `json:"s3_url,omitempty"` // hint only; may be empty
        UpdatedAt     string   `json:"updated_at"`
        ContentChange bool     `json:"content_changed"`
}

type ChangeKind int

const (
        KindAdd ChangeKind = iota
        KindModify
        KindDelete
        KindRename
)

type Change struct {
        Kind    ChangeKind
        OldPath string // for rename
        NewPath string // for rename (and for add/modify/delete uses NewPath)
        Status  string // raw status, e.g. "A", "M", "D", "R100"
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "precommit",
        Short: "pre-commit hook to update local DRS cache",
        Long:  "Pre-commit hook that updates the local DRS pre-commit cache",
        Args:  cobra.ExactArgs(0),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="12">{
                return run(context.Background())
        }</span>,
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        if err := run(ctx); err != nil </span><span class="cov0" title="0">{
                // For a reference impl, treat errors as non-fatal unless you want strict enforcement.
                // Exiting non-zero blocks the commit.
                fmt.Fprintf(os.Stderr, "pre-commit drs cache: %v\n", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context) error <span class="cov6" title="12">{
        gitDir, err := gitRevParseGitDir(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="12">cacheRoot := filepath.Join(gitDir, cacheVersionDir)
        pathsDir := filepath.Join(cacheRoot, "paths")
        oidsDir := filepath.Join(cacheRoot, "oids")
        tombsDir := filepath.Join(cacheRoot, "tombstones")

        if err := os.MkdirAll(pathsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="12">if err := os.MkdirAll(oidsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="12">_ = os.MkdirAll(tombsDir, 0o755) // optional

        changes, err := stagedChanges(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="12">if len(changes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="12">now := time.Now().UTC().Format(time.RFC3339)

        // Process renames first so subsequent add/modify logic sees the "new" path.
        // This mirrors how we want cache paths to follow staged paths.
        for _, ch := range changes </span><span class="cov7" title="18">{
                if ch.Kind != KindRename </span><span class="cov6" title="15">{
                        continue</span>
                }
                // Only act if BOTH old and new are LFS in scope? Prefer:
                // - If the new path is LFS, we migrate.
                // - If it isn't LFS, we remove old path entry (out of scope).
                <span class="cov3" title="3">newOID, newIsLFS, err := stagedLFSOID(ctx, ch.NewPath)
                if err != nil </span><span class="cov0" title="0">{
                        // If file doesn't exist in index due to weird staging, skip.
                        continue</span>
                }

                <span class="cov3" title="3">oldPathFile := pathEntryFile(pathsDir, ch.OldPath)
                newPathFile := pathEntryFile(pathsDir, ch.NewPath)

                if newIsLFS </span><span class="cov3" title="3">{
                        // Move/overwrite path entry file
                        if err := moveFileBestEffort(oldPathFile, newPathFile); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                return fmt.Errorf("rename migrate path entry: %w", err)
                        }</span>

                        // Ensure path entry content correct
                        <span class="cov3" title="3">if err := writeJSONAtomic(newPathFile, PathEntry{
                                Path:      ch.NewPath,
                                LFSOID:    newOID,
                                UpdatedAt: now,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Update oid entry: replace old path with new path for that OID
                        <span class="cov3" title="3">if err := oidAddOrReplacePath(oidsDir, newOID, ch.OldPath, ch.NewPath, now, false); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Out of scope now: remove any cached path entry.
                        _ = os.Remove(oldPathFile)
                }</span>
        }

        // Process adds/modifies/deletes (and renames again just to ensure content correctness on new path).
        <span class="cov6" title="12">for _, ch := range changes </span><span class="cov7" title="18">{
                switch ch.Kind </span>{
                case KindAdd, KindModify:<span class="cov6" title="15">
                        if err := handleUpsert(ctx, pathsDir, oidsDir, ch.NewPath, now); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case KindRename:<span class="cov3" title="3">
                        // Treat like upsert on NewPath to ensure OID/path consistency if content also changed.
                        if err := handleUpsert(ctx, pathsDir, oidsDir, ch.NewPath, now); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Optionally also remove old path from *other* OID entry if rename+content-change changed OID.
                        // We'll do it inside handleUpsert by checking previous cached OID for that path (after move).
                case KindDelete:<span class="cov0" title="0">
                        if err := handleDelete(ctx, pathsDir, oidsDir, tombsDir, ch.NewPath, now); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov6" title="12">return nil</span>
}

func handleUpsert(ctx context.Context, pathsDir, oidsDir, path, now string) error <span class="cov7" title="20">{
        oid, isLFS, err := stagedLFSOID(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                // If file isn't in index, ignore.
                return nil
        }</span>
        <span class="cov7" title="20">if !isLFS </span><span class="cov5" title="7">{
                // Out of scope.
                return nil
        }</span>

        <span class="cov6" title="13">pathFile := pathEntryFile(pathsDir, path)

        // Load previous path entry if it exists to detect content changes.
        var prev PathEntry
        prevExists := false
        if b, err := os.ReadFile(pathFile); err == nil </span><span class="cov5" title="8">{
                _ = json.Unmarshal(b, &amp;prev)
                if prev.Path != "" &amp;&amp; prev.LFSOID != "" </span><span class="cov5" title="8">{
                        prevExists = true
                }</span>
        }

        // Write/update path entry.
        <span class="cov6" title="13">if err := writeJSONAtomic(pathFile, PathEntry{
                Path:      path,
                LFSOID:    oid,
                UpdatedAt: now,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update OID entry for new oid: add path.
        <span class="cov6" title="13">contentChanged := prevExists &amp;&amp; prev.LFSOID != oid
        if err := oidAddOrReplacePath(oidsDir, oid, "", path, now, contentChanged); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If content changed, remove path from the *old* oid entry (best effort).
        <span class="cov6" title="13">if contentChanged </span><span class="cov4" title="5">{
                _ = oidRemovePath(oidsDir, prev.LFSOID, path, now)
        }</span>

        <span class="cov6" title="13">return nil</span>
}

func handleDelete(ctx context.Context, pathsDir, oidsDir, tombsDir, path, now string) error <span class="cov0" title="0">{
        // Only consider deletion if it was previously an LFS entry (cache-driven).
        pathFile := pathEntryFile(pathsDir, path)
        b, err := os.ReadFile(pathFile)
        if err != nil </span><span class="cov0" title="0">{
                // nothing to do
                return nil
        }</span>
        <span class="cov0" title="0">var pe PathEntry
        if err := json.Unmarshal(b, &amp;pe); err != nil </span><span class="cov0" title="0">{
                // corrupted cache; remove it
                _ = os.Remove(pathFile)
                return nil
        }</span>
        // Remove path entry.
        <span class="cov0" title="0">_ = os.Remove(pathFile)

        // Remove this path from the old oid entry (best effort).
        if pe.LFSOID != "" </span><span class="cov0" title="0">{
                _ = oidRemovePath(oidsDir, pe.LFSOID, path, now)
        }</span>

        // Optional tombstone.
        <span class="cov0" title="0">tombFile := filepath.Join(tombsDir, encodePath(path)+".json")
        _ = writeJSONAtomic(tombFile, map[string]string{
                "path":       path,
                "deleted_at": now,
        })

        return nil</span>
}

// stagedChanges parses: git diff --cached --name-status -M
// Formats:
//
//        A&lt;TAB&gt;path
//        M&lt;TAB&gt;path
//        D&lt;TAB&gt;path
//        R100&lt;TAB&gt;old&lt;TAB&gt;new
func stagedChanges(ctx context.Context) ([]Change, error) <span class="cov6" title="12">{
        out, err := git(ctx, "diff", "--cached", "--name-status", "-M")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="12">var changes []Change
        sc := bufio.NewScanner(bytes.NewReader(out))
        for sc.Scan() </span><span class="cov7" title="18">{
                line := sc.Text()
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="18">parts := strings.Split(line, "\t")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="18">status := parts[0]
                switch </span>{
                case status == "A":<span class="cov5" title="8">
                        changes = append(changes, Change{Kind: KindAdd, NewPath: parts[1], Status: status})</span>
                case status == "M":<span class="cov5" title="7">
                        changes = append(changes, Change{Kind: KindModify, NewPath: parts[1], Status: status})</span>
                case status == "D":<span class="cov0" title="0">
                        changes = append(changes, Change{Kind: KindDelete, NewPath: parts[1], Status: status})</span>
                case strings.HasPrefix(status, "R") &amp;&amp; len(parts) &gt;= 3:<span class="cov3" title="3">
                        changes = append(changes, Change{Kind: KindRename, OldPath: parts[1], NewPath: parts[2], Status: status})</span>
                default:<span class="cov0" title="0"></span>
                        // ignore other statuses (C, T, U, etc) for this reference impl
                }
        }
        <span class="cov6" title="12">if err := sc.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="12">return changes, nil</span>
}

// stagedLFSOID returns (oid, isLFS, err) based on STAGED content.
// isLFS is true only if the staged file is a valid LFS pointer with an oid sha256 line.
func stagedLFSOID(ctx context.Context, path string) (string, bool, error) <span class="cov7" title="23">{
        out, err := git(ctx, "show", ":"+path)
        if err != nil </span><span class="cov0" title="0">{
                // path may not exist in index (deleted/intent-to-add weirdness)
                return "", false, err
        }</span>

        // Fast parse: look for spec line and oid line near top.
        // LFS pointer files are small; scanning full content is fine.
        <span class="cov7" title="23">var hasSpec bool
        var oid string

        sc := bufio.NewScanner(bytes.NewReader(out))
        for sc.Scan() </span><span class="cov9" title="43">{
                line := sc.Text()
                if line == lfsSpecLine </span><span class="cov7" title="16">{
                        hasSpec = true
                        continue</span>
                }
                <span class="cov8" title="27">if strings.HasPrefix(line, "oid sha256:") </span><span class="cov7" title="16">{
                        hex := strings.TrimPrefix(line, "oid sha256:")
                        hex = strings.TrimSpace(hex)
                        if hex != "" </span><span class="cov7" title="16">{
                                oid = "sha256:" + hex
                        }</span>
                        // keep scanning a bit in case spec is below (rare), but we can break once both are found.
                }
                // pointer usually has only a few lines; stop early after 10 lines
                <span class="cov8" title="27">if hasSpec &amp;&amp; oid != "" </span><span class="cov7" title="16">{
                        break</span>
                }
        }
        <span class="cov7" title="23">if err := sc.Err(); err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov7" title="23">if hasSpec &amp;&amp; oid != "" </span><span class="cov7" title="16">{
                return oid, true, nil
        }</span>
        <span class="cov5" title="7">return "", false, nil</span>
}

func gitRevParseGitDir(ctx context.Context) (string, error) <span class="cov6" title="12">{
        out, err := git(ctx, "rev-parse", "--git-dir")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="12">gitDir := strings.TrimSpace(string(out))
        if gitDir == "" </span><span class="cov0" title="0">{
                return "", errors.New("could not determine .git dir")
        }</span>
        // If gitDir is relative, resolve relative to repo root
        <span class="cov6" title="12">if !filepath.IsAbs(gitDir) </span><span class="cov6" title="12">{
                rootOut, err := git(ctx, "rev-parse", "--show-toplevel")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov6" title="12">root := strings.TrimSpace(string(rootOut))
                gitDir = filepath.Join(root, gitDir)</span>
        }
        <span class="cov6" title="12">return gitDir, nil</span>
}

func git(ctx context.Context, args ...string) ([]byte, error) <span class="cov10" title="59">{
        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Env = os.Environ()
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // include stderr for debugging; dont leak massive output
                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("git %s: %s", strings.Join(args, " "), msg)</span>
        }
        <span class="cov10" title="59">return stdout.Bytes(), nil</span>
}

// pathEntryFile maps a repo-relative path to a cache file location.
// We keep a deterministic encoding so any path maps to exactly one file.
func pathEntryFile(pathsDir, path string) string <span class="cov7" title="21">{
        return filepath.Join(pathsDir, encodePath(path)+".json")
}</span>

func encodePath(path string) string <span class="cov7" title="21">{
        // base64url encoding of the UTF-8 path string (no padding) is simple and safe.
        return base64.RawURLEncoding.EncodeToString([]byte(path))
}</span>

func oidEntryFile(oidsDir, oid string) string <span class="cov7" title="22">{
        // OID contains ":"; make it filesystem safe but still human readable.
        // Use a stable transform; here: sha256 of oid string to avoid path length issues.
        sum := sha256.Sum256([]byte(oid))
        return filepath.Join(oidsDir, fmt.Sprintf("%x.json", sum[:]))
}</span>

// oidAddOrReplacePath:
// - loads oid entry (if exists)
// - adds newPath to paths[]
// - if oldPath != "" and present, replaces it with newPath
// - sets ContentChange flag if requested (ORed into existing flag)
// - preserves existing s3_url hint
func oidAddOrReplacePath(oidsDir, oid, oldPath, newPath, now string, contentChanged bool) error <span class="cov7" title="16">{
        f := oidEntryFile(oidsDir, oid)

        entry := OIDEntry{
                LFSOID:    oid,
                Paths:     []string{},
                UpdatedAt: now,
        }
        if b, err := os.ReadFile(f); err == nil </span><span class="cov4" title="6">{
                _ = json.Unmarshal(b, &amp;entry)
                // ensure oid is set even if old file was incomplete
                entry.LFSOID = oid
        }</span>

        <span class="cov7" title="16">paths := make(map[string]struct{}, len(entry.Paths)+1)
        for _, p := range entry.Paths </span><span class="cov4" title="6">{
                paths[p] = struct{}{}
        }</span>

        <span class="cov7" title="16">if oldPath != "" </span><span class="cov3" title="3">{
                delete(paths, oldPath)
        }</span>
        <span class="cov7" title="16">if newPath != "" </span><span class="cov7" title="16">{
                paths[newPath] = struct{}{}
        }</span>

        <span class="cov7" title="16">entry.Paths = keysSorted(paths)
        entry.UpdatedAt = now
        entry.ContentChange = entry.ContentChange || contentChanged

        return writeJSONAtomic(f, entry)</span>
}

func oidRemovePath(oidsDir, oid, path, now string) error <span class="cov4" title="5">{
        f := oidEntryFile(oidsDir, oid)

        b, err := os.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">var entry OIDEntry
        if err := json.Unmarshal(b, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">paths := make(map[string]struct{}, len(entry.Paths))
        for _, p := range entry.Paths </span><span class="cov4" title="5">{
                if p == path </span><span class="cov4" title="5">{
                        continue</span>
                }
                <span class="cov0" title="0">paths[p] = struct{}{}</span>
        }
        <span class="cov4" title="5">entry.Paths = keysSorted(paths)
        entry.UpdatedAt = now

        // If no paths remain, keep the file (it may still hold s3_url hint) or delete it.
        // This ADR allows stale entries; keeping is fine. Optionally delete when empty:
        // if len(entry.Paths) == 0 &amp;&amp; entry.S3URL == "" { return os.Remove(f) }

        return writeJSONAtomic(f, entry)</span>
}

func keysSorted(m map[string]struct{}) []string <span class="cov7" title="21">{
        out := make([]string, 0, len(m))
        for k := range m </span><span class="cov7" title="16">{
                out = append(out, k)
        }</span>
        <span class="cov7" title="21">sort.Strings(out)
        return out</span>
}

// writeJSONAtomic writes JSON to a temp file then renames it into place.
// This avoids partially written cache files if the process is interrupted.
func writeJSONAtomic(path string, v any) error <span class="cov8" title="37">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="37">tmp := path + ".tmp"
        f, err := os.OpenFile(tmp, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="37">defer func() </span><span class="cov8" title="37">{ _ = f.Close() }</span>()

        <span class="cov8" title="37">enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        if err := enc.Encode(v); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmp)
                return err
        }</span>
        <span class="cov8" title="37">if err := f.Sync(); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmp)
                return err
        }</span>
        <span class="cov8" title="37">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmp)
                return err
        }</span>
        <span class="cov8" title="37">return os.Rename(tmp, path)</span>
}

func moveFileBestEffort(src, dst string) error <span class="cov3" title="3">{
        // Ensure destination directory exists.
        if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Rename will fail across devices; fall back to copy+remove.
        <span class="cov3" title="3">if err := os.Rename(src, dst); err == nil </span><span class="cov3" title="3">{
                return nil
        }</span> else<span class="cov0" title="0"> if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">in, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer in.Close()

        out, err := os.OpenFile(dst, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := io.Copy(out, in); err != nil </span><span class="cov0" title="0">{
                _ = out.Close()
                return err
        }</span>
        <span class="cov0" title="0">if err := out.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.Remove(src)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package prepush

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "os/exec"
        "sort"
        "strings"
        "time"

        "github.com/calypr/data-client/drs"
        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/precommit_cache"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "pre-push-prepare",
        Short: "pre-push hook to update DRS objects",
        Long:  "Pre-push hook that updates DRS objects before transfer",
        Args:  cobra.RangeArgs(0, 2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov7" title="6">{
                return NewPrePushService().Run(args, os.Stdin)
        }</span>,
}

type PrePushService struct {
        newLogger        func(string, bool) (*slog.Logger, error)
        loadConfig       func() (*config.Config, error)
        updateDrsObjects func(drs.ObjectBuilder, map[string]lfs.LfsFileInfo, drsmap.UpdateOptions) error
        createTempFile   func(dir, pattern string) (*os.File, error)
}

func NewPrePushService() *PrePushService <span class="cov7" title="6">{
        return &amp;PrePushService{
                newLogger:        drslog.NewLogger,
                loadConfig:       config.LoadConfig,
                updateDrsObjects: drsmap.UpdateDrsObjectsWithFiles,
                createTempFile:   os.CreateTemp,
        }
}</span>

func (s *PrePushService) Run(args []string, stdin io.Reader) error <span class="cov7" title="6">{
        ctx := context.Background()
        myLogger, err := s.newLogger("", false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating logger: %v", err)
        }</span>

        <span class="cov7" title="6">myLogger.Info("~~~~~~~~~~~~~ START: pre-push ~~~~~~~~~~~~~")

        cfg, err := s.loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting config: %v", err)
        }</span>

        <span class="cov7" title="6">gitRemoteName, gitRemoteLocation := parseRemoteArgs(args)
        myLogger.Debug(fmt.Sprintf("git remote name: %s, git remote location: %s", gitRemoteName, gitRemoteLocation))

        remote, err := cfg.GetDefaultRemote()
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Debug(fmt.Sprintf("Warning. Error getting default remote: %v", err))
                fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting default remote:", err)
                return nil
        }</span>

        // get the remote client
        <span class="cov7" title="6">cli, err := cfg.GetRemoteClient(remote, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                // Print warning to stderr and return success (exit 0)
                fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting remote client:", err)
                myLogger.Debug(fmt.Sprintf("Warning. Skipping DRS preparation. Error getting remote client: %v", err))
                // Check for GitDrsIdxdClient
        }</span>
        <span class="cov7" title="6">dc, ok := cli.(*indexd.GitDrsIdxdClient)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("cli is not IndexdClient: %T", cli)
        }</span>
        <span class="cov7" title="6">myLogger.Debug(fmt.Sprintf("Current server: %s", dc.Config.ProjectId))
        remoteConfig := cfg.GetRemote(remote)
        if remoteConfig == nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting remote configuration.")
                myLogger.Debug("Warning. Skipping DRS preparation. Error getting remote configuration.")
                return nil
        }</span>

        <span class="cov7" title="6">builder := drs.NewObjectBuilder(remoteConfig.GetBucketName(), remoteConfig.GetProjectId())
        myLogger.Debug(fmt.Sprintf("Current server project: %s", builder.ProjectID))

        tmp, err := bufferStdin(stdin, s.createTempFile)
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("error buffering stdin: %v", err))
                return err
        }</span>
        <span class="cov7" title="6">defer func() </span><span class="cov7" title="6">{
                _ = tmp.Close()
                _ = os.Remove(tmp.Name())
        }</span>()

        <span class="cov7" title="6">refs, err := readPushedRefs(tmp)
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("error reading pushed refs: %v", err))
                return err
        }</span>
        <span class="cov7" title="6">branches := branchesFromRefs(refs)

        cache, cacheReady := openCache(ctx, myLogger)
        lfsFiles, usedCache, err := collectLfsFiles(ctx, cache, cacheReady, gitRemoteName, gitRemoteLocation, branches, refs, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("error collecting LFS files: %v", err))
                return err
        }</span>

        <span class="cov7" title="6">myLogger.Debug(fmt.Sprintf("Preparing DRS objects for push branches: %v (cache=%v)", branches, usedCache))
        err = s.updateDrsObjects(builder, lfsFiles, drsmap.UpdateOptions{
                Cache:          cache,
                PreferCacheURL: usedCache,
                Logger:         myLogger,
        })
        if err != nil </span><span class="cov0" title="0">{
                myLogger.Error(fmt.Sprintf("UpdateDrsObjects failed: %v", err))
                return err
        }</span>
        <span class="cov7" title="6">myLogger.Info("~~~~~~~~~~~~~ COMPLETED: pre-push ~~~~~~~~~~~~~")
        return nil</span>
}

func parseRemoteArgs(args []string) (string, string) <span class="cov7" title="6">{
        var gitRemoteName, gitRemoteLocation string
        if len(args) &gt;= 1 </span><span class="cov7" title="6">{
                gitRemoteName = args[0]
        }</span>
        <span class="cov7" title="6">if len(args) &gt;= 2 </span><span class="cov7" title="6">{
                gitRemoteLocation = args[1]
        }</span>
        <span class="cov7" title="6">if gitRemoteName == "" </span><span class="cov0" title="0">{
                gitRemoteName = "origin"
        }</span>
        <span class="cov7" title="6">return gitRemoteName, gitRemoteLocation</span>
}

type pushedRef struct {
        LocalRef  string
        LocalSHA  string
        RemoteRef string
        RemoteSHA string
}

func bufferStdin(stdin io.Reader, createTempFile func(dir, pattern string) (*os.File, error)) (*os.File, error) <span class="cov7" title="6">{
        tmp, err := createTempFile("", "prepush-stdin-*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating temp file for stdin: %w", err)
        }</span>

        <span class="cov7" title="6">if _, err := io.Copy(tmp, stdin); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error buffering stdin: %w", err)
        }</span>

        <span class="cov7" title="6">if _, err := tmp.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error seeking temp stdin: %w", err)
        }</span>
        <span class="cov7" title="6">return tmp, nil</span>
}

// readPushedBranches reads git push lines from the provided temp file,
// extracts unique local branch names for refs under `refs/heads/` and
// returns them sorted. The file is rewound to the start before returning.
func readPushedRefs(f io.ReadSeeker) ([]pushedRef, error) <span class="cov7" title="6">{
        // Ensure we read from start
        // example:
        // refs/heads/main 67890abcdef1234567890abcdef1234567890abcd refs/heads/main 12345abcdef67890abcdef1234567890abcdef12
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">scanner := bufio.NewScanner(f)
        refs := make([]pushedRef, 0)
        for scanner.Scan() </span><span class="cov7" title="6">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &lt; 4 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="6">refs = append(refs, pushedRef{
                        LocalRef:  fields[0],
                        LocalSHA:  fields[1],
                        RemoteRef: fields[2],
                        RemoteSHA: fields[3],
                })</span>
        }
        <span class="cov7" title="6">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Rewind so caller can reuse the file
        <span class="cov7" title="6">if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">return refs, nil</span>
}

func branchesFromRefs(refs []pushedRef) []string <span class="cov7" title="6">{
        const prefix = "refs/heads/"
        set := make(map[string]struct{})
        for _, ref := range refs </span><span class="cov7" title="6">{
                if strings.HasPrefix(ref.LocalRef, prefix) </span><span class="cov7" title="6">{
                        branch := strings.TrimPrefix(ref.LocalRef, prefix)
                        if branch != "" </span><span class="cov7" title="6">{
                                set[branch] = struct{}{}
                        }</span>
                }
        }
        <span class="cov7" title="6">branches := make([]string, 0, len(set))
        for b := range set </span><span class="cov7" title="6">{
                branches = append(branches, b)
        }</span>
        <span class="cov7" title="6">sort.Strings(branches)
        return branches</span>
}

func openCache(ctx context.Context, logger *slog.Logger) (*precommit_cache.Cache, bool) <span class="cov7" title="6">{
        cache, err := precommit_cache.Open(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("pre-commit cache unavailable: %v", err))
                return nil, false
        }</span>
        <span class="cov7" title="6">if _, err := os.Stat(cache.Root); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        logger.Debug("pre-commit cache missing; continuing without cache")
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug(fmt.Sprintf("pre-commit cache access error: %v", err))
                }</span>
                <span class="cov0" title="0">return nil, false</span>
        }
        <span class="cov7" title="6">return cache, true</span>
}

func collectLfsFiles(ctx context.Context, cache *precommit_cache.Cache, cacheReady bool, gitRemoteName, gitRemoteLocation string, branches []string, refs []pushedRef, logger *slog.Logger) (map[string]lfs.LfsFileInfo, bool, error) <span class="cov7" title="6">{
        if cacheReady </span><span class="cov7" title="6">{
                lfsFiles, ok, err := lfsFilesFromCache(ctx, cache, refs, logger)
                if err != nil </span><span class="cov3" title="2">{
                        logger.Debug(fmt.Sprintf("pre-commit cache read failed: %v", err))
                }</span> else<span class="cov6" title="4"> if ok </span><span class="cov0" title="0">{
                        return lfsFiles, true, nil
                }</span>
                <span class="cov7" title="6">logger.Debug("pre-commit cache incomplete or stale; falling back to LFS discovery")</span>
        }
        <span class="cov7" title="6">lfsFiles, err := lfs.GetAllLfsFiles(gitRemoteName, gitRemoteLocation, branches, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov7" title="6">return lfsFiles, false, nil</span>
}

const cacheMaxAge = 24 * time.Hour

func lfsFilesFromCache(ctx context.Context, cache *precommit_cache.Cache, refs []pushedRef, logger *slog.Logger) (map[string]lfs.LfsFileInfo, bool, error) <span class="cov8" title="8">{
        if cache == nil </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>
        <span class="cov8" title="8">paths, err := listPushedPaths(ctx, refs)
        if err != nil </span><span class="cov3" title="2">{
                return nil, false, err
        }</span>
        <span class="cov7" title="6">lfsFiles := make(map[string]lfs.LfsFileInfo, len(paths))
        for _, path := range paths </span><span class="cov7" title="6">{
                entry, ok, err := cache.ReadPathEntry(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>
                <span class="cov7" title="6">if !ok || entry.LFSOID == "" </span><span class="cov6" title="4">{
                        return nil, false, nil
                }</span>
                <span class="cov3" title="2">if entry.UpdatedAt == "" || precommit_cache.StaleAfter(entry.UpdatedAt, cacheMaxAge) </span><span class="cov1" title="1">{
                        return nil, false, nil
                }</span>
                <span class="cov1" title="1">stat, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("cache path stat failed for %s: %v", path, err))
                        return nil, false, nil
                }</span>
                <span class="cov1" title="1">lfsFiles[path] = lfs.LfsFileInfo{
                        Name:    path,
                        Size:    stat.Size(),
                        OidType: "sha256",
                        Oid:     entry.LFSOID,
                        Version: "https://git-lfs.github.com/spec/v1",
                }</span>
        }
        <span class="cov1" title="1">return lfsFiles, true, nil</span>
}

func listPushedPaths(ctx context.Context, refs []pushedRef) ([]string, error) <span class="cov8" title="8">{
        const zeroSHA = "0000000000000000000000000000000000000000"
        set := make(map[string]struct{})
        for _, ref := range refs </span><span class="cov8" title="8">{
                if ref.LocalSHA == "" || ref.LocalSHA == zeroSHA </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="8">var args []string
                if ref.RemoteSHA == "" || ref.RemoteSHA == zeroSHA </span><span class="cov1" title="1">{
                        args = []string{"ls-tree", "-r", "--name-only", ref.LocalSHA}
                }</span> else<span class="cov8" title="7"> {
                        args = []string{"diff", "--name-only", ref.RemoteSHA, ref.LocalSHA}
                }</span>
                <span class="cov8" title="8">out, err := gitOutput(ctx, args...)
                if err != nil </span><span class="cov3" title="2">{
                        return nil, err
                }</span>
                <span class="cov7" title="6">for _, line := range strings.Split(strings.TrimSpace(out), "\n") </span><span class="cov10" title="12">{
                        line = strings.TrimSpace(line)
                        if line == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov10" title="12">set[line] = struct{}{}</span>
                }
        }
        <span class="cov7" title="6">paths := make([]string, 0, len(set))
        for path := range set </span><span class="cov10" title="12">{
                paths = append(paths, path)
        }</span>
        <span class="cov7" title="6">sort.Strings(paths)
        return paths, nil</span>
}

func gitOutput(ctx context.Context, args ...string) (string, error) <span class="cov8" title="8">{
        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Env = os.Environ()
        out, err := cmd.Output()
        if err != nil </span><span class="cov3" title="2">{
                return "", fmt.Errorf("git %s: %s", strings.Join(args, " "), strings.TrimSpace(string(out)))
        }</span>
        <span class="cov7" title="6">return string(out), nil</span>
}

// readPushedBranches reads git push lines from the provided temp file,
// extracts unique local branch names for refs under `refs/heads/` and
// returns them sorted. The file is rewound to the start before returning.
func readPushedBranches(f *os.File) ([]string, error) <span class="cov6" title="5">{
        // Ensure we read from start
        // example:
        // refs/heads/main 67890abcdef1234567890abcdef1234567890abcd refs/heads/main 12345abcdef67890abcdef1234567890abcdef12
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="5">scanner := bufio.NewScanner(f)
        set := make(map[string]struct{})
        for scanner.Scan() </span><span class="cov7" title="6">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="6">localRef := fields[0]
                const prefix = "refs/heads/"
                if strings.HasPrefix(localRef, prefix) </span><span class="cov6" title="4">{
                        branch := strings.TrimPrefix(localRef, prefix)
                        if branch != "" </span><span class="cov6" title="4">{
                                set[branch] = struct{}{}
                        }</span>
                }
        }
        <span class="cov6" title="5">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="5">branches := make([]string, 0, len(set))
        for b := range set </span><span class="cov6" title="4">{
                branches = append(branches, b)
        }</span>
        <span class="cov6" title="5">sort.Strings(branches)
        // Rewind so caller can reuse the file
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="5">return branches, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package push

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "push [remote-name]",
        Short: "push local objects to drs server.",
        Long:  "push local objects to drs server. Any local files that do not have drs records are written to a bucket.",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) &gt; 1 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs push --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov6" title="2">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="2">{
                myLogger := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error loading config: %v", err))
                        return err
                }</span>

                <span class="cov6" title="2">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov6" title="2"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov6" title="2">{
                                myLogger.Debug(fmt.Sprintf("Error getting default remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error creating indexd client: %s", err))
                        return err
                }</span>

                //// Check for GitDrsIdxdClient
                //icli, ok := drsClient.(*indexd.GitDrsIdxdClient)
                //if !ok {
                //        return fmt.Errorf("remote client is not an *indexdCl.IndexDClient (got %T), cannot push", drsClient)
                //}

                <span class="cov0" title="0">err = drsmap.PushLocalDrsObjects(drsClient, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package query

import (
        "context"
        "fmt"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

// printDRSObject marshals and prints a DRS object based on the pretty flag
func printDRSObject(obj drs.DRSObject, pretty bool) error <span class="cov2" title="2">{
        var out []byte
        var err error

        if pretty </span><span class="cov1" title="1">{
                out, err = sonic.ConfigFastest.MarshalIndent(obj, "", "  ")
        }</span> else<span class="cov1" title="1"> {
                out, err = sonic.ConfigFastest.Marshal(obj)
        }</span>

        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">fmt.Printf("%s\n", string(out))
        return nil</span>
}

var remote string
var checksum = false
var pretty = false

type checksumClient interface {
        GetObjectByHash(ctx context.Context, hash *hash.Checksum) ([]drs.DRSObject, error)
}

func queryByChecksum(client checksumClient, checksum string) ([]drs.DRSObject, error) <span class="cov3" title="4">{
        // Auto-detect checksum type based on hash length
        checksumType := hash.ChecksumTypeSHA256
        switch len(checksum) </span>{
        case 32:<span class="cov1" title="1">
                // 128-bit / 32-hex-character checksum (e.g., MD5)
                checksumType = hash.ChecksumTypeMD5</span>
        case 40:<span class="cov1" title="1">
                // 160-bit / 40-hex-character checksum (e.g., SHA1)
                checksumType = hash.ChecksumTypeSHA1</span>
        case 64:<span class="cov1" title="1">
                // 256-bit / 64-hex-character checksum (e.g., SHA256)
                checksumType = hash.ChecksumTypeSHA256</span>
        case 128:<span class="cov1" title="1">
                // 512-bit / 128-hex-character checksum (e.g., SHA512)
                checksumType = hash.ChecksumTypeSHA512</span>
        }

        <span class="cov3" title="4">return client.GetObjectByHash(context.Background(), &amp;hash.Checksum{
                Checksum: checksum,
                Type:     checksumType,
        })</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "query &lt;drs_id&gt;",
        Short: "Query DRS server by DRS ID",
        Long:  "Query DRS server by DRS ID",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (DRS ID), received %d\n\nUsage: %s\n\nSee 'git drs query --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                config, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := config.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">client, err := config.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var obj *drs.DRSObject

                if checksum </span><span class="cov0" title="0">{
                        objs, err := queryByChecksum(client, args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, drsObj := range objs </span><span class="cov0" title="0">{
                                if err := printDRSObject(drsObj, pretty); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        obj, err = client.GetObject(context.Background(), args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := printDRSObject(*obj, pretty); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="96">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVarP(&amp;checksum, "checksum", "c", checksum, "Find by checksum")
        Cmd.Flags().BoolVarP(&amp;pretty, "pretty", "p", pretty, "Print indented JSON")
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package add

import (
        "fmt"
        "log/slog"

        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
)

var AnvilCmd = &amp;cobra.Command{
        Use: "anvil [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add anvil --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return fmt.Errorf("error: anvil remote is not yet implemented. Use 'git drs remote add gen3' instead. See 'git drs remote add gen3 --help' for more details")
        }</span>,
}

func anvilInit(terraProject string, logger *slog.Logger) error <span class="cov0" title="0">{
        // make sure terra project is provided
        if terraProject != "" </span><span class="cov0" title="0">{
                // populate anvil config
                remoteAnvil := config.RemoteSelect{
                        Anvil: &amp;anvil_client.AnvilRemote{
                                Endpoint: anvil_client.ANVIL_ENDPOINT,
                                Auth: anvil_client.AnvilAuth{
                                        TerraProject: terraProject,
                                },
                        },
                }
                // TODO: different than ORIGIN?
                remoteName := config.Remote(config.AnvilServerType)
                _, err := config.UpdateRemote(remoteName, remoteAnvil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error: unable to update config file: %v\n", err)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package add

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/calypr/data-client/conf"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var Gen3Cmd = &amp;cobra.Command{
        Use: "gen3 [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add gen3 --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                logg := drslog.GetLogger()

                // make sure at least one of the credentials params is provided
                if credFile == "" &amp;&amp; fenceToken == "" &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a credentials file or accessToken to setup project locally. Please provide either a --cred or --token flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                // When adding a new remote, bucket field is required.
                <span class="cov10" title="4">if bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a bucket name to be specified when adding a new remote. Please specify a bucket with --bucket flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                <span class="cov10" title="4">remoteName := config.ORIGIN
                if len(args) &gt; 0 </span><span class="cov10" title="4">{
                        remoteName = args[0]
                }</span>

                <span class="cov10" title="4">err := gen3Init(remoteName, credFile, fenceToken, project, bucket, logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error configuring gen3 server: %v", err)
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
}

func gen3Init(remoteName, credFile, fenceToken, project, bucket string, logg *slog.Logger) error <span class="cov10" title="4">{
        if remoteName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote name is required")
        }</span>
        <span class="cov10" title="4">if project == "" || bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project and bucket are required for Gen3 remote")
        }</span>

        <span class="cov10" title="4">var accessToken, apiKey, keyID, apiEndpoint string
        configure := conf.NewConfigure(logg)
        switch </span>{
        case fenceToken != "":<span class="cov0" title="0">
                accessToken = fenceToken
                var err error
                apiEndpoint, err = common.ParseAPIEndpointFromToken(accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from provided access token: %w", err)
                }</span>

        case credFile != "":<span class="cov10" title="4">
                cred, err := configure.Import(credFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read credentials file %s: %w", credFile, err)
                }</span>
                <span class="cov10" title="4">accessToken = cred.AccessToken
                apiKey = cred.APIKey
                keyID = cred.KeyID

                apiEndpoint, err = common.ParseAPIEndpointFromToken(cred.APIKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from API key in credentials file: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                existing, err := configure.Load(remoteName)
                if err == nil </span><span class="cov0" title="0">{
                        accessToken = existing.AccessToken
                        apiKey = existing.APIKey
                        keyID = existing.KeyID
                        apiEndpoint = existing.APIEndpoint
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("must provide either --cred or --token (or have existing profile %s)", remoteName)
                }</span>
        }

        <span class="cov10" title="4">if apiEndpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not determine Gen3 API endpoint")
        }</span>

        <span class="cov10" title="4">remoteGen3 := config.RemoteSelect{
                Gen3: &amp;indexd.Gen3Remote{
                        Endpoint:  apiEndpoint,
                        ProjectID: project,
                        Bucket:    bucket,
                },
        }

        remote := config.Remote(remoteName)
        if _, err := config.UpdateRemote(remote, remoteGen3); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update remote config: %w", err)
        }</span>
        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Remote added/updated: %s  %s (project: %s, bucket: %s)", remoteName, apiEndpoint, project, bucket))

        // Step 3: Ensure credential profile is up-to-date (refreshes token if needed)
        cred := &amp;conf.Credential{
                Profile:            remoteName,
                APIEndpoint:        apiEndpoint,
                APIKey:             apiKey,
                KeyID:              keyID,
                AccessToken:        accessToken, // may be stale
                UseShepherd:        "false",     // or preserve from existing?
                MinShepherdVersion: "",
        }

        gen3Logger := logs.NewGen3Logger(logg, "", remoteName)
        if err := g3client.EnsureValidCredential(context.Background(), cred, configure, gen3Logger, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify/refresh Gen3 credential: %w", err)
        }</span>

        <span class="cov10" title="4">if err := configure.Save(cred); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure/update Gen3 profile: %w", err)
        }</span>

        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Gen3 profile '%s' configured and token refreshed successfully", remoteName))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package add

import "github.com/spf13/cobra"

var (
        server       string
        apiEndpoint  string
        bucket       string
        credFile     string
        fenceToken   string
        project      string
        terraProject string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "add",
        Short: "add server access for git-drs",
}

func init() <span class="cov10" title="97">{
        Gen3Cmd.Flags().StringVar(&amp;server, "server", "gen3", "Options for DRS server: gen3 or anvil")
        Gen3Cmd.Flags().StringVar(&amp;apiEndpoint, "url", "", "[gen3] Specify the API endpoint of the data commons")
        Gen3Cmd.Flags().StringVar(&amp;bucket, "bucket", "", "[gen3] Specify the bucket name")
        Gen3Cmd.Flags().StringVar(&amp;credFile, "cred", "", "[gen3] Specify the gen3 credential file that you want to use")
        Gen3Cmd.Flags().StringVar(&amp;fenceToken, "token", "", "[gen3] Specify the token to be used as a replacement for a credential file for temporary access")
        Gen3Cmd.Flags().StringVar(&amp;project, "project", "", "[gen3] Specify the gen3 project ID in the format &lt;program&gt;-&lt;project&gt;")
        AnvilCmd.Flags().StringVar(&amp;terraProject, "terraProject", "", "[AnVIL] Specify the Terra project ID")

        Cmd.AddCommand(Gen3Cmd)
        Cmd.AddCommand(AnvilCmd)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS repos",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="2">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs remote list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov1" title="1">{
                logg := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("Error loading config: %s", err))
                        return err
                }</span>

                <span class="cov1" title="1">for name, remoteSelect := range cfg.Remotes </span><span class="cov1" title="1">{
                        // Determine if this is the default
                        isDefault := name == cfg.DefaultRemote
                        marker := " "
                        if isDefault </span><span class="cov1" title="1">{
                                marker = "*"
                        }</span>

                        // Determine remote type and endpoint
                        <span class="cov1" title="1">var remoteType string
                        var remote config.DRSRemote
                        if remoteSelect.Gen3 != nil </span><span class="cov1" title="1">{
                                remoteType = string(config.Gen3ServerType)
                                remote = remoteSelect.Gen3
                        }</span> else<span class="cov0" title="0"> if remoteSelect.Anvil != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.AnvilServerType)
                                remote = remoteSelect.Anvil
                        }</span> else<span class="cov0" title="0"> {
                                remoteType = "unknown"
                        }</span>

                        <span class="cov1" title="1">endpoint := "N/A"
                        if remote != nil </span><span class="cov1" title="1">{
                                endpoint = remote.GetEndpoint()
                        }</span>

                        <span class="cov1" title="1">fmt.Printf("%s %-10s %-8s %s\n", marker, name, remoteType, endpoint)</span>
                }
                <span class="cov1" title="1">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package remote

import (
        "fmt"
        "sort"

        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
)

var RemoveCmd = &amp;cobra.Command{
        Use:     "remove &lt;remote-name&gt;",
        Aliases: []string{"rm"},
        Short:   "Remove a configured DRS remote",
        Long:    "Remove a configured DRS remote and update the default remote if needed",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) != 1 </span><span class="cov6" title="2">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (remote name), received %d\n\nUsage: %s\n\nRun 'git drs remote list' to see available remotes or 'git drs remote rm --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="2">{
                remoteName := args[0]

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                <span class="cov6" title="2">remote := config.Remote(remoteName)
                if _, ok := cfg.Remotes[remote]; !ok </span><span class="cov1" title="1">{
                        availableRemotes := make([]string, 0, len(cfg.Remotes))
                        for name := range cfg.Remotes </span><span class="cov1" title="1">{
                                availableRemotes = append(availableRemotes, string(name))
                        }</span>
                        <span class="cov1" title="1">sort.Strings(availableRemotes)
                        return fmt.Errorf("remote '%s' not found.\nAvailable remotes: %v", remoteName, availableRemotes)</span>
                }

                <span class="cov1" title="1">if err := config.RemoveRemote(remote); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove remote: %w", err)
                }</span>

                <span class="cov1" title="1">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package remote

import (
        "github.com/calypr/git-drs/cmd/remote/add"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "remote",
        Short: "Manage remote DRS server configs",
}

func init() <span class="cov10" title="95">{
        Cmd.AddCommand(add.Cmd)
        Cmd.AddCommand(ListCmd)
        Cmd.AddCommand(SetCmd)
        Cmd.AddCommand(RemoveCmd)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var SetCmd = &amp;cobra.Command{
        Use:   "set &lt;remote-name&gt;",
        Short: "Set the default DRS remote",
        Long:  "Set which DRS remote to use by default for all operations",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) != 1 </span><span class="cov6" title="2">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (remote name), received %d\n\nUsage: %s\n\nRun 'git drs remote list' to see available remotes or 'git drs remote set --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                remoteName := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                // validate remote exists
                <span class="cov0" title="0">remote := config.Remote(remoteName)
                if _, ok := cfg.Remotes[remote]; !ok </span><span class="cov0" title="0">{
                        availableRemotes := make([]string, 0, len(cfg.Remotes))
                        for name := range cfg.Remotes </span><span class="cov0" title="0">{
                                availableRemotes = append(availableRemotes, string(name))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf(
                                "remote '%s' not found.\nAvailable remotes: %v",
                                remoteName,
                                availableRemotes,
                        )</span>
                }

                // save new default
                <span class="cov0" title="0">cfg.DefaultRemote = remote

                if err := config.SaveConfig(cfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save config: %w", err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Default remote set to: %s", remoteName))
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package cmd

import (
        "github.com/calypr/git-drs/cmd/addref"
        "github.com/calypr/git-drs/cmd/addurl"
        deleteCmd "github.com/calypr/git-drs/cmd/delete"
        "github.com/calypr/git-drs/cmd/deleteproject"
        "github.com/calypr/git-drs/cmd/fetch"
        "github.com/calypr/git-drs/cmd/initialize"
        "github.com/calypr/git-drs/cmd/precommit"
        "github.com/calypr/git-drs/cmd/prepush"
        "github.com/calypr/git-drs/cmd/push"
        "github.com/calypr/git-drs/cmd/query"
        "github.com/calypr/git-drs/cmd/remote"
        "github.com/calypr/git-drs/cmd/transfer"
        "github.com/calypr/git-drs/cmd/transferref"
        "github.com/calypr/git-drs/cmd/version"
        "github.com/spf13/cobra"
)

// RootCmd represents the root command
var RootCmd = &amp;cobra.Command{
        Use:   "git-drs",
        Short: "Git DRS - Git-LFS file management for DRS servers",
        Long:  "Git DRS provides the benefits of Git-LFS file management using DRS for seamless integration with Gen3 servers",
}

func init() <span class="cov10" title="95">{
        // Hide internal commands
        precommit.Cmd.Hidden = true
        prepush.Cmd.Hidden = true
        transfer.Cmd.Hidden = true
        transferref.Cmd.Hidden = true

        RootCmd.AddCommand(initialize.Cmd)
        RootCmd.AddCommand(version.Cmd)
        RootCmd.AddCommand(remote.Cmd)
        RootCmd.AddCommand(fetch.Cmd)
        RootCmd.AddCommand(push.Cmd)
        RootCmd.AddCommand(precommit.Cmd)
        RootCmd.AddCommand(prepush.Cmd)
        RootCmd.AddCommand(transfer.Cmd)
        RootCmd.AddCommand(transferref.Cmd)
        RootCmd.AddCommand(addref.Cmd)
        RootCmd.AddCommand(addurl.Cmd)
        RootCmd.AddCommand(deleteCmd.Cmd)
        RootCmd.AddCommand(deleteproject.Cmd)
        RootCmd.AddCommand(query.Cmd)

        RootCmd.CompletionOptions.HiddenDefaultCmd = true
        RootCmd.SilenceUsage = true
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package transfer

import (
        "bufio"
        "context"
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        dataClientCommon "github.com/calypr/data-client/common"
        "github.com/calypr/git-drs/common"

        "github.com/calypr/data-client/download"
        "github.com/calypr/data-client/hash"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

// TransferJob carries the raw JSON data and shared client
type TransferJob struct {
        data      []byte
        drsClient client.DRSClient
}

// TransferResult sent back to the single writer
type TransferResult struct {
        data    any
        isError bool
}

var (
        // Set once after init  determines which path all workers take
        transferOperation string    // "upload" or "download"
        sConfig           sonic.API = sonic.ConfigFastest
)

const (
        OPERATION_UPLOAD   = "upload"
        OPERATION_DOWNLOAD = "download"
)

var Cmd = &amp;cobra.Command{
        Use:   "transfer",
        Short: "[RUN VIA GIT LFS] register LFS files into gen3 during git push",
        Long:  `[RUN VIA GIT LFS] git-lfs transfer mechanism to register LFS files up to gen3 during git push. For new files, creates an indexd record and uploads to the bucket`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov9" title="67">{
                logger := drslog.GetLogger()
                logger.Info("~~~~~~~~~~~~~ START: drs transfer ~~~~~~~~~~~~~")

                // Gotta go fast  big buffer
                scanner := bufio.NewScanner(os.Stdin)
                const maxCapacity = 10 * 1024 * 1024 // 10 MB
                buf := make([]byte, 0, 64*1024)
                scanner.Buffer(buf, maxCapacity)
                streamEncoder := encoder.NewStreamEncoder(os.Stdout)

                // Read init message
                if !scanner.Scan() </span><span class="cov1" title="1">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="66">initBytes := make([]byte, len(scanner.Bytes()))
                copy(initBytes, scanner.Bytes())
                var initMsg lfs.InitMessage
                if err := sConfig.Unmarshal(initBytes, &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error decoding initial JSON message: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="66">if initMsg.Event != "init" </span><span class="cov0" title="0">{
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%s'", initMsg.Event)
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="66">var drsClient client.DRSClient

                // Load config first
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error loading config: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                // Determine remote
                <span class="cov9" title="66">remote, err := cfg.GetDefaultRemote()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="66">drsClient, err = cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error creating DRS client: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                // Determine if upload or download
                <span class="cov9" title="66">if initMsg.Operation == OPERATION_UPLOAD || initMsg.Operation == OPERATION_DOWNLOAD </span><span class="cov9" title="66">{
                        transferOperation = initMsg.Operation
                        logger.Debug(fmt.Sprintf("Transfer operation: %s", transferOperation))
                }</span> else<span class="cov0" title="0"> {
                        err := fmt.Errorf("invalid or missing operation in init message: %s", initMsg.Operation)
                        logger.Error(err.Error())
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>
                <span class="cov9" title="66">if err := streamEncoder.Encode(map[string]any{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error sending init acknowledgment: %v", err))
                        return err
                }</span>

                <span class="cov9" title="66">for scanner.Scan() </span><span class="cov10" title="76">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("error decoding JSON: %s", err))
                                continue</span>
                        }

                        <span class="cov10" title="76">if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov3" title="4">{
                                // Handle download event
                                logger.Debug("Download requested")

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, "", 400, errMsg)
                                        continue</span>
                                }
                                <span class="cov3" title="4">ctx := dataClientCommon.WithProgress(context.Background(), lfs.NewProgressCallback(streamEncoder))
                                ctx = dataClientCommon.WithOid(ctx, downloadMsg.Oid)
                                logger.InfoContext(ctx, fmt.Sprintf("Downloading file OID %s", downloadMsg.Oid))

                                // get the matching record for this OID
                                checksumSpec := &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: downloadMsg.Oid}
                                records, err := drsClient.GetObjectByHash(ctx, checksumSpec)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error looking up OID %s: %v", downloadMsg.Oid, err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }

                                <span class="cov3" title="4">matchingRecord, err := drsmap.FindMatchingRecord(records, drsClient.GetProjectId())
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error finding matching record for project %s: %v", drsClient.GetProjectId(), err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        errMsg = fmt.Sprintf("Error getting signed URL for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)

                                        drsObject, errG := drsmap.DrsInfoFromOid(downloadMsg.Oid)
                                        if errG == nil &amp;&amp; drsObject != nil </span><span class="cov0" title="0">{
                                                manualDownloadMsg := fmt.Sprintf("%s %s", drsObject.AccessMethods[0].AccessURL.URL, drsObject.Name)
                                                logger.Info(manualDownloadMsg)
                                                lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 302, manualDownloadMsg)
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Error(fmt.Sprintf("drsClient.GetObject failed for %s: %v ", downloadMsg.Oid, errG))
                                                lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                <span class="cov3" title="4">if matchingRecord == nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("No matching record found for project %s and OID %s", drsClient.GetProjectId(), downloadMsg.Oid)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 404, errMsg)
                                        continue</span>
                                }

                                // download using data-client
                                <span class="cov3" title="4">dstPath, err := drsmap.GetObjectPath(common.LFS_OBJS_PATH, downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error getting destination path for OID %s: %v", downloadMsg.Oid, err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                <span class="cov3" title="4">err = download.DownloadToPath(
                                        ctx,
                                        drsClient.GetGen3Interface(),
                                        matchingRecord.Id,
                                        dstPath,
                                )
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s (GUID: %s): %v", downloadMsg.Oid, matchingRecord.Id, err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }

                                <span class="cov3" title="4">lfs.WriteProgressMessage(streamEncoder, downloadMsg.Oid, downloadMsg.Size, downloadMsg.Size)

                                // send success message back
                                logger.InfoContext(ctx, fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))

                                lfs.WriteCompleteMessage(streamEncoder, downloadMsg.Oid, dstPath)</span>

                        } else<span class="cov9" title="72"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov4" title="6">{
                                // Handle upload event
                                logger.Debug("Upload requested")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                <span class="cov4" title="6">ctx := dataClientCommon.WithProgress(context.Background(), lfs.NewProgressCallback(streamEncoder))
                                ctx = dataClientCommon.WithOid(ctx, uploadMsg.Oid)
                                logger.InfoContext(ctx, fmt.Sprintf("Uploading file OID %s", uploadMsg.Oid))

                                drsObj, err := drsClient.RegisterFile(ctx, uploadMsg.Oid, uploadMsg.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error registering file: %v\n", err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }
                                // send success message back
                                <span class="cov4" title="6">lfs.WriteCompleteMessage(streamEncoder, uploadMsg.Oid, drsObj.Name)
                                logger.InfoContext(ctx, fmt.Sprintf("Upload for Oid %s complete", uploadMsg.Oid))</span>

                        } else<span class="cov9" title="66"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov9" title="66">{
                                logger.Info("LFS transfer terminate received.")
                        }</span>
                }

                <span class="cov9" title="66">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("stdin error: %s", err))
                }</span>

                <span class="cov9" title="66">logger.Info("~~~~~~~~~~~~~ COMPLETED: custom transfer ~~~~~~~~~~~~~")
                return nil</span>

        },
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package transferref

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

var (
        drsClient client.DRSClient
        sConfig   sonic.API = sonic.ConfigFastest
)

// TODO: used for AnvIL use case, requires implementation
var Cmd = &amp;cobra.Command{
        Use:   "transfer-ref",
        Short: "[RUN VIA GIT LFS] handle transfers of existing DRS object into git during git push",
        Long:  "[RUN VIA GIT LFS] custom transfer mechanism to pull LFS files during git lfs pull. Does nothing on push.",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                //setup logging to file for debugging
                myLogger := drslog.GetLogger()

                myLogger.Info("~~~~~~~~~~~~~ START: custom anvil transfer ~~~~~~~~~~~~~")

                scanner := bufio.NewScanner(os.Stdin)
                encoder := encoder.NewStreamEncoder(os.Stdout)

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("Error loading config: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">var remoteName string

                // Read the first (init) message outside the main loop
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        // No OID yet, so pass empty string
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">var initMsg map[string]any
                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("error decoding initial JSON message: %s", err))
                        return err
                }</span>

                // Handle "init" event and extract remote
                <span class="cov0" title="0">if evt, ok := initMsg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                        // if no remote name specified, use default remote
                        defaultRemote, err := cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                                lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">remoteName = string(defaultRemote)
                        myLogger.Debug(fmt.Sprintf("Initializing connection, remote not specified  using default: %s", remoteName))

                        // Respond with an empty json object via stdout
                        encoder.Encode(struct{}{})</span>
                } else<span class="cov0" title="0"> {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%v'", initMsg["event"])
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">drsClient, err = cfg.GetRemoteClient(config.Remote(remoteName), myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("Error creating indexd client: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Debug(fmt.Sprintf("error decoding JSON: %s", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Received message: %s", msg))

                        // Example: handle only "init" event
                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                                // Log for debugging
                                myLogger.Debug(fmt.Sprintf("Handling init: %s", msg))

                                // Respond with an empty json object via stdout
                                encoder.Encode(struct{}{})
                                myLogger.Debug("Responding to init with empty object")
                        }</span> else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov0" title="0">{
                                // Handle download event
                                myLogger.Debug(fmt.Sprintf("Handling download event: %s", msg))

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                // call DRS Downloader via downloadFile
                                <span class="cov0" title="0">dstPath, err := downloadFile(config.Remote(remoteName), downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v\n", downloadMsg.Oid, err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 500, errMsg)
                                        continue</span>
                                }

                                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Downloaded file for OID %s", downloadMsg.Oid))

                                // send success message back
                                myLogger.Debug(fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   downloadMsg.Oid,
                                        Path:  dstPath,
                                }
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov0" title="0">{
                                // Handle upload event
                                myLogger.Info(fmt.Sprintf("Handling upload event: %s", msg))
                                myLogger.Info("skipping upload, just registering existing DRS object")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, uploadMsg.Oid, 400, errMsg)
                                }</span>
                                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Got UploadMessage: %+v", uploadMsg))

                                // send success message back
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   uploadMsg.Oid,
                                }
                                myLogger.Info(fmt.Sprintf("Complete message: %+v", completeMsg))
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov0" title="0"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov0" title="0">{
                                // Handle terminate event
                                myLogger.Debug(fmt.Sprintf("terminate event received: %s", msg))
                        }</span>
                }

                <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("stdin error: %s", err))
                }</span>

                <span class="cov0" title="0">myLogger.Info("~~~~~~~~~~~~~ COMPLETED: custom anvil transfer ~~~~~~~~~~~~~")

                return nil</span>
        },
}

func downloadFile(remote config.Remote, sha string) (string, error) <span class="cov0" title="0">{
        myLogger := drslog.GetLogger()

        myLogger.Debug(fmt.Sprintf("Downloading file for sha %s", sha))

        // get terra project
        cfg, err := config.LoadConfig() // should this be handled only via indexd client?
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>

        <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remote, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">terraProject := cli.GetProjectId()

        filePath, err := drsmap.GetObjectPath(common.DRS_REF_DIR, sha)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting object path for sha %s: %v", sha, err)
        }</span>
        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("File path for sha %s: %s", sha, filePath))

        // get DRS URI in the second line of the file
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        myLogger.Debug(fmt.Sprintf("Opened file %s for reading", filePath))

        scanner := bufio.NewScanner(file)
        var drsUri string
        lineNum := 0
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNum++
                line := scanner.Text()
                myLogger.Debug(fmt.Sprintf("Reading line %d: %s", lineNum, line))
                if lineNum == 2 </span><span class="cov0" title="0">{
                        // second line should be the DRS URI
                        drsUri = strings.TrimSpace(line)
                        myLogger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
                        break</span>
                }
        }

        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
        if drsUri == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error: file %s does not contain a valid DRS URI in the second line", filePath)
        }</span>
        <span class="cov0" title="0">drsObj, err := drsClient.GetObject(context.Background(), drsUri)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error fetching DRS object for URI %s: %v", drsUri, err)
        }</span>
        <span class="cov0" title="0">if drsObj == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no DRS object found for URI %s", drsUri)
        }</span>

        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("DRS Object fetched: %+v", drsObj))

        // call DRS downloader as a binary, redirect output to log file
        logFile, err := os.OpenFile(common.DRS_LOG_FILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        //TODO: This should be done in the DRSClient code
        // download file, make sure its name is the sha
        dstPath, err := drsmap.GetObjectPath(common.LFS_OBJS_PATH, sha)
        dstDir := filepath.Dir(dstPath)
        cmd := exec.Command("drs_downloader", "terra", "--user-project", terraProject, "--manifest-path", filePath, "--destination-dir", dstDir)

        // write command to log file
        logFile.WriteString(fmt.Sprintf("Running command: %s\n", cmd.String()))

        cmd.Stdout = logFile
        cmd.Stderr = logFile
        cmdOut, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error running drs_downloader for sha %s: %s", sha, cmdOut)
        }</span>

        //rename file to sha
        <span class="cov0" title="0">tmpPath := filepath.Join(dstDir, drsObj.Name)
        err = os.Rename(tmpPath, dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error renaming downloaded file from %s to %s: %v", tmpPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return dstPath, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package version

import (
        "fmt"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Cmd represents the "version" command
var Cmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Get version",
        Long:  ``,
        Run: func(cmd *cobra.Command, args []string) <span class="cov4" title="5">{
                fmt.Println("git-drs", buildVersion())
        }</span>,
}

func buildVersion() string <span class="cov4" title="6">{
        tag := ""
        commit := ""
        if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov4" title="6">{
                if info.Main.Version != "" &amp;&amp; info.Main.Version != "(devel)" </span><span class="cov0" title="0">{
                        tag = info.Main.Version
                }</span>
                <span class="cov4" title="6">for _, setting := range info.Settings </span><span class="cov10" title="72">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                commit = setting.Value</span>
                        case "vcs.tag":<span class="cov0" title="0">
                                if tag == "" </span><span class="cov0" title="0">{
                                        tag = setting.Value
                                }</span>
                        }
                }
        }

        <span class="cov4" title="6">commitShort := commit
        if len(commitShort) &gt; 7 </span><span class="cov0" title="0">{
                commitShort = commitShort[:7]
        }</span>

        <span class="cov4" title="6">switch </span>{
        case tag != "" &amp;&amp; commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s", tag, commitShort)</span>
        case tag != "":<span class="cov0" title="0">
                return tag</span>
        case commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("dev-%s", commitShort)</span>
        default:<span class="cov4" title="6">
                return "dev-unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package common

import (
        "fmt"
        "strings"
)

// AddUnique appends items from 'toAdd' to 'existing' only if they're not already present.
// Returns the updated slice with unique items.
func AddUnique[T comparable](existing []T, toAdd []T) []T <span class="cov1" title="1">{
        // seen map uses struct{} as the value for memory efficiency
        seen := make(map[T]struct{}, len(existing))

        // Populate the set with existing items
        for _, item := range existing </span><span class="cov4" title="2">{
                seen[item] = struct{}{}
        }</span>

        <span class="cov1" title="1">for _, item := range toAdd </span><span class="cov4" title="2">{
                // check if item not yet in the set
                if _, found := seen[item]; !found </span><span class="cov1" title="1">{
                        existing = append(existing, item)
                        // Add the new unique item to the set
                        seen[item] = struct{}{}
                }</span>
        }
        <span class="cov1" title="1">return existing</span>
}

func ProjectToResource(project string) (string, error) <span class="cov10" title="7">{
        if !strings.Contains(project, "-") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error: invalid project ID %s in config file, ID should look like &lt;program&gt;-&lt;project&gt;", project)
        }</span>
        <span class="cov9" title="6">projectIdArr := strings.SplitN(project, "-", 2)
        return "/programs/" + projectIdArr[0] + "/projects/" + projectIdArr[1], nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package common

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
)

// PromptForConfirmation displays a prompt and reads user input to confirm an operation.
// Returns nil if the response matches expectedResponse, error otherwise.
// If caseSensitive is false, comparison is case-insensitive.
func PromptForConfirmation(w io.Writer, prompt string, expectedResponse string, caseSensitive bool) error <span class="cov10" title="2">{
        fmt.Fprintf(w, "%s: ", prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading confirmation: %v", err)
        }</span>

        <span class="cov10" title="2">response = strings.TrimSpace(response)
        if !caseSensitive </span><span class="cov1" title="1">{
                response = strings.ToLower(response)
                expectedResponse = strings.ToLower(expectedResponse)
        }</span>

        <span class="cov10" title="2">if response != expectedResponse </span><span class="cov1" title="1">{
                return fmt.Errorf("operation cancelled: confirmation did not match")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DisplayWarningHeader writes a formatted warning header to the writer
func DisplayWarningHeader(w io.Writer, operation string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\n  WARNING: You are about to %s\n\n", operation)
}</span>

// DisplayField writes a formatted key-value field to the writer
func DisplayField(w io.Writer, key, value string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "%-11s %s\n", key+":", value)
}</span>

// DisplayFooter writes the standard "cannot be undone" footer to the writer
func DisplayFooter(w io.Writer) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\nThis action CANNOT be undone.\n\n")
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package common

import (
        "fmt"
        "net/url"

        "github.com/golang-jwt/jwt/v5"
)

func ParseEmailFromToken(tokenString string) (string, error) <span class="cov8" title="5">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode token in ParseEmailFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov7" title="4">context, ok := claims["context"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context' claim structure")
        }</span>
        <span class="cov6" title="3">user, ok := context["user"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user' claim structure")
        }</span>
        <span class="cov4" title="2">name, ok := user["name"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user.name' claim")
        }</span>
        <span class="cov1" title="1">return name, nil</span>
}

func ParseAPIEndpointFromToken(tokenString string) (string, error) <span class="cov10" title="7">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token in ParseAPIEndpointFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov10" title="7">issUrl, ok := claims["iss"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'iss' claim")
        }</span>
        <span class="cov9" title="6">parsedURL, err := url.Parse(issUrl)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="5">return fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host), nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package config

import (
        "fmt"
        "log"
        "log/slog"
        "path/filepath"
        "sort"
        "strings"

        "github.com/calypr/data-client/g3client"
        "github.com/calypr/git-drs/client"
        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/gitrepo"
        "github.com/go-git/go-git/v5"
)

// RemoteType represents the type of server being initialized
type RemoteType string
type Remote string

const (
        ORIGIN = "origin"

        Gen3ServerType  RemoteType = "gen3"
        AnvilServerType RemoteType = "anvil"

        newConfigSection           = "lfs"
        newConfigSubsectionRoot    = "customtransfer.drs"
        legacyConfigSection        = "drs"
        remoteSubsectionPrefix     = "remote."
        legacyDefaultRemoteKey     = "drs.default-remote"
        namespacedDefaultRemoteKey = "lfs.customtransfer.drs.default-remote"
)

func AllRemoteTypes() []RemoteType {
        </span>return []RemoteType{Gen3ServerType, AnvilServerType}
}</span>

func IsValidRemoteType(mode string) error {
        modeOptions := make([]string, len(A</span>llRemoteTypes()))
        for i, m := range AllRemoteTypes() </span>{
                </span>modeOptions[i] = string(m)
        }</span>

</span>        for _, validMode := range mode</span>Options </span>{
                if mode == string(validMode) {
                        </span></span>return nil
                }</span>
        }

</span>        <span class="cov2" title="2">return fmt.Errorf("invalid mode '%s'. Valid options are: %s", mode, strings.Join(modeOptions, ", "))</span>
}

// DRSRemote holds pointers to remote types
type DRSRemote interface {
        GetProjectId() string
        GetEndpoint() string
        GetBucketName() string
        GetClient(remoteName string, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error)
}

type RemoteSelect struct {
        Gen3  *indexd.Gen3Remote
        Anvil *anvil_client.AnvilRemote
}

// Config holds the overall config structure
type Config struct {
        DefaultRemote Remote
        Remotes       map[Remote]RemoteSelect
}

func (c Config) GetRemoteClient(remote Remote, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) {
        x, ok :</span>= c.Remotes[remote]
        if !ok </span>{
                </span>return nil, fmt.Errorf("GetRemoteClient no remote configuration found for current remote: %s", remote)
        }</span>
</span>        if x.Gen3 != nil {
                </span></span>return x.Gen3.GetClient(string(remote), logger, opts...)
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil.GetClient(string(remote), logger, opts...)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("no valid remote configuration found for current remote: %s", remote)</span>
}

func (c Config) GetRemote(remote Remote) DRSRemote <span class="cov4" title="9">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="9">if x.Gen3 != nil </span><span class="cov4" title="9">{
                return x.Gen3
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDefaultRemote returns the configured default remote with validation
func (c Config) GetDefaultRemote() (Remote, error) <span class="cov8" title="75">{
        if c.DefaultRemote == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "no default remote configured.\n"+
                                "Set one with: git drs remote set &lt;name&gt;\n"+
                                "Available remotes: %v\n"+
                                "Config: %v\n",
                        c.listRemoteNames(),
                        c,
                )
        }</span>

        <span class="cov8" title="75">if _, ok := c.Remotes[c.DefaultRemote]; !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "default remote '%s' not found in configuration.\n"+
                                "Available remotes: %v",
                        c.DefaultRemote,
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov8" title="75">return c.DefaultRemote, nil</span>
}

// GetRemoteOrDefault returns the specified remote if provided, otherwise returns the default remote
func (c Config) GetRemoteOrDefault(remote string) (Remote, error) <span class="cov0" title="0">{
        if remote != "" </span><span class="cov0" title="0">{
                return Remote(remote), nil
        }</span>
        <span class="cov0" title="0">return c.GetDefaultRemote()</span>
}

// listRemoteNames returns a slice of all remote names for error messages
func (c Config) listRemoteNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(c.Remotes))
        for name := range c.Remotes </span><span class="cov0" title="0">{
                names = append(names, string(name))
        }</span>
        <span class="cov0" title="0">return names</span>
}

// getRepo opens the current git repository
func getRepo() (*git.Repository, error) <span class="cov8" title="91">{
        return gitrepo.GetRepo()
}</span>

func (c Config) ConfigPath() (string, error) <span class="cov0" title="0">{
        return getConfigPath()
}</span>

// updates and git adds a Git DRS config file
// this should handle three cases:
// 1. create a new config file if it does not exist / is empty
// 2. return an error if the config file is invalid
// 3. update the existing config file, making sure to combine the new serversMap with the existing one
// UpdateRemote updates and saves configuration using go-git
func UpdateRemote(name Remote, remote RemoteSelect) (*Config, error) <span class="cov3" title="4">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update lfs.customtransfer.drs.remote.&lt;name&gt; subsection
        <span class="cov3" title="4">remoteSubsectionName := fmt.Sprintf("%s.%s%s", newConfigSubsectionRoot, remoteSubsectionPrefix, name)
        remoteSubsection := conf.Raw.Section(newConfigSection).Subsection(remoteSubsectionName)

        if remote.Gen3 != nil </span><span class="cov3" title="4">{
                remoteSubsection.SetOption("type", "gen3")
                remoteSubsection.SetOption("endpoint", remote.Gen3.Endpoint)
                remoteSubsection.SetOption("project", remote.Gen3.ProjectID)
                remoteSubsection.SetOption("bucket", remote.Gen3.Bucket)
        }</span> else<span class="cov0" title="0"> if remote.Anvil != nil </span><span class="cov0" title="0">{
                remoteSubsection.SetOption("type", "anvil")
        }</span>

        // Set default remote if not set
        <span class="cov3" title="4">configRoot := conf.Raw.Section(newConfigSection).Subsection(newConfigSubsectionRoot)
        defaultRemote := configRoot.Option("default-remote")
        if defaultRemote == "" </span><span class="cov3" title="4">{
                configRoot.SetOption("default-remote", string(name))
        }</span>

        // Save config
        <span class="cov3" title="4">if err := repo.Storer.SetConfig(conf); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="4">return LoadConfig()</span>
}

func parseAndAddRemote(cfg *Config, subsectionName string, remoteType string, endpoint string, project string, bucket string) <span class="cov8" title="79">{
        if !strings.HasPrefix(subsectionName, remoteSubsectionPrefix) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="79">remoteName := Remote(strings.TrimPrefix(subsectionName, remoteSubsectionPrefix))
        rs := RemoteSelect{}

        if remoteType == "gen3" || remoteType == "" </span><span class="cov8" title="79">{
                rs.Gen3 = &amp;indexd.Gen3Remote{
                        Endpoint:  endpoint,
                        ProjectID: project,
                        Bucket:    bucket,
                }
        }</span> else<span class="cov0" title="0"> if remoteType == "anvil" </span><span class="cov0" title="0">{
                rs.Anvil = &amp;anvil_client.AnvilRemote{}
        }</span>

        <span class="cov8" title="79">cfg.Remotes[remoteName] = rs</span>
}

// LoadConfig loads configuration using go-git
func LoadConfig() (*Config, error) <span class="cov8" title="83">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="83">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="83">cfg := &amp;Config{
                Remotes: make(map[Remote]RemoteSelect),
        }

        lfsSection := conf.Raw.Section(newConfigSection)
        newRoot := lfsSection.Subsection(newConfigSubsectionRoot)
        legacyRoot := conf.Raw.Section(legacyConfigSection)

        cfg.DefaultRemote = Remote(newRoot.Option("default-remote"))
        if cfg.DefaultRemote == "" </span><span class="cov3" title="4">{
                legacyDefault := legacyRoot.Option("default-remote")
                if legacyDefault != "" </span><span class="cov0" title="0">{
                        log.Printf("Warning: git-drs config key '%s' is deprecated; use '%s'", legacyDefaultRemoteKey, namespacedDefaultRemoteKey)
                        cfg.DefaultRemote = Remote(legacyDefault)
                }</span>
        }

        <span class="cov8" title="83">for _, subsection := range lfsSection.Subsections </span><span class="cov10" title="162">{
                if !strings.HasPrefix(subsection.Name, newConfigSubsectionRoot+".") </span><span class="cov8" title="83">{
                        continue</span>
                }
                <span class="cov8" title="79">relativeName := strings.TrimPrefix(subsection.Name, newConfigSubsectionRoot+".")
                parseAndAddRemote(
                        cfg,
                        relativeName,
                        subsection.Option("type"),
                        subsection.Option("endpoint"),
                        subsection.Option("project"),
                        subsection.Option("bucket"),
                )</span>
        }

        <span class="cov8" title="83">for _, subsection := range legacyRoot.Subsections </span><span class="cov0" title="0">{
                if !strings.HasPrefix(subsection.Name, remoteSubsectionPrefix) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">remoteName := Remote(strings.TrimPrefix(subsection.Name, remoteSubsectionPrefix))
                if _, exists := cfg.Remotes[remoteName]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("Warning: git-drs config key prefix 'drs.%s' is deprecated; use 'lfs.customtransfer.drs.%s'", subsection.Name, subsection.Name)
                parseAndAddRemote(
                        cfg,
                        subsection.Name,
                        subsection.Option("type"),
                        subsection.Option("endpoint"),
                        subsection.Option("project"),
                        subsection.Option("bucket"),
                )</span>
        }

        <span class="cov8" title="83">return cfg, nil</span>
}

func CreateEmptyConfig() error <span class="cov3" title="4">{
        // With go-git, we just verify we are in a repo?
        // Existing behavior was ensuring file existence.
        // We can check if we can open the repo.
        _, err := getRepo()
        return err
}</span>

func GetProjectId(remote Remote) (string, error) <span class="cov0" title="0">{
        cfg, err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>
        <span class="cov0" title="0">rmt := cfg.GetRemote(remote)
        if rmt == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov0" title="0">return rmt.GetProjectId(), nil</span>
}

// RemoveRemote removes a configured remote and updates default-remote when required
func RemoveRemote(name Remote) error <span class="cov0" title="0">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">section := conf.Raw.Section(newConfigSection)
        legacySection := conf.Raw.Section(legacyConfigSection)
        root := section.Subsection(newConfigSubsectionRoot)

        remoteSubsectionName := fmt.Sprintf("%s.%s%s", newConfigSubsectionRoot, remoteSubsectionPrefix, name)
        legacyRemoteSubsectionName := fmt.Sprintf("%s%s", remoteSubsectionPrefix, name)

        hasNamespaced := section.HasSubsection(remoteSubsectionName)
        hasLegacy := legacySection.HasSubsection(legacyRemoteSubsectionName)
        if !hasNamespaced &amp;&amp; !hasLegacy </span><span class="cov0" title="0">{
                return fmt.Errorf("remote '%s' not found", name)
        }</span>

        <span class="cov0" title="0">if hasNamespaced </span><span class="cov0" title="0">{
                section.RemoveSubsection(remoteSubsectionName)
        }</span>
        <span class="cov0" title="0">if hasLegacy </span><span class="cov0" title="0">{
                legacySection.RemoveSubsection(legacyRemoteSubsectionName)
        }</span>

        <span class="cov0" title="0">defaultRemote := root.Option("default-remote")
        if defaultRemote == "" </span><span class="cov0" title="0">{
                defaultRemote = legacySection.Option("default-remote")
        }</span>

        <span class="cov0" title="0">if defaultRemote == string(name) </span><span class="cov0" title="0">{
                remainingSet := make(map[string]struct{})
                for _, subsection := range section.Subsections </span><span class="cov0" title="0">{
                        if !strings.HasPrefix(subsection.Name, newConfigSubsectionRoot+"."+remoteSubsectionPrefix) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">rest := strings.TrimPrefix(subsection.Name, newConfigSubsectionRoot+".")
                        remainingSet[strings.TrimPrefix(rest, remoteSubsectionPrefix)] = struct{}{}</span>
                }
                <span class="cov0" title="0">for _, subsection := range legacySection.Subsections </span><span class="cov0" title="0">{
                        if !strings.HasPrefix(subsection.Name, remoteSubsectionPrefix) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">remainingSet[strings.TrimPrefix(subsection.Name, remoteSubsectionPrefix)] = struct{}{}</span>
                }

                <span class="cov0" title="0">remaining := make([]string, 0, len(remainingSet))
                for remoteName := range remainingSet </span><span class="cov0" title="0">{
                        remaining = append(remaining, remoteName)
                }</span>
                <span class="cov0" title="0">sort.Strings(remaining)

                root.RemoveOption("default-remote")
                legacySection.RemoveOption("default-remote")
                if len(remaining) &gt; 0 </span><span class="cov0" title="0">{
                        root.SetOption("default-remote", remaining[0])
                }</span>
        }

        <span class="cov0" title="0">return repo.Storer.SetConfig(conf)</span>
}

// SaveConfig writes the configuration using go-git
func SaveConfig(cfg *Config) error <span class="cov0" title="0">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cfg.DefaultRemote != "" </span><span class="cov0" title="0">{
                conf.Raw.Section(newConfigSection).Subsection(newConfigSubsectionRoot).SetOption("default-remote", string(cfg.DefaultRemote))
        }</span>

        <span class="cov0" title="0">return repo.Storer.SetConfig(conf)</span>
}

// GetGitConfigInt reads an integer value from git config
// getGitConfigValue retrieves a value from git config by key
func getConfigPath() (string, error) <span class="cov0" title="0">{
        topLevel, err := gitrepo.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(topLevel, common.DRS_DIR, common.CONFIG_YAML)
        return configPath, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// go
package drslog

import (
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"

        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/gitrepo"

        "github.com/calypr/data-client/logs"
)

var globalLogger *slog.Logger
var globalLogFile io.Closer
var globalLoggerOnce sync.Once
var globalLoggerMu sync.RWMutex
var GIT_TRANSFER_TRACE int
var modulePathSuffixOnce sync.Once
var modulePathSuffixValue string
var repoRootOnce sync.Once
var repoRootValue string

const (
        levelDebugStr   = "DEBUG"
        levelInfoStr    = "INFO"
        levelWarnStr    = "WARN"
        levelWarningStr = "WARNING"
        levelErrorStr   = "ERROR"
)

// init initializes package-level settings from the environment.
//
// Documented calls inside:
//   - os.Getenv("GIT_TRANSFER_TRACE")
//     Reads environment variable to optionally enable trace logging.
//   - strconv.Atoi(envValue)
//     Parses the numeric env value.
//
// Side-effects:
// - sets package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - runtime automatically invokes init(); no external callers needed.
func init() <span class="cov6" title="113">{
        GIT_TRANSFER_TRACE = 0
        if envValue := os.Getenv("GIT_TRANSFER_TRACE"); envValue != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(envValue); err == nil </span><span class="cov0" title="0">{
                        GIT_TRANSFER_TRACE = parsed
                }</span>
        }
}

// TraceEnabled returns whether transfer trace logging is enabled.
//
// Documented calls inside:
// - reads package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - logging setup and callsites that want to be verbose only when trace is enabled.
func TraceEnabled() bool <span class="cov6" title="107">{
        return GIT_TRANSFER_TRACE == 1
}</span>

// NewLogger creates and installs a global slog.Logger that writes to the specified file
// and optionally to stderr. It is safe to call multiple times; the first successful call
// establishes the global logger.
//
// Documented calls inside:
//   - projectdir.DRS_DIR usage
//     Uses projectdir.DRS_DIR to create log directory.
//   - os.MkdirAll(projectdir.DRS_DIR, 0755)
//     Ensures the directory exists; returns error on failure.
//   - filepath.Join(projectdir.DRS_DIR, "git-drs.log")
//     Constructs default filename when none provided.
//   - os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
//     Opens/creates the log file (returns *os.File).
//   - io.MultiWriter(writers...)
//     Combines file and optionally os.Stderr into a single Writer.
//   - slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{...})
//     Creates the text handler for slog that writes to the combined writer.
//   - slog.New(handler).With("pid", os.Getpid())
//     Builds the logger and attaches pid attribute.
//   - globalLoggerMu.Lock()/Unlock()
//     Protects globalLogFile and globalLogger assignment.
//
// Side-effects:
// - sets package-level globalLogger and globalLogFile.
// Typical callers:
// - application startup code that wants to initialize logging (e.g. main).
func NewLogger(filename string, logToStderr bool) (*slog.Logger, error) <span class="cov6" title="107">{
        var writers []io.Writer

        if filename == "" </span><span class="cov6" title="106">{
                // create drs dir if it doesn't exist
                if err := os.MkdirAll(common.DRS_DIR, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov6" title="106">filename = filepath.Join(common.DRS_DIR, "git-drs.log")</span>
        }

        <span class="cov6" title="107">file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="107">writers = append(writers, file)

        if logToStderr </span><span class="cov6" title="95">{
                writers = append(writers, os.Stderr)
        }</span>

        <span class="cov6" title="107">multiWriter := io.MultiWriter(writers...)

        handler := slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{
                AddSource:   true,
                Level:       resolveLogLevel(),
                ReplaceAttr: replaceSourceAttr,
        })
        core := slog.New(logs.NewProgressHandler(handler)).With("pid", os.Getpid())

        globalLoggerMu.Lock()
        globalLogFile = file
        globalLogger = core
        globalLoggerMu.Unlock()

        return globalLogger, nil</span>
}

// GetLogger returns the global logger, initializing a no-op logger on first access.
//
// Documented calls inside:
//   - globalLoggerOnce.Do(func() { ... })
//     Ensures initialization runs only once.
//   - NewNoOpLogger()
//     Creates a logger that discards output if no global logger was set.
//
// Typical callers:
// - any package code that needs access to the package-level logger.
func GetLogger() *slog.Logger <span class="cov6" title="83">{
        globalLoggerOnce.Do(func() </span><span class="cov6" title="81">{
                if globalLogger == nil </span><span class="cov3" title="6">{
                        globalLogger = NewNoOpLogger()
                }</span>
        })
        <span class="cov6" title="83">return globalLogger</span>
}

// Close closes the active log file if one was opened.
//
// Documented calls inside:
//   - globalLoggerMu.Lock()/Unlock()
//     Protects access to globalLogFile.
//   - globalLogFile.Close()
//     Closes the underlying file and returns any error.
//
// Side-effects:
// - sets globalLogFile to nil.
// Typical callers:
// - application shutdown code or tests that want to release file handles.
func Close() error <span class="cov1" title="2">{
        globalLoggerMu.Lock()
        defer globalLoggerMu.Unlock()
        if globalLogFile != nil </span><span class="cov1" title="2">{
                err := globalLogFile.Close()

                globalLogFile = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewNoOpLogger returns a logger that discards all output.
//
// Documented calls inside:
//   - slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{Level: slog.LevelDebug})
//     Creates a text handler writing to io.Discard.
//   - slog.New(handler)
//     Builds the logger.
//
// Typical callers:
// - GetLogger on first access when no global logger was configured.
// - tests that need a deterministic logger that produces no output.
func NewNoOpLogger() *slog.Logger <span class="cov4" title="12">{
        handler := slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        return slog.New(logs.NewProgressHandler(handler))
}</span>

// resolveLogLevel determines the effective log level.
//
// Documented calls inside:
//   - TraceEnabled()
//     If trace is enabled, returns Debug level immediately.
//   - readLogLevelFromGitConfig()
//     Attempts to read configured level from git config; returns level and ok.
//   - defaults to slog.LevelInfo when nothing else matches.
//
// Typical callers:
// - NewLogger -&gt; used when creating slog.HandlerOptions.Level.
func resolveLogLevel() slog.Level <span class="cov6" title="107">{
        if TraceEnabled() </span><span class="cov0" title="0">{
                return slog.LevelDebug
        }</span>

        <span class="cov6" title="107">level, ok := readLogLevelFromGitConfig()
        if ok </span><span class="cov0" title="0">{
                return level
        }</span>

        <span class="cov6" title="107">return slog.LevelInfo</span>
}

// readLogLevelFromGitConfig queries git configuration for a custom log level.
//
// Documented calls inside:
//   - exec.Command("git", "config", "--get", "lfs.customtransfer.drs.loglevel")
//     Constructs the command to query git config.
//   - cmd.Output()
//     Executes the command and returns raw output or an error.
//   - strings.TrimSpace(string(output))
//     Trims whitespace/newlines from git output.
//   - parseLogLevel(value)
//     Parses the trimmed value into a slog.Level.
//
// Behavior:
// - On any error or empty output, returns (slog.LevelInfo, false) to indicate no valid config was found.
// Typical callers:
// - resolveLogLevel when initializing a logger.
func readLogLevelFromGitConfig() (slog.Level, bool) <span class="cov6" title="107">{
        val, err := gitrepo.GetGitConfigString("lfs.customtransfer.drs.loglevel")
        if err != nil || val == "" </span><span class="cov6" title="107">{
                return slog.LevelInfo, false
        }</span>

        <span class="cov0" title="0">parsed, ok := parseLogLevel(val)
        if !ok </span><span class="cov0" title="0">{
                return slog.LevelInfo, false
        }</span>
        <span class="cov0" title="0">return parsed, true</span>
}

// parseLogLevel maps textual level names to slog.Level.
//
// Documented calls inside:
//   - strings.ToUpper(strings.TrimSpace(value))
//     Normalizes the input for comparison.
//   - switch on normalized value to return corresponding slog.Level constants.
//
// Typical callers:
// - readLogLevelFromGitConfig
// - resolveLogLevel indirectly.

func parseLogLevel(value string) (slog.Level, bool) <span class="cov0" title="0">{
        switch strings.ToUpper(strings.TrimSpace(value)) </span>{
        case levelDebugStr:<span class="cov0" title="0">
                return slog.LevelDebug, true</span>
        case levelInfoStr:<span class="cov0" title="0">
                return slog.LevelInfo, true</span>
        case levelWarnStr, levelWarningStr:<span class="cov0" title="0">
                return slog.LevelWarn, true</span>
        case levelErrorStr:<span class="cov0" title="0">
                return slog.LevelError, true</span>
        default:<span class="cov0" title="0">
                return slog.LevelDebug, false</span>
        }
}

// replaceSourceAttr rewrites the slog.Source attr to a shorter path suitable for logs.
//
// Documented calls inside:
//   - attr.Key comparison with slog.SourceKey
//     Determines whether the attribute is the source attribute.
//   - attr.Value.Any().(*slog.Source)
//     Retrieves and type-asserts the attribute value to *slog.Source.
//   - formatSourcePath(source.File)
//     Formats the file path according to module or repo root heuristics.
//   - attr.Value = slog.AnyValue(source)
//     Replaces attribute value with modified source.
//
// Typical callers:
// - passed as ReplaceAttr to slog.HandlerOptions in NewLogger.
func replaceSourceAttr(_ []string, attr slog.Attr) slog.Attr <span class="cov10" title="1227">{
        if attr.Key != slog.SourceKey </span><span class="cov9" title="950">{
                return attr
        }</span>
        <span class="cov8" title="277">source, ok := attr.Value.Any().(*slog.Source)
        if !ok || source == nil </span><span class="cov0" title="0">{
                return attr
        }</span>
        <span class="cov8" title="277">source.File = formatSourcePath(source.File)
        attr.Value = slog.AnyValue(source)
        return attr</span>
}

// formatSourcePath shortens file paths using module suffix or repo root heuristics.
//
// Documented calls inside:
//   - filepath.ToSlash(path)
//     Normalizes OS-specific separators to forward slashes.
//   - modulePathSuffix()
//     Gets the module path suffix (derived from build info).
//   - strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
//     Normalizes module suffix.
//   - strings.Index(pathSlash, "/"+moduleSuffixSlash+"/")
//     Searches for module suffix within the path to trim leading segments.
//   - strings.HasPrefix(pathSlash, moduleSuffixSlash+"/")
//     Handles case where path already starts with module suffix.
//   - repoRootPath()
//     Attempts to resolve the repository root (by locating go.mod).
//   - strings.HasPrefix(pathSlash, repoRootSlash+"/")
//     Trims repository-root prefix to produce a relative path.
//   - filepath.ToSlash(filepath.Join(moduleSuffix, rel))
//     Reconstructs path when combining module suffix and relative path.
//
// Typical callers:
// - replaceSourceAttr when rewriting source file paths for log output.
func formatSourcePath(path string) string <span class="cov8" title="277">{
        pathSlash := filepath.ToSlash(path)
        moduleSuffix := modulePathSuffix()
        if moduleSuffix != "" </span><span class="cov8" title="277">{
                moduleSuffixSlash := strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
                if idx := strings.Index(pathSlash, "/"+moduleSuffixSlash+"/"); idx &gt;= 0 </span><span class="cov8" title="260">{
                        return pathSlash[idx+1:]
                }</span>
                <span class="cov4" title="17">if strings.HasPrefix(pathSlash, moduleSuffixSlash+"/") </span><span class="cov0" title="0">{
                        return pathSlash
                }</span>
        }
        <span class="cov4" title="17">repoRoot := repoRootPath()
        if repoRoot != "" </span><span class="cov4" title="17">{
                repoRootSlash := filepath.ToSlash(repoRoot)
                if strings.HasPrefix(pathSlash, repoRootSlash+"/") </span><span class="cov0" title="0">{
                        rel := strings.TrimPrefix(pathSlash, repoRootSlash+"/")
                        if moduleSuffix != "" </span><span class="cov0" title="0">{
                                return filepath.ToSlash(filepath.Join(moduleSuffix, rel))
                        }</span>
                        <span class="cov0" title="0">return rel</span>
                }
        }
        <span class="cov4" title="17">return pathSlash</span>
}

// modulePathSuffix returns the module path suffix derived from build info.
//
// Documented calls inside:
//   - runtime/debug.ReadBuildInfo()
//     Reads build info at runtime; used to extract Main.Path.
//   - strings.Split(info.Main.Path, "/")
//     Splits module path to drop the first element (typically hostname).
//
// Side-effects:
// - caches computed value via modulePathSuffixOnce.
// Typical callers:
// - formatSourcePath to help shorten file paths.
func modulePathSuffix() string <span class="cov8" title="277">{
        modulePathSuffixOnce.Do(func() </span><span class="cov6" title="74">{
                if info, ok := debug.ReadBuildInfo(); ok &amp;&amp; info.Main.Path != "" </span><span class="cov6" title="74">{
                        parts := strings.Split(info.Main.Path, "/")
                        if len(parts) &gt; 1 </span><span class="cov6" title="74">{
                                modulePathSuffixValue = strings.Join(parts[1:], "/")
                        }</span>
                }
        })
        <span class="cov8" title="277">return modulePathSuffixValue</span>
}

// repoRootPath attempts to locate the repository root by searching for go.mod upward.
//
// Documented calls inside:
//   - os.Getwd()
//     Retrieves current working directory as a starting point.
//   - os.Stat(filepath.Join(dir, "go.mod"))
//     Checks for presence of go.mod in each directory while walking up.
//   - filepath.Dir(dir)
//     Moves up one directory level on each iteration.
//
// Side-effects:
// - caches resolved repo root via repoRootOnce.
// Typical callers:
// - formatSourcePath when computing shorter file paths for logs.
func repoRootPath() string <span class="cov4" title="17">{
        repoRootOnce.Do(func() </span><span class="cov3" title="6">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov3" title="6">dir := cwd
                for </span><span class="cov5" title="24">{
                        if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov3" title="6">{
                                repoRootValue = dir
                                return
                        }</span>
                        <span class="cov4" title="18">parent := filepath.Dir(dir)
                        if parent == dir </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov4" title="18">dir = parent</span>
                }
        })
        <span class="cov4" title="17">return repoRootValue</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package drsmap

// Utilities to map between Git LFS files and DRS objects

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/hash"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/precommit_cache"
        "github.com/google/uuid"
)

// execCommand is a variable to allow mocking in tests
var execCommand = exec.Command
var execCommandContext = exec.CommandContext

func PushLocalDrsObjects(drsClient client.DRSClient, myLogger *slog.Logger) error <span class="cov0" title="0">{
        // Gather all objects in .git/drs/lfs/objects store
        drsLfsObjs, err := lfs.GetDrsLfsObjects(myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make this a map if it does not exist when hitting the server
        <span class="cov0" title="0">sums := make([]*hash.Checksum, 0)
        for _, obj := range drsLfsObjs </span><span class="cov0" title="0">{
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                sums = append(sums, &amp;hash.Checksum{
                                        Checksum: sum,
                                        Type:     hash.ChecksumTypeSHA256,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">outobjs := map[string]*drs.DRSObject{}
        for _, sum := range sums </span><span class="cov0" title="0">{
                records, err := drsClient.GetObjectByHash(context.Background(), sum)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                        continue</span>
                }
                <span class="cov0" title="0">found := false
                // Warning: The loop overwrites map entries if multiple records have the same SHA256 hash.
                // If there are multiple records with SHA256 checksums, only the last one will be stored in the map
                for i, rec := range records </span><span class="cov0" title="0">{
                        if rec.Checksums.SHA256 != "" </span><span class="cov0" title="0">{
                                found = true
                                outobjs[rec.Checksums.SHA256] = &amp;records[i]
                        }</span>
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                }</span>
        }

        <span class="cov0" title="0">for drsObjKey := range outobjs </span><span class="cov0" title="0">{
                val, ok := drsLfsObjs[drsObjKey]
                if !ok </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Drs record not found in sha256 map %s", drsObjKey))
                }</span>
                <span class="cov0" title="0">if _, statErr := os.Stat(val.Name); os.IsNotExist(statErr) </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error: Object record found locally, but file does not exist locally. Registering Record %s", val.Name))
                        _, err = drsClient.RegisterRecord(context.Background(), val)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                } else<span class="cov0" title="0"> {
                        myLogger.Warn("TODO: Upload file to DRS server before registering file")
                        _, err = drsClient.RegisterFile(context.Background(), drsObjKey, "TODO")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func PullRemoteDrsObjects(drsClient client.DRSClient, logger *slog.Logger) error <span class="cov1" title="1">{
        objChan, err := drsClient.ListObjectsByProject(context.Background(), drsClient.GetProjectId())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">writtenObjs := 0
        for drsObj := range objChan </span><span class="cov1" title="1">{
                if drsObj.Object == nil </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("OBJ is nil: %#v, continuing...", drsObj))
                        continue</span>
                }
                <span class="cov1" title="1">sumMap := hash.ConvertHashInfoToMap(drsObj.Object.Checksums)
                if len(sumMap) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: drs Object '%s' does not contain a checksum", drsObj.Object.Id)
                }</span>
                <span class="cov1" title="1">var drsObjPath, oid string = "", ""
                for sumType, sum := range sumMap </span><span class="cov1" title="1">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                                oid = sum
                                drsObjPath, err = GetObjectPath(common.DRS_OBJS_PATH, oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error getting object path for oid %s: %v", oid, err)
                                }</span>
                        }
                }
                // Only write a record if there exists a proper checksum to use. Checksums besides sha256 are not used
                <span class="cov1" title="1">if drsObjPath != "" &amp;&amp; oid != "" </span><span class="cov1" title="1">{
                        writtenObjs++
                        // write drs objects to DRS_OBJS_PATH
                        err = WriteDrsObj(drsObj.Object, oid, drsObjPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error writing DRS object for oid %s: %v", oid, err)
                        }</span>
                }
        }
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Wrote %d new objs to object store", writtenObjs))
        return nil</span>
}
func UpdateDrsObjects(builder drs.ObjectBuilder, gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) error <span class="cov0" title="0">{

        if logger == nil </span>{
                return fmt.Errorf("logger is required")
        }
        logger.Debug("Update to DRS objects started")

</span></span>        // get all lfs files
        lfsFiles, err := lfs.GetAllLfsFiles(gitRemoteName, gitRemoteLocation, branches, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting all LFS files: %v", err)
        }</span>

        // get project
        <span class="cov0" title="0">if builder.ProjectID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no project configured")
        }</span>

        <span class="cov0" title="0">return UpdateDrsObjectsWithFiles(builder, lfsFiles, UpdateOptions{Logger: logger})</span>
}

type UpdateOptions struct {
        Cache          *precommit_cache.Cache
        PreferCacheURL bool
        Logger         *slog.Logger
}

func UpdateDrsObjectsWithFiles(builder drs.ObjectBuilder, lfsFiles map[string]lfs.LfsFileInfo, opts UpdateOptions) error <span class="cov8" title="6">{
        if opts.Logger == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("logger is required")
        }</span>
        <span class="cov8" title="6">opts.Logger.Debug("Update to DRS objects started")

        // get project
        if builder.ProjectID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no project configured")
        }</span>
        <span class="cov8" title="6">if len(lfsFiles) == 0 </span><span class="cov3" title="2">{
                return nil
        }</span>

        <span class="cov6" title="4">for _, file := range lfsFiles </span><span class="cov8" title="6">{
                drsID := DrsUUID(builder.ProjectID, file.Oid)
                authoritativeObj, err := builder.Build(file.Name, file.Oid, file.Size, drsID)
                if err != nil </span><span class="cov0" title="0">{
                        opts.Logger.Error(fmt.Sprintf("Could not build DRS object for %s OID %s %v", file.Name, file.Oid, err))
                        continue</span>
                }

                <span class="cov8" title="6">authoritativeURL := ""
                if len(authoritativeObj.AccessMethods) &gt; 0 </span><span class="cov8" title="6">{
                        authoritativeURL = authoritativeObj.AccessMethods[0].AccessURL.URL
                }</span>

                <span class="cov8" title="6">var hint string
                if opts.Cache != nil </span><span class="cov8" title="6">{
                        externalURL, ok, err := opts.Cache.LookupExternalURLByOID(file.Oid)
                        if err != nil </span><span class="cov0" title="0">{
                                opts.Logger.Debug(fmt.Sprintf("cache lookup failed for %s: %v", file.Oid, err))
                        }</span> else<span class="cov8" title="6"> if ok </span><span class="cov0" title="0">{
                                hint = externalURL
                        }</span>
                }

                <span class="cov8" title="6">if hint != "" </span><span class="cov0" title="0">{
                        if err := precommit_cache.CheckExternalURLMismatch(hint, authoritativeURL); err != nil </span><span class="cov0" title="0">{
                                opts.Logger.Warn(fmt.Sprintf("Warning. %s (path=%s oid=%s)", err.Error(), file.Name, file.Oid))
                                fmt.Fprintln(os.Stderr, "Warning.", err.Error())
                        }</span>
                }

                <span class="cov8" title="6">if opts.PreferCacheURL &amp;&amp; hint != "" </span><span class="cov0" title="0">{
                        if len(authoritativeObj.AccessMethods) &gt; 0 </span><span class="cov0" title="0">{
                                authoritativeObj.AccessMethods[0].AccessURL = drs.AccessURL{URL: hint}
                        }</span>
                }

                <span class="cov8" title="6">if err := lfs.WriteObject(common.DRS_OBJS_PATH, authoritativeObj, file.Oid); err != nil </span><span class="cov0" title="0">{
                        opts.Logger.Error(fmt.Sprintf("Could not WriteDrsFile for %s OID %s %v", file.Name, file.Oid, err))
                        continue</span>
                }
                <span class="cov8" title="6">opts.Logger.Info(fmt.Sprintf("Prepared File %s OID %s with DRS ID %s for commit", file.Name, file.Oid, authoritativeObj.Id))</span>
        }

        <span class="cov6" title="4">return nil</span>
}

// WriteDrsFile creates drsObject record from LFS file info
func WriteDrsFile(builder drs.ObjectBuilder, file lfs.LfsFileInfo, objectPath *string) (*drs.DRSObject, error) <span class="cov5" title="3">{

        // determine drs object path: use provided objectPath if non-nil/non-empty, otherwise compute default

        // if file is in cache, hasn't been committed to git or pushed to indexd
        // create a local DRS object for it
        // TODO: determine git to gen3 project hierarchy mapping (eg repo name to project ID)
        drsId := DrsUUID(builder.ProjectID, file.Oid)
        // logger.Printf("File: %s, OID: %s, DRS ID: %s\n", file.Name, file.Oid, drsId)

        // get file info needed to create indexd record
        //path, err := GetObjectPath(projectdir.LFS_OBJS_PATH, file.Oid)
        //if err != nil {
        //        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
        //}
        //if _, err := os.Stat(path); os.IsNotExist(err) {
        //        return fmt.Errorf("error: File %s does not exist in LFS objects path %s. Aborting", file.Name, path)
        //}

        drsObj, err := builder.Build(file.Name, file.Oid, file.Size, drsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error building DRS object for oid %s: %v", file.Oid, err)
        }</span>
        <span class="cov5" title="3">if objectPath != nil &amp;&amp; *objectPath != "" </span><span class="cov5" title="3">{
                drsObj.AccessMethods[0].AccessURL = drs.AccessURL{URL: *objectPath}
        }</span>

        // write drs objects to DRS_OBJS_PATH
        <span class="cov5" title="3">err = lfs.WriteObject(common.DRS_OBJS_PATH, drsObj, file.Oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error writing DRS object for oid %s: %v", file.Oid, err)
        }</span>
        <span class="cov5" title="3">return drsObj, nil</span>
}

func WriteDrsObj(drsObj *drs.DRSObject, oid string, drsObjPath string) error <span class="cov0" title="0">{
        basePath := filepath.Dir(filepath.Dir(filepath.Dir(drsObjPath)))
        return lfs.WriteObject(basePath, drsObj, oid)
}</span>

func DrsUUID(projectId string, hash string) string <span class="cov10" title="9">{
        // create UUID based on project ID and hash
        hashStr := fmt.Sprintf("%s:%s", projectId, hash)
        return uuid.NewSHA1(drs.NAMESPACE, []byte(hashStr)).String()
}</span>

// creates drsObject record from file
func DrsInfoFromOid(oid string) (*drs.DRSObject, error) <span class="cov8" title="6">{
        return lfs.ReadObject(common.DRS_OBJS_PATH, oid)
}</span>

func GetObjectPath(basePath string, oid string) (string, error) <span class="cov6" title="4">{
        return lfs.ObjectPath(basePath, oid)
}</span>

// CreateCustomPath creates a custom path based on the DRS URI
// For example, DRS URI drs://&lt;namespace&gt;:&lt;drs_id&gt;
// create custom path &lt;baseDir&gt;/&lt;namespace&gt;/&lt;drs_id&gt;
func CreateCustomPath(baseDir, drsURI string) (string, error) <span class="cov0" title="0">{
        const prefix = "drs://"
        if len(drsURI) &lt;= len(prefix) || drsURI[:len(prefix)] != prefix </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid DRS URI: %s", drsURI)
        }</span>
        <span class="cov0" title="0">rest := drsURI[len(prefix):]

        // Split by first colon
        colonIdx := -1
        for i, c := range rest </span><span class="cov0" title="0">{
                if c == ':' </span><span class="cov0" title="0">{
                        colonIdx = i
                        break</span>
                }
        }
        <span class="cov0" title="0">if colonIdx == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("DRS URI missing colon: %s", drsURI)
        }</span>
        <span class="cov0" title="0">namespace := rest[:colonIdx]
        drsId := rest[colonIdx+1:]
        return filepath.Join(baseDir, namespace, drsId), nil</span>
}

// FindMatchingRecord finds a record from the list that matches the given project ID authz
// If no matching record is found return nil
func FindMatchingRecord(records []drs.DRSObject, projectId string) (*drs.DRSObject, error) <span class="cov6" title="4">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Convert project ID to resource path format for comparison
        <span class="cov6" title="4">expectedAuthz, err := common.ProjectToResource(projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting project ID to resource format: %v", err)
        }</span>

        // Get the first record with matching authz if exists

        <span class="cov6" title="4">for _, record := range records </span><span class="cov6" title="4">{
                for _, access := range record.AccessMethods </span><span class="cov6" title="4">{
                        // assert access has Authorizations
                        if access.Authorizations == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("access method for record %v missing authorizations", record)
                        }</span>
                        <span class="cov6" title="4">if access.Authorizations.Value == expectedAuthz </span><span class="cov6" title="4">{
                                return &amp;record, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// output of git lfs ls-files
type LfsLsOutput struct {
        Files []lfs.LfsFileInfo `json:"files"`
}

type LfsDryRunSpec struct {
        Remote string // e.g. "origin"
        Ref    string // e.g. "refs/heads/main" or "HEAD"
}

// RunLfsPushDryRun executes: git lfs push --dry-run &lt;remote&gt; &lt;ref&gt;
func RunLfsPushDryRun(ctx context.Context, repoDir string, spec LfsDryRunSpec, logger *slog.Logger) (string, error) <span class="cov0" title="0">{
        if spec.Remote == "" || spec.Ref == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing remote or ref")
        }</span>

        // Debug-print the command to stderr
        <span class="cov0" title="0">fullCmd := []string{"git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref}
        logger.Debug(fmt.Sprintf("running command: %v", fullCmd))

        cmd := execCommandContext(ctx, "git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref)
        cmd.Dir = repoDir

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        out := stdout.String()
        if err != nil </span><span class="cov0" title="0">{
                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span>
                <span class="cov0" title="0">return out, fmt.Errorf("git lfs push --dry-run failed: %s", msg)</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/cmd"
        "github.com/calypr/git-drs/drslog"
)

func main() <span class="cov10" title="95">{

        _, err := drslog.NewLogger("", true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open log file: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov10" title="95">if err := cmd.RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                drslog.Close() // closes log file if there was one
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package gitrepo

import (
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/calypr/git-drs/common"
        "github.com/go-git/go-git/v5"
)

func DrsTopLevel() (string, error) <span class="cov1" title="1">{
        base, err := GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(base, common.DRS_DIR), nil</span>
}

// GetRepo opens the current git repository
func GetRepo() (*git.Repository, error) <span class="cov8" title="152">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="152">return git.PlainOpenWithOptions(cwd, &amp;git.PlainOpenOptions{DetectDotGit: true})</span>
}

// GitTopLevel returns the absolute path of the git repository root
func GitTopLevel() (string, error) <span class="cov5" title="16">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov5" title="15">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="15">return wt.Filesystem.Root(), nil</span>
}

// GetGitConfigString reads a string value from git config using the git command
// to ensure we pick up values from all scopes (system, global, local).
func GetGitConfigString(key string) (string, error) <span class="cov10" title="330">{
        cmd := exec.Command("git", "config", "--get", key)
        out, err := cmd.Output()
        if err != nil </span><span class="cov8" title="110">{
                // git config returns exit code 1 if the key is not found
                return "", nil
        }</span>
        <span class="cov9" title="220">return strings.TrimSpace(string(out)), nil</span>
}

// GetGitConfigInt reads an integer value from git config
func GetGitConfigInt(key string, defaultValue int64) int64 <span class="cov7" title="73">{
        valStr, err := GetGitConfigString(key)
        if err != nil || valStr == "" </span><span class="cov1" title="1">{
                return defaultValue
        }</span>
        <span class="cov7" title="72">val, err := strconv.ParseInt(valStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov7" title="72">return val</span>
}

// GetGitConfigBool reads a boolean value from git config
func GetGitConfigBool(key string, defaultValue bool) bool <span class="cov8" title="146">{
        valStr, err := GetGitConfigString(key)
        if err != nil || valStr == "" </span><span class="cov2" title="2">{
                return defaultValue
        }</span>
        <span class="cov8" title="144">val, err := strconv.ParseBool(valStr)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov8" title="144">return val</span>
}

func SetGitConfigOptions(configs map[string]string) error <span class="cov3" title="6">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="6">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="6">for key, value := range configs </span><span class="cov7" title="54">{
                parts := strings.Split(key, ".")
                if len(parts) == 2 </span><span class="cov5" title="18">{
                        conf.Raw.Section(parts[0]).SetOption(parts[1], value)
                }</span> else<span class="cov6" title="36"> if len(parts) &gt; 2 </span><span class="cov6" title="36">{
                        // Handle subsections e.g. lfs.customtransfer.drs.path
                        section := parts[0]
                        subsection := strings.Join(parts[1:len(parts)-1], ".")
                        key := parts[len(parts)-1]
                        conf.Raw.Section(section).Subsection(subsection).SetOption(key, value)
                }</span>
        }

        <span class="cov3" title="6">return repo.Storer.SetConfig(conf)</span>
}

// GetGitHooksDir returns the absolute path to the .git/hooks directory
func GetGitHooksDir() (string, error) <span class="cov3" title="6">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="6">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // This is a simplification; for complex setups (submodules, worktrees),
        // we might need more robust logic, but this matches previous behavior.
        <span class="cov3" title="6">return filepath.Join(wt.Filesystem.Root(), ".git", "hooks"), nil</span>
}

// AddFile adds a file to the git staging area (index)
func AddFile(path string) error <span class="cov0" title="0">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = wt.Add(path)
        return err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package testutils

import (
        "fmt"
        "os"
        "os/exec"
        "testing"

        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/stretchr/testify/require"
)

// SetupTestGitRepo creates a temp directory mocking a real git repo
func SetupTestGitRepo(t *testing.T) string <span class="cov7" title="12">{
        t.Helper()

        tmpDir, err := os.MkdirTemp("", "git-drs-test-*")
        require.NoError(t, err)

        originalDir, err := os.Getwd()
        require.NoError(t, err)

        err = os.Chdir(tmpDir)
        require.NoError(t, err)

        cmd := exec.Command("git", "init")
        cmd.Dir = tmpDir
        err = cmd.Run()
        require.NoError(t, err)

        cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        cmd = exec.Command("git", "config", "user.name", "Test User")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        t.Cleanup(func() </span><span class="cov7" title="12">{
                os.Chdir(originalDir)
                os.RemoveAll(tmpDir)
        }</span>)

        <span class="cov7" title="12">return tmpDir</span>
}

// CreateTestConfig applies the given config to the git repository using git config commands
func CreateTestConfig(t *testing.T, tmpDir string, cfg *config.Config) <span class="cov5" title="6">{
        t.Helper()

        // Helper to run git config
        setConfig := func(key, value string) </span><span class="cov10" title="29">{
                cmd := exec.Command("git", "config", key, value)
                cmd.Dir = tmpDir
                err := cmd.Run()
                require.NoError(t, err, "failed to set git config %s=%s", key, value)
        }</span>

        <span class="cov5" title="6">if cfg.DefaultRemote != "" </span><span class="cov5" title="5">{
                setConfig("lfs.customtransfer.drs.default-remote", string(cfg.DefaultRemote))
        }</span>

        <span class="cov5" title="6">for name, remote := range cfg.Remotes </span><span class="cov5" title="6">{
                prefix := fmt.Sprintf("lfs.customtransfer.drs.remote.%s", name)
                if remote.Gen3 != nil </span><span class="cov5" title="6">{
                        setConfig(prefix+".type", "gen3")
                        setConfig(prefix+".endpoint", remote.Gen3.Endpoint)
                        setConfig(prefix+".project", remote.Gen3.ProjectID)
                        setConfig(prefix+".bucket", remote.Gen3.Bucket)
                }</span> else<span class="cov0" title="0"> if remote.Anvil != nil </span><span class="cov0" title="0">{
                        setConfig(prefix+".type", "anvil")
                }</span>
        }
}

// CreateDefaultTestConfig creates a standard test configuration
func CreateDefaultTestConfig(t *testing.T, tmpDir string) *config.Config <span class="cov4" title="4">{
        t.Helper()

        testConfig := &amp;config.Config{
                DefaultRemote: config.Remote(config.ORIGIN),
                Remotes: map[config.Remote]config.RemoteSelect{
                        config.Remote(config.ORIGIN): {
                                Gen3: &amp;indexd.Gen3Remote{
                                        Endpoint:  "https://test.gen3.org",
                                        ProjectID: "test-project",
                                        Bucket:    "test",
                                },
                        },
                },
        }

        CreateTestConfig(t, tmpDir, testConfig)
        return testConfig
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package testutils

import (
        "bytes"
        "io"
        "os"
        "testing"

        "github.com/stretchr/testify/require"
)

// CaptureStdout captures stdout during test execution
func CaptureStdout(t *testing.T, f func()) string <span class="cov10" title="6">{
        t.Helper()

        r, w, err := os.Pipe()
        require.NoError(t, err)

        oldStdout := os.Stdout
        os.Stdout = w

        defer func() </span><span class="cov10" title="6">{
                os.Stdout = oldStdout
        }</span>()

        <span class="cov10" title="6">outC := make(chan string)
        go func() </span><span class="cov10" title="6">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, r)
                outC &lt;- buf.String()
        }</span>()

        <span class="cov10" title="6">f()

        w.Close()
        output := &lt;-outC

        return output</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package testutils

import (
        "os"
        "testing"
)

// RunCmdMainTest is a generic test helper for cmd main packages
// It verifies the package compiles and can handle basic argument scenarios
func RunCmdMainTest(t *testing.T, cmdName string) <span class="cov6" title="6">{
        t.Helper()

        // Save original args
        oldArgs := os.Args
        defer func() </span><span class="cov6" title="6">{ os.Args = oldArgs }</span>()

        // Test with no arguments
        <span class="cov6" title="6">os.Args = []string{cmdName}

        t.Logf("%s main function test", cmdName)</span>
}

// RunCmdArgsTest is a generic test helper for validating command arguments
func RunCmdArgsTest(t *testing.T) <span class="cov6" title="6">{
        t.Helper()

        tests := []struct {
                name string
                args []string
        }{
                {"no args", []string{}},
                {"one arg", []string{"arg1"}},
                {"multiple args", []string{"arg1", "arg2"}},
        }

        for _, tt := range tests </span><span class="cov10" title="18">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="18">{
                        if len(tt.args) &gt;= 0 </span><span class="cov10" title="18">{
                                t.Logf("Args count: %d", len(tt.args))
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package lfs

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// UpsertDRSRouteLines adds or updates .gitattributes lines of the form:
//
//        &lt;pattern&gt; drs.route=&lt;ro|rw&gt;
//
// Returns changed=true if the file was modified.
func UpsertDRSRouteLines(gitattributesPath string, mode string, patterns []string) (changed bool, err error) <span class="cov5" title="5">{
        mode = strings.ToLower(strings.TrimSpace(mode))
        if mode != "ro" &amp;&amp; mode != "rw" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid mode %q", mode)
        }</span>

        // Normalize patterns (preserve original spelling except trim).
        <span class="cov5" title="5">want := make(map[string]string, len(patterns))
        order := make([]string, 0, len(patterns))
        for _, p := range patterns </span><span class="cov5" title="5">{
                p = strings.TrimSpace(p)
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="5">if _, ok := want[p]; !ok </span><span class="cov5" title="5">{
                        want[p] = p
                        order = append(order, p)
                }</span>
        }
        <span class="cov5" title="5">if len(order) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no patterns provided")
        }</span>

        // Read existing file if present.
        <span class="cov5" title="5">var lines []string
        data, readErr := os.ReadFile(gitattributesPath)
        if readErr == nil </span><span class="cov4" title="4">{
                sc := bufio.NewScanner(strings.NewReader(string(data)))
                for sc.Scan() </span><span class="cov7" title="9">{
                        lines = append(lines, sc.Text())
                }</span>
                <span class="cov4" title="4">if err := sc.Err(); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("read %s: %w", gitattributesPath, err)
                }</span>
        } else<span class="cov1" title="1"> if !os.IsNotExist(readErr) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("read %s: %w", gitattributesPath, readErr)
        }</span>

        // Build index of existing drs.route lines.
        // We match "pattern ... drs.route=&lt;x&gt;" in a whitespace-tolerant way, but only update
        // if the first token equals the pattern exactly.
        <span class="cov5" title="5">seen := make(map[string]int) // pattern -&gt; line index
        for i, line := range lines </span><span class="cov7" title="9">{
                pat, _, ok := parseRouteLine(line)
                if ok </span><span class="cov4" title="3">{
                        seen[pat] = i
                }</span>
        }

        // Apply upserts.
        <span class="cov5" title="5">for _, pat := range order </span><span class="cov5" title="5">{
                newLine := fmt.Sprintf("%s drs.route=%s", pat, mode)

                if idx, ok := seen[pat]; ok </span><span class="cov2" title="2">{
                        // Update only if different
                        if strings.TrimSpace(lines[idx]) != newLine </span><span class="cov1" title="1">{
                                lines[idx] = newLine
                                changed = true
                        }</span>
                } else<span class="cov4" title="3"> {
                        lines = append(lines, newLine)
                        changed = true
                }</span>
        }

        <span class="cov5" title="5">if !changed &amp;&amp; readErr == nil </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        // Ensure directory exists (it should, but be safe).
        <span class="cov4" title="4">if err := os.MkdirAll(filepath.Dir(gitattributesPath), 0o755); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("mkdir %s: %w", filepath.Dir(gitattributesPath), err)
        }</span>

        // Write back with trailing newline.
        <span class="cov4" title="4">out := strings.Join(lines, "\n")
        if !strings.HasSuffix(out, "\n") </span><span class="cov4" title="4">{
                out += "\n"
        }</span>
        <span class="cov4" title="4">if err := os.WriteFile(gitattributesPath, []byte(out), 0o644); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("write %s: %w", gitattributesPath, err)
        }</span>
        <span class="cov4" title="4">return true, nil</span>
}

// parseRouteLine returns (pattern, mode, ok) for lines like:
//
//        scratch/** drs.route=rw
//
// It ignores comments and blank lines.
func parseRouteLine(line string) (pattern string, mode string, ok bool) <span class="cov7" title="10">{
        s := strings.TrimSpace(line)
        if s == "" || strings.HasPrefix(s, "#") </span><span class="cov1" title="1">{
                return "", "", false
        }</span>

        // Tokenize by whitespace.
        <span class="cov7" title="9">parts := strings.Fields(s)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return "", "", false
        }</span>

        <span class="cov7" title="9">pat := parts[0]
        for _, tok := range parts[1:] </span><span class="cov10" title="24">{
                if strings.HasPrefix(tok, "drs.route=") </span><span class="cov4" title="4">{
                        val := strings.TrimPrefix(tok, "drs.route=")
                        val = strings.ToLower(strings.TrimSpace(val))
                        if val == "ro" || val == "rw" </span><span class="cov4" title="4">{
                                return pat, val, true
                        }</span>
                        // present but invalid -&gt; treat as not-ok to avoid fixing unknown formats silently
                        <span class="cov0" title="0">return "", "", false</span>
                }
        }
        <span class="cov5" title="5">return "", "", false</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package lfs

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/calypr/git-drs/gitrepo"
)

// runGitAllowMissing treats "key not found" as empty output, not an error.
func runGitAllowMissing(ctx context.Context, args ...string) (string, error) <span class="cov9" title="8">{
        cmd := exec.CommandContext(ctx, "git", args...)
        // Use Output() to get stdout only.
        // GIT_TRACE et al go to stderr.
        b, err := cmd.Output()
        //if err != nil {
        //        // "git config --get missing.key" exits 1 with empty output.
        //        var exitErr *exec.ExitError
        //        if errors.As(err, &amp;exitErr) &amp;&amp; exitErr.ExitCode() == 1 {
        //                return "", nil
        //        }
        //}
        if err != nil </span><span class="cov7" title="5">{
                // "git config --get missing.key" exits 1 with empty output.
                s := strings.TrimSpace(string(b))
                if s == "" </span><span class="cov7" title="5">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("%v: &gt;%s&lt;", err, s)</span>
        }
        <span class="cov5" title="3">return string(b), nil</span>
}

// resolveLFSRoot implements:
// - if `git config --get lfs.storage` is set: use it
//   - if relative: resolve relative to GitCommonDir (this is how git-lfs treats it in practice)
//
// - else: &lt;GitCommonDir&gt;/lfs
func resolveLFSRoot(ctx context.Context, gitCommonDir string) (string, error) <span class="cov9" title="8">{
        // NOTE: git config --get returns exit status 1 if key not found.
        out, err := runGitAllowMissing(ctx, "config", "--get", "lfs.storage")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git config --get lfs.storage failed: %w", err)
        }</span>
        <span class="cov9" title="8">val := strings.TrimSpace(out)

        if val == "" </span><span class="cov7" title="5">{
                return filepath.Clean(filepath.Join(gitCommonDir, "lfs")), nil
        }</span>

        // Expand ~ if present (nice-to-have).
        <span class="cov5" title="3">if strings.HasPrefix(val, "~") &amp;&amp; (len(val) == 1 || val[1] == '/' || val[1] == '\\') </span><span class="cov1" title="1">{
                home, herr := userHomeDir()
                if herr == nil &amp;&amp; home != "" </span><span class="cov1" title="1">{
                        val = filepath.Join(home, strings.TrimPrefix(val, "~"))
                }</span>
        }

        <span class="cov5" title="3">if !filepath.IsAbs(val) </span><span class="cov1" title="1">{
                val = filepath.Join(gitCommonDir, val)
        }</span>
        <span class="cov5" title="3">return filepath.Clean(val), nil</span>
}

func runGit(ctx context.Context, args ...string) (string, error) <span class="cov10" title="10">{
        cmd := exec.CommandContext(ctx, "git", args...)
        b, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%v: %s", err, strings.TrimSpace(string(b)))
        }</span>
        <span class="cov10" title="10">return string(b), nil</span>
}

func userHomeDir() (string, error) <span class="cov1" title="1">{
        // Avoid os/user on some cross-compile scenarios; keep it simple.
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Not your target, but safe fallback.
                return "", errors.New("home expansion not supported on windows in this helper")
        }</span>
        <span class="cov1" title="1">if home := strings.TrimSpace(os.Getenv("HOME")); home != "" </span><span class="cov1" title="1">{
                return home, nil
        }</span>
        // macOS/Linux
        <span class="cov0" title="0">out, err := exec.Command("sh", "-lc", "printf %s \"$HOME\"").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}

func GetGitAttribute(ctx context.Context, attr string, path string) (string, error) <span class="cov0" title="0">{
        out, err := runGit(ctx, "check-attr", attr, "--", path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git check-attr failed: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

//
// --- Git helpers ---
//

func GitLFSTrack(ctx context.Context, path string) (bool, error) <span class="cov3" title="2">{
        out, err := runGit(ctx, "lfs", "track", path)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("git lfs track failed: %w", err)
        }</span>
        <span class="cov3" title="2">return strings.Contains(out, path), nil</span>
}

func GitLFSTrackReadOnly(ctx context.Context, path string) (bool, error) <span class="cov3" title="2">{
        _, err := GitLFSTrack(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("git lfs track failed: %w", err)
        }</span>

        <span class="cov3" title="2">repoRoot, err := gitrepo.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="2">attrPath := filepath.Join(repoRoot, ".gitattributes")
        changed, err := UpsertDRSRouteLines(attrPath, "ro", []string{path})
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="2">return changed, nil</span>
}

func gitRevParseGitCommonDir(ctx context.Context) (string, error) <span class="cov9" title="8">{
        out, err := runGit(ctx, "rev-parse", "--git-common-dir")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git rev-parse --git-common-dir failed: %w", err)
        }</span>
        <span class="cov9" title="8">dir := strings.TrimSpace(out)
        if dir == "" </span><span class="cov0" title="0">{
                return "", errors.New("git rev-parse returned empty --git-common-dir")
        }</span>
        // If relative, resolve it against current working directory.
        <span class="cov9" title="8">if !filepath.IsAbs(dir) </span><span class="cov9" title="8">{
                abs, err := filepath.Abs(dir)
                if err == nil </span><span class="cov9" title="8">{
                        dir = abs
                }</span>
        }
        <span class="cov9" title="8">return dir, nil</span>
}

// GetGitRootDirectories
// returns (gitCommonDir, lfsRoot, error).
func GetGitRootDirectories(ctx context.Context) (string, string, error) <span class="cov6" title="4">{
        gitCommonDir, err := gitRevParseGitCommonDir(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov6" title="4">lfsRoot, err := resolveLFSRoot(ctx, gitCommonDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov6" title="4">if lfsRoot == "" </span><span class="cov0" title="0">{
                lfsRoot = filepath.Join(gitCommonDir, "lfs")
        }</span>
        <span class="cov6" title="4">return gitCommonDir, lfsRoot, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package lfs

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/calypr/data-client/drs"
        "github.com/calypr/data-client/hash"
)

type DryRunSpec struct {
        Remote string // e.g. "origin"
        Ref    string // e.g. "refs/heads/main" or "HEAD"
}

// RunPushDryRun executes: git lfs push --dry-run &lt;remote&gt; &lt;ref&gt;
func RunPushDryRun(ctx context.Context, repoDir string, spec DryRunSpec, logger *slog.Logger) (string, error) <span class="cov8" title="6">{
        if spec.Remote == "" || spec.Ref == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing remote or ref")
        }</span>

        // Debug-print the command to stderr
        <span class="cov8" title="6">fullCmd := []string{"git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref}
        logger.Debug(fmt.Sprintf("running command: %v", fullCmd))

        cmd := exec.CommandContext(ctx, "git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref)
        cmd.Dir = repoDir

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        out := stdout.String()
        if err != nil </span><span class="cov0" title="0">{
                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span>
                <span class="cov0" title="0">return out, fmt.Errorf("git lfs push --dry-run failed: %s", msg)</span>
        }
        <span class="cov8" title="6">return out, nil</span>
}

func GetAllLfsFiles(gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) (map[string]LfsFileInfo, error) <span class="cov8" title="6">{
        if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger is required")
        }</span>
        <span class="cov8" title="6">repoDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // no timeout for now
        <span class="cov8" title="6">ctx := context.Background()

        if gitRemoteName == "" </span><span class="cov0" title="0">{
                gitRemoteName = "origin"
        }</span>
        <span class="cov8" title="6">if gitRemoteLocation != "" </span><span class="cov8" title="6">{
                logger.Debug(fmt.Sprintf("Using git remote %s at %s for LFS dry-run", gitRemoteName, gitRemoteLocation))
        }</span> else<span class="cov0" title="0"> {
                logger.Debug(fmt.Sprintf("Using git remote %s for LFS dry-run", gitRemoteName))
        }</span>

        <span class="cov8" title="6">refs := buildRefs(branches)
        lfsFileMap := make(map[string]LfsFileInfo)
        for _, ref := range refs </span><span class="cov8" title="6">{
                spec := DryRunSpec{
                        Remote: gitRemoteName,
                        Ref:    ref,
                }
                out, err := RunPushDryRun(ctx, repoDir, spec, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="6">if err := addFilesFromDryRun(out, repoDir, logger, lfsFileMap); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="6">return lfsFileMap, nil</span>
}

func buildRefs(branches []string) []string <span class="cov8" title="6">{
        if len(branches) == 0 </span><span class="cov0" title="0">{
                return []string{"HEAD"}
        }</span>
        <span class="cov8" title="6">refs := make([]string, 0, len(branches))
        seen := make(map[string]struct{})
        for _, branch := range branches </span><span class="cov8" title="6">{
                branch = strings.TrimSpace(branch)
                if branch == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="6">ref := branch
                if branch != "HEAD" &amp;&amp; !strings.HasPrefix(branch, "refs/") </span><span class="cov8" title="6">{
                        ref = fmt.Sprintf("refs/heads/%s", branch)
                }</span>
                <span class="cov8" title="6">if _, ok := seen[ref]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="6">seen[ref] = struct{}{}
                refs = append(refs, ref)</span>
        }
        <span class="cov8" title="6">if len(refs) == 0 </span><span class="cov0" title="0">{
                return []string{"HEAD"}
        }</span>
        <span class="cov8" title="6">return refs</span>
}

func addFilesFromDryRun(out, repoDir string, logger *slog.Logger, lfsFileMap map[string]LfsFileInfo) error <span class="cov8" title="6">{
        // Log when dry-run returns no output to help with debugging
        if strings.TrimSpace(out) == "" </span><span class="cov0" title="0">{
                logger.Debug("No LFS files to push (dry-run returned no output)")
                return nil
        }</span>

        // accept lowercase or uppercase hex
        <span class="cov8" title="6">sha256Re := regexp.MustCompile(`(?i)^[a-f0-9]{64}$`)

        for _, line := range strings.Split(strings.TrimSpace(string(out)), "\n") </span><span class="cov10" title="8">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="8">parts := strings.Fields(line)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="8">oid := parts[1]
                path := parts[len(parts)-1]

                // Validate OID looks like a SHA256 hex string.
                if !sha256Re.MatchString(oid) </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("skipping LFS line with invalid oid %q: %q", oid, line))
                        continue</span>
                }

                // see https://github.com/calypr/git-drs/issues/124#issuecomment-3721837089
                <span class="cov10" title="8">if oid == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" &amp;&amp; strings.Contains(path, ".gitattributes") </span><span class="cov4" title="2">{
                        logger.Debug(fmt.Sprintf("skipping empty LFS pointer for %s", path))
                        continue</span>
                }
                // Remove a trailing parenthetical suffix from p, e.g.:
                // "path/to/file.dat (100 KB)" -&gt; "path/to/file.dat"
                <span class="cov8" title="6">if idx := strings.LastIndex(path, " ("); idx != -1 &amp;&amp; strings.HasSuffix(path, ")") </span><span class="cov0" title="0">{
                        path = strings.TrimSpace(path[:idx])
                }</span>
                <span class="cov8" title="6">size := int64(0)
                absPath := path
                if repoDir != "" &amp;&amp; !filepath.IsAbs(path) </span><span class="cov8" title="6">{
                        absPath = filepath.Join(repoDir, path)
                }</span>
                <span class="cov8" title="6">if stat, err := os.Stat(absPath); err == nil </span><span class="cov8" title="6">{
                        size = stat.Size()
                }</span> else<span class="cov0" title="0"> {
                        logger.Error(fmt.Sprintf("could not stat file %s: %v", path, err))
                        continue</span>
                }

                // If the file is small, read it and detect LFS pointer signature.
                // Pointer files are textual and include the LFS spec version + an oid line.
                <span class="cov8" title="6">if size &gt; 0 &amp;&amp; size &lt; 2048 </span><span class="cov7" title="4">{
                        if data, readErr := os.ReadFile(absPath); readErr == nil </span><span class="cov7" title="4">{
                                s := strings.TrimSpace(string(data))
                                if strings.Contains(s, "version https://git-lfs.github.com/spec/v1") &amp;&amp; strings.Contains(s, "oid sha256:") </span><span class="cov0" title="0">{
                                        logger.Warn(fmt.Sprintf("WARNING: Detected upload of lfs pointer file %s skipping", path))
                                        continue</span>
                                }
                        }
                }

                <span class="cov8" title="6">lfsFileMap[path] = LfsFileInfo{
                        Name:    path,
                        Size:    size,
                        OidType: "sha256",
                        Oid:     oid,
                        Version: "https://git-lfs.github.com/spec/v1",
                }</span>
        }

        <span class="cov8" title="6">return nil</span>
}

// CreateLfsPointer creates a Git LFS pointer file for the given DRS object.
func CreateLfsPointer(drsObj *drs.DRSObject, dst string) error <span class="cov0" title="0">{
        sumMap := hash.ConvertHashInfoToMap(drsObj.Checksums)
        if len(sumMap) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no checksums found for DRS object")
        }</span>

        // find sha256 checksum
        <span class="cov0" title="0">var shaSum string
        for csType, cs := range sumMap </span><span class="cov0" title="0">{
                if csType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                        shaSum = cs
                        break</span>
                }
        }
        <span class="cov0" title="0">if shaSum == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no sha256 checksum found for DRS object")
        }</span>

        // create pointer file content
        <span class="cov0" title="0">pointerContent := "version https://git-lfs.github.com/spec/v1\n"
        pointerContent += fmt.Sprintf("oid sha256:%s\n", shaSum)
        pointerContent += fmt.Sprintf("size %d\n", drsObj.Size)

        // write to file
        err := os.WriteFile(dst, []byte(pointerContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write LFS pointer file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package lfs

import (
        "bytes"
        "fmt"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
)

// IsLFSTracked returns true if the given path is tracked by Git LFS
// (i.e. has `filter=lfs` via git attributes).
func IsLFSTracked(path string) (bool, error) <span class="cov8" title="7">{
        if path == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("path is empty")
        }</span>

        // Git prefers forward slashes, even on macOS/Linux
        <span class="cov8" title="7">cleanPath := filepath.ToSlash(path)

        cmd := exec.Command(
                "git",
                "check-attr",
                "filter",
                "--",
                cleanPath,
        )

        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;out

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("git check-attr failed: %w (%s)", err, out.String())
        }</span>

        // Expected output:
        // path: filter: lfs
        // path: filter: unspecified
        //
        // Format is stable and documented, but some git wrappers print extra
        // debugging lines. eg GIT_TRACE=1 GIT_TRANSFER_TRACE=1
        // Only consider the line that starts with the queried
        // path so we do not parse unrelated output.
        <span class="cov8" title="7">output := out.String()
        prefix := cleanPath + ":"
        for _, line := range strings.Split(output, "\n") </span><span class="cov10" title="11">{
                line = strings.TrimSpace(line)
                if line == "" || !strings.HasPrefix(line, prefix) </span><span class="cov7" title="5">{
                        continue</span>
                }

                <span class="cov7" title="6">fields := strings.SplitN(line, ":", 3)
                if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov7" title="6">value := strings.TrimSpace(fields[2])
                return value == "lfs", nil</span>
        }

        <span class="cov1" title="1">return false, nil</span>
}

// LfsFileInfo represents the information about an LFS file
type LfsFileInfo struct {
        Name       string `json:"name"`
        Size       int64  `json:"size"`
        Checkout   bool   `json:"checkout"`
        Downloaded bool   `json:"downloaded"`
        OidType    string `json:"oid_type"`
        Oid        string `json:"oid"`
        Version    string `json:"version"`
}

type lfsLsOutput struct {
        Files []LfsFileInfo `json:"files"`
}

// CheckIfLfsFile checks if a given file is tracked by Git LFS.
// Returns true and file info if it's an LFS file, false otherwise.
func CheckIfLfsFile(fileName string) (bool, *LfsFileInfo, error) <span class="cov0" title="0">{
        // Use git lfs ls-files -I to check if specific file is LFS tracked
        cmd := exec.Command("git", "lfs", "ls-files", "-I", fileName, "--json")
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If git lfs ls-files returns error, the file is not LFS tracked
                return false, nil, nil
        }</span>

        // If output is empty, file is not LFS tracked
        <span class="cov0" title="0">if len(strings.TrimSpace(string(out))) == 0 </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        // Parse the JSON output
        <span class="cov0" title="0">var output lfsLsOutput
        err = sonic.ConfigFastest.Unmarshal(out, &amp;output)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("error unmarshaling git lfs ls-files output for %s: %v", fileName, err)
        }</span>

        // If no files in output, not LFS tracked
        <span class="cov0" title="0">if len(output.Files) == 0 </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        <span class="cov0" title="0">return true, &amp;output.Files[0], nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package lfs

import (
        "github.com/bytedance/sonic/encoder"
        dataClientCommon "github.com/calypr/data-client/common"
)

// InitMessage represents the structure of the initiation data
type InitMessage struct {
        Event               string `json:"event"`               // Always "init" to identify this message
        Operation           string `json:"operation"`           // "upload" or "download" depending on transfer direction
        Remote              string `json:"remote"`              // Git remote name or URL
        Concurrent          bool   `json:"concurrent"`          // Reflects lfs.customtransfer.&lt;name&gt;.concurrent
        ConcurrentTransfers int    `json:"concurrenttransfers"` // Reflects lfs.concurrenttransfers value
}

// CompleteMessage is a minimal response to signal transfer is "complete"
type CompleteMessage struct {
        Event string `json:"event"`
        Oid   string `json:"oid"`
        Path  string `json:"path,omitempty"`
}

// UploadMessage represents a request to upload an object.
type UploadMessage struct {
        Event  string  `json:"event"`  // "upload"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Path   string  `json:"path"`   // Local path to file
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
}

// DownloadMessage represents a request to download an object.
type DownloadMessage struct {
        Event  string  `json:"event"`  // "download"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
        Path   string  `json:"path"`   // Where to store the downloaded file
}

// TerminateMessage is sent when the agent should terminate.
type TerminateMessage struct {
        Event string `json:"event"` // "terminate"
}

// ErrorMessage is sent when an error occurs during a transfer.
type ErrorMessage struct {
        Event string `json:"event"` // "error"
        Oid   string `json:"oid"`   // Object ID involved in the error
        Error Error  `json:"error"` // Error details
}

type InitErrorMessage struct {
        Error Error `json:"error"` // Error details
}

type Error struct {
        Code    int    `json:"code"`    // Error code (standard or custom)
        Message string `json:"message"` // Human-readable error message
}

// ProgressResponse provides progress updates for an object transfer.
type ProgressResponse struct {
        Event          string `json:"event"`          // "progress"
        Oid            string `json:"oid"`            // Object ID being transferred
        BytesSoFar     int64  `json:"bytesSoFar"`     // Bytes transferred so far
        BytesSinceLast int64  `json:"bytesSinceLast"` // Bytes transferred since last progress message
}

// LogResponse provides log updates for an object transfer.
type LogResponse struct {
        Event   string `json:"event"`   // "log"
        Message string `json:"message"` // The log message
}

// TerminateResponse signals the agent has completed termination.
type TerminateResponse struct {
        Event string `json:"event"` // "terminate"
}

// Action is an optional struct representing transfer actions (upload/download URLs, etc.)
type Action struct {
        Href      string            `json:"href"`
        Header    map[string]string `json:"header,omitempty"`
        ExpiresIn int               `json:"expires_in,omitempty"`
}

func WriteInitErrorMessage(encoder *encoder.StreamEncoder, code int, errMsg string) <span class="cov2" title="2">{
        // create failure message and send it back
        errorResponse := InitErrorMessage{
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteErrorMessage(encoder *encoder.StreamEncoder, oid string, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := ErrorMessage{
                Event: "complete",
                Oid:   oid,
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteCompleteMessage(encoder *encoder.StreamEncoder, oid string, path string) <span class="cov5" title="11">{
        // create success message and send it back
        completeResponse := CompleteMessage{
                Event: "complete",
                Oid:   oid,
                Path:  path,
        }
        encoder.Encode(completeResponse)
}</span>

func WriteProgressMessage(encoder *encoder.StreamEncoder, oid string, bytesSoFar int64, bytesSinceLast int64) <span class="cov8" title="51">{
        progressResponse := ProgressResponse{
                Event:          "progress",
                Oid:            oid,
                BytesSoFar:     bytesSoFar,
                BytesSinceLast: bytesSinceLast,
        }
        encoder.Encode(progressResponse)
}</span>

// NewProgressCallback returns a ProgressCallback that sends progress events
// to git-lfs via the streamEncoder
func NewProgressCallback(streamEncoder *encoder.StreamEncoder) dataClientCommon.ProgressCallback <span class="cov5" title="10">{
        return func(event dataClientCommon.ProgressEvent) error </span><span class="cov10" title="116">{
                if event.Event == "log" </span><span class="cov9" title="70">{
                        // Don't send log events to Git LFS as they are not part of the protocol
                        // and cause Git LFS to think the transfer is complete.
                        return nil
                }</span>
                <span class="cov8" title="46">WriteProgressMessage(streamEncoder, event.Oid, event.BytesSoFar, event.BytesSinceLast)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package lfs

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/drs"
        "github.com/calypr/git-drs/common"
)

// This file contains functions that pertain to .git/drs/lfs/objects directory walk
type PendingObject struct {
        OID  string
        Path string
}

type ObjectStore struct {
        BasePath string
        Logger   *slog.Logger
}

func NewObjectStore(basePath string, logger *slog.Logger) *ObjectStore <span class="cov10" title="31">{
        return &amp;ObjectStore{
                BasePath: basePath,
                Logger:   logger,
        }
}</span>

func ObjectPath(basePath string, oid string) (string, error) <span class="cov6" title="9">{
        store := NewObjectStore(basePath, nil)
        return store.ObjectPath(oid)
}</span>

func WriteObject(basePath string, drsObj *drs.DRSObject, oid string) error <span class="cov7" title="13">{
        store := NewObjectStore(basePath, nil)
        return store.WriteObject(drsObj, oid)
}</span>

func ReadObject(basePath string, oid string) (*drs.DRSObject, error) <span class="cov6" title="9">{
        store := NewObjectStore(basePath, nil)
        return store.ReadObject(oid)
}</span>

func (s *ObjectStore) ObjectPath(oid string) (string, error) <span class="cov10" title="31">{
        // check that oid is a valid sha256 hash
        if len(oid) != 64 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error: %s is not a valid sha256 hash", oid)
        }</span>

        <span class="cov9" title="30">return filepath.Join(s.BasePath, oid[:2], oid[2:4], oid), nil</span>
}

func (s *ObjectStore) WriteObject(drsObj *drs.DRSObject, oid string) error <span class="cov7" title="13">{
        indexdObjBytes, err := sonic.ConfigFastest.Marshal(drsObj)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshalling indexd object for oid %s: %v", oid, err)
        }</span>

        <span class="cov7" title="13">drsObjPath, err := s.ObjectPath(oid)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="13">if err := os.MkdirAll(filepath.Dir(drsObjPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating directory for %s: %v", drsObjPath, err)
        }</span>

        <span class="cov7" title="13">if err := os.WriteFile(drsObjPath, indexdObjBytes, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing %s: %v", drsObjPath, err)
        }</span>
        <span class="cov7" title="13">return nil</span>
}

func (s *ObjectStore) ReadObject(oid string) (*drs.DRSObject, error) <span class="cov6" title="9">{
        path, err := s.ObjectPath(oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span>

        <span class="cov6" title="9">drsObjBytes, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov6" title="9">var drsObject drs.DRSObject
        if err := sonic.ConfigFastest.Unmarshal(drsObjBytes, &amp;drsObject); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov6" title="9">return &amp;drsObject, nil</span>
}

// getPendingObjects walks .git/drs/lfs/objects/ to find all pending records
func GetPendingObjects(logger *slog.Logger) ([]*PendingObject, error) <span class="cov1" title="1">{
        var objects []*PendingObject
        objectsDir := common.DRS_OBJS_PATH

        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov5" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="5">if info.IsDir() </span><span class="cov3" title="3">{
                        return nil
                }</span>
                <span class="cov2" title="2">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov1" title="1">oid := parts[2] // GetObjectPath stores full OID in the 3rd directory level
                objects = append(objects, &amp;PendingObject{
                        OID: oid,
                })
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found %d pending objects in %s", len(objects), objectsDir))
        return objects, nil</span>
}

func GetDrsLfsObjects(logger *slog.Logger) (map[string]*drs.DRSObject, error) <span class="cov1" title="1">{
        objects := map[string]*drs.DRSObject{}
        objectsDir := common.DRS_OBJS_PATH
        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("DRS objects directory not found: %s", objectsDir))
                return nil, nil
        }</span>

        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov5" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error accessing path %s: %v", path, err))
                        return err
                }</span>
                <span class="cov5" title="6">if info.IsDir() </span><span class="cov3" title="3">{
                        return nil
                }</span>
                <span class="cov3" title="3">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="3">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov2" title="2">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error reading file %s: %v", path, err))
                        return err
                }</span>
                <span class="cov2" title="2">var drsObject drs.DRSObject
                if err := sonic.ConfigFastest.Unmarshal(data, &amp;drsObject); err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("Error unmarshalling JSON from %s: %v", path, err))
                        return nil
                }</span>

                // This could be problematic
                <span class="cov1" title="1">if drsObject.Checksums.SHA256 != "" </span><span class="cov1" title="1">{
                        objects[drsObject.Checksums.SHA256] = &amp;drsObject
                }</span>

                <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Successfully unmarshaled drs.DRSObject from %s:\n%+v", path, drsObject))
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found and unmarshaled %d DRS objects.", len(objects)))
        return objects, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package lfs

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/drs"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/gitrepo"
)

type DrsWalkFunc func(path string, d *drs.DRSObject) error

func BaseDir() (string, error) <span class="cov1" title="1">{
        gitTopLevel, err := gitrepo.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(gitTopLevel, common.DRS_DIR), nil</span>
}

type dirWalker struct {
        baseDir  string
        userFunc DrsWalkFunc
}

func (d *dirWalker) call(path string, dir fs.DirEntry, cErr error) error <span class="cov10" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov6" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">obj := drs.DRSObject{}
        err = sonic.ConfigFastest.Unmarshal(data, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">relPath, err := filepath.Rel(d.baseDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return d.userFunc(relPath, &amp;obj)</span>
}

func ObjectWalk(f DrsWalkFunc) error <span class="cov1" title="1">{
        baseDir, err := BaseDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">ud := dirWalker{baseDir, f}
        return filepath.WalkDir(baseDir, ud.call)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package precommit_cache

import (
        "context"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io/fs"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

const (
        // cacheVersionDir is the repository-relative directory under `.git`
        // containing the pre-commit cache layout (paths and oids).
        cacheVersionDir = "drs/pre-commit/v1"
)

// PathEntry represents the per-path cache file format.
// It maps a repository-relative path to the last recorded LFS OID and
// a timestamp when the entry was updated.
type PathEntry struct {
        Path      string `json:"path"`
        LFSOID    string `json:"lfs_oid"`
        UpdatedAt string `json:"updated_at"`
}

// OIDEntry represents the per-OID cache file format.
// It lists repository paths that referenced the OID, an optional
// non-authoritative external URL hint, a timestamp and a flag that
// indicates whether content changed for a path update.
type OIDEntry struct {
        LFSOID        string   `json:"lfs_oid"`
        Paths         []string `json:"paths"`
        ExternalURL   string   `json:"external_url,omitempty"` // non-authoritative hint
        UpdatedAt     string   `json:"updated_at"`
        ContentChange bool     `json:"content_changed"`
}

// Cache provides read-only access to the `.git/drs/pre-commit` cache.
// Use Open to construct an instance with correct paths resolved.
type Cache struct {
        GitDir    string
        Root      string
        PathsDir  string
        OIDsDir   string
        StatePath string
}

// Open discovers the repository `.git` directory and returns a Cache
// configured to read the repository's pre-commit cache layout.
// Returns an error if git metadata cannot be resolved.
func Open(ctx context.Context) (*Cache, error) <span class="cov8" title="14">{
        gitDir, err := gitRevParseGitDir(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="14">root := filepath.Join(gitDir, cacheVersionDir)
        return &amp;Cache{
                GitDir:    gitDir,
                Root:      root,
                PathsDir:  filepath.Join(root, "paths"),
                OIDsDir:   filepath.Join(root, "oids"),
                StatePath: filepath.Join(root, "state.json"),
        }, nil</span>
}

//
// Primary lookup helpers
//

// LookupOIDByPath returns the cached LFS OID for a repo-relative path.
// It returns (oid, true, nil) when present, (\"\", false, nil) when absent,
// and an error if the underlying read failed.
func (c *Cache) LookupOIDByPath(path string) (string, bool, error) <span class="cov1" title="1">{
        pe, ok, err := c.ReadPathEntry(path)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return "", ok, err
        }</span>
        <span class="cov1" title="1">if pe.LFSOID == "" </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>
        <span class="cov1" title="1">return pe.LFSOID, true, nil</span>
}

// LookupPathsByOID returns advisory repository-relative paths that recently
// referenced the given LFS OID. Paths are returned sorted. Absent OID yields
// (nil, false, nil).
func (c *Cache) LookupPathsByOID(oid string) ([]string, bool, error) <span class="cov0" title="0">{
        oe, ok, err := c.ReadOIDEntry(oid)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return nil, ok, err
        }</span>
        <span class="cov0" title="0">paths := append([]string(nil), oe.Paths...)
        sort.Strings(paths)
        return paths, true, nil</span>
}

// LookupExternalURLByOID returns the cached external URL hint for an OID.
// Returns (\"\", false, nil) if the entry is missing or the hint is empty.
func (c *Cache) LookupExternalURLByOID(oid string) (string, bool, error) <span class="cov6" title="8">{
        oe, ok, err := c.ReadOIDEntry(oid)
        if err != nil || !ok </span><span class="cov5" title="6">{
                return "", ok, err
        }</span>
        <span class="cov2" title="2">u := strings.TrimSpace(oe.ExternalURL)
        if u == "" </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>
        <span class="cov2" title="2">return u, true, nil</span>
}

// ResolveExternalURLByPath resolves a path -&gt; oid -&gt; external_url (hint).
// Returns the external URL hint when available. Missing data yields
// (\"\", false, nil).
func (c *Cache) ResolveExternalURLByPath(path string) (string, bool, error) <span class="cov1" title="1">{
        oid, ok, err := c.LookupOIDByPath(path)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return "", false, err
        }</span>
        <span class="cov1" title="1">return c.LookupExternalURLByOID(oid)</span>
}

//
// Lower-level file access
//

// ReadPathEntry reads and parses the JSON path entry for a repository-relative
// path. Returns (entry, true, nil) on success, (nil, false, nil) if the file
// does not exist, or an error on I/O/parse failure.
func (c *Cache) ReadPathEntry(path string) (*PathEntry, bool, error) <span class="cov6" title="7">{
        f := c.pathEntryFile(path)
        b, err := os.ReadFile(f)
        if err != nil </span><span class="cov4" title="4">{
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov4" title="4">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("read path entry %q: %w", f, err)</span>
        }
        <span class="cov3" title="3">var pe PathEntry
        if err := json.Unmarshal(b, &amp;pe); err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("parse path entry %q: %w", f, err)
        }</span>
        <span class="cov3" title="3">return &amp;pe, true, nil</span>
}

// ReadOIDEntry reads and parses the JSON OID entry for an LFS OID string.
// Returns (entry, true, nil) on success, (nil, false, nil) if missing,
// or an error on I/O/parse failure.
func (c *Cache) ReadOIDEntry(oid string) (*OIDEntry, bool, error) <span class="cov6" title="8">{
        f := c.oidEntryFile(oid)
        b, err := os.ReadFile(f)
        if err != nil </span><span class="cov5" title="6">{
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov5" title="6">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("read oid entry %q: %w", f, err)</span>
        }
        <span class="cov2" title="2">var oe OIDEntry
        if err := json.Unmarshal(b, &amp;oe); err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("parse oid entry %q: %w", f, err)
        }</span>
        <span class="cov2" title="2">return &amp;oe, true, nil</span>
}

//
// Validation helpers (optional)
//

// CheckExternalURLMismatch compares a cached external URL hint against an
// authoritative URL. If either value is empty this is a no-op. When both are
// non-empty and differ an error describing the mismatch is returned.
func CheckExternalURLMismatch(localHint, authoritative string) error <span class="cov3" title="3">{
        l := strings.TrimSpace(localHint)
        a := strings.TrimSpace(authoritative)
        if l == "" || a == "" </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="2">if l != a </span><span class="cov1" title="1">{
                return fmt.Errorf(
                        "external URL mismatch: cache=%q authoritative=%q",
                        l, a,
                )
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// StaleAfter reports whether a JSON entry with the given updatedAt RFC3339
// timestamp is older than maxAge. Returns false if the timestamp cannot be parsed.
func StaleAfter(updatedAt string, maxAge time.Duration) bool <span class="cov4" title="4">{
        t, err := time.Parse(time.RFC3339, updatedAt)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov3" title="3">return time.Since(t) &gt; maxAge</span>
}

//
// Filename / encoding helpers
//

// pathEntryFile returns the filesystem path to the JSON file for the given
// repository-relative path within the Cache.PathsDir.
func (c *Cache) pathEntryFile(path string) string <span class="cov6" title="8">{
        return filepath.Join(c.PathsDir, EncodePath(path)+".json")
}</span>

// oidEntryFile returns the filesystem path to the JSON file for the given
// LFS OID. Files are named by sha256(oid) to avoid filesystem restrictions.
func (c *Cache) oidEntryFile(oid string) string <span class="cov7" title="10">{
        sum := sha256.Sum256([]byte(oid))
        return filepath.Join(c.OIDsDir, fmt.Sprintf("%x.json", sum[:]))
}</span>

// EncodePath returns a filesystem-safe base64 raw-URL encoding for a path.
// The encoding is reversible by DecodePath.
func EncodePath(path string) string <span class="cov8" title="19">{
        return base64.RawURLEncoding.EncodeToString([]byte(path))
}</span>

// DecodePath decodes a value produced by EncodePath back to the original path.
// Returns an error if the input is not valid base64 raw-URL.
func DecodePath(encoded string) (string, error) <span class="cov1" title="1">{
        b, err := base64.RawURLEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return string(b), nil</span>
}

//
// Git helpers
//

// gitRevParseGitDir runs `git rev-parse --git-dir` (and `--show-toplevel` if
// necessary) to return an absolute path to the repository `.git` directory.
// Returns an error when git fails or the result cannot be resolved.
func gitRevParseGitDir(ctx context.Context) (string, error) <span class="cov8" title="14">{
        out, err := git(ctx, "rev-parse", "--git-dir")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="14">gitDir := strings.TrimSpace(string(out))
        if gitDir == "" </span><span class="cov0" title="0">{
                return "", errors.New("could not determine .git dir")
        }</span>
        <span class="cov8" title="14">if !filepath.IsAbs(gitDir) </span><span class="cov8" title="14">{
                rootOut, err := git(ctx, "rev-parse", "--show-toplevel")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="14">root := strings.TrimSpace(string(rootOut))
                gitDir = filepath.Join(root, gitDir)</span>
        }
        <span class="cov8" title="14">return gitDir, nil</span>
}

// git executes a git command and returns combined output. If git exits with
// a non-zero status the returned error includes the command and stderr/stdout.
func git(ctx context.Context, args ...string) ([]byte, error) <span class="cov10" title="28">{
        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Env = os.Environ()
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "git %s: %s",
                        strings.Join(args, " "),
                        strings.TrimSpace(string(out)),
                )
        }</span>
        <span class="cov10" title="28">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Creates directories from stdin lines, each with 16 `sub-directory-N` subfolders, each containing 1001000 files of 1 KiB whose contents are the relative file path. Save as `generate-fixtures.go`.

package main

import (
        "bufio"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

const (
        minSubDirs = 1
        maxSubDirs = 6

        minFilesPerSub = 100
        maxFilesPerSub = 1000

        fileSizeBytes = 1024
)

// main reads directory names from stdin (one per line) and creates a set of
// "fixture" directories and files for each input name. For each top-level
// directory it creates between minSubDirs and maxSubDirs subdirectories
// named "sub-directory-N". Each subdirectory receives between minFilesPerSub
// and maxFilesPerSub files. File contents are written as the relative path
// bytes. The program prints progress and errors to stderr and exits with a
// non-zero code on read errors or when no input is provided.
func main() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())

        // Flags: if &gt;0 they override randomness
        numSubdirsFlag := flag.Int("number-of-subdirectories", 0, "fixed number of subdirectories per top-level directory (overrides random)")
        numFilesFlag := flag.Int("number-of-files", 0, "fixed number of files per subdirectory (overrides random)")
        flag.Parse()

        scanner := bufio.NewScanner(os.Stdin)
        entries := []string{}
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">entries = append(entries, line)</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "reading stdin: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "no input lines; provide one directory name per line on stdin")
                os.Exit(1)
        }</span>

        // Determine digits for file name padding based on configured or default max
        <span class="cov0" title="0">maxFilesConsidered := maxFilesPerSub
        if *numFilesFlag &gt; 0 &amp;&amp; *numFilesFlag &gt; maxFilesConsidered </span><span class="cov0" title="0">{
                maxFilesConsidered = *numFilesFlag
        }</span>
        <span class="cov0" title="0">maxFilesDigits := len(strconv.Itoa(maxFilesConsidered))

        for _, name := range entries </span><span class="cov0" title="0">{
                // Clean the path and disallow absolute paths for safety
                clean := filepath.Clean(name)
                if filepath.IsAbs(clean) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping absolute path: %s\n", name)
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(clean, ".."+string(os.PathSeparator)) || clean == ".." </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping path outside current tree: %s\n", name)
                        continue</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(clean, 0o755); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", clean, err)
                        continue</span>
                }

                // Choose number of subdirectories
                <span class="cov0" title="0">var nSub int
                if *numSubdirsFlag &gt; 0 </span><span class="cov0" title="0">{
                        if *numSubdirsFlag &lt; 1 </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "invalid --number-of-subdirectories: %d (must be &gt;= 1)\n", *numSubdirsFlag)
                                continue</span>
                        }
                        <span class="cov0" title="0">nSub = *numSubdirsFlag</span>
                } else<span class="cov0" title="0"> {
                        nSub = rand.Intn(maxSubDirs-minSubDirs+1) + minSubDirs
                }</span>

                <span class="cov0" title="0">for si := 1; si &lt;= nSub; si++ </span><span class="cov0" title="0">{
                        subdir := filepath.Join(clean, fmt.Sprintf("sub-directory-%d", si))
                        if err := os.MkdirAll(subdir, 0o755); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", subdir, err)
                                continue</span>
                        }

                        // Choose number of files per subdirectory
                        <span class="cov0" title="0">var nFiles int
                        if *numFilesFlag &gt; 0 </span><span class="cov0" title="0">{
                                if *numFilesFlag &lt; 1 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "invalid --number-of-files: %d (must be &gt;= 1)\n", *numFilesFlag)
                                        continue</span>
                                }
                                <span class="cov0" title="0">nFiles = *numFilesFlag</span>
                        } else<span class="cov0" title="0"> {
                                nFiles = rand.Intn(maxFilesPerSub-minFilesPerSub+1) + minFilesPerSub
                        }</span>

                        <span class="cov0" title="0">largeFileNumberOfLines := 480008 // approx 20 MiB
                        for fi := 1; fi &lt;= nFiles; fi++ </span><span class="cov0" title="0">{
                                filename := fmt.Sprintf("file-%0*d.dat", maxFilesDigits, fi)
                                path := filepath.Join(subdir, filename)
                                // if fi is odd just write the path; if even, write the path LARGE_FILE_NUMBER_OF_LINES
                                // if fi is odd just write the path; if even, write the path LARGE_FILE_NUMBER_OF_LINES
                                var content []byte
                                if fi%2 == 1 </span><span class="cov0" title="0">{
                                        content = []byte(path)
                                }</span> else<span class="cov0" title="0"> {
                                        var b strings.Builder
                                        // Pre-allocate roughly to avoid too many allocations (estimate)
                                        b.Grow(len(path)*largeFileNumberOfLines + largeFileNumberOfLines)
                                        for i := 0; i &lt; largeFileNumberOfLines; i++ </span><span class="cov0" title="0">{
                                                b.WriteString(path)
                                                b.WriteByte('\n')
                                        }</span>
                                        <span class="cov0" title="0">content = []byte(b.String())</span>
                                }
                                <span class="cov0" title="0">if err := os.WriteFile(path, content, 0o644); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "write %s: %v\n", path, err)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "created %d files in %s\n", nFiles, subdir)</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "done: %s (%d subdirs)\n", clean, nSub)</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Package version reports the Git-DRS version.
package version

import "fmt"

// Build and version details
var (
        GitCommit   = ""
        GitBranch   = ""
        GitUpstream = ""
        BuildDate   = ""
        Version     = ""
)

var tpl = `git commit: %s
git branch: %s
git upstream: %s
build date: %s
version: %s`

// String formats a string with version details.
func String() string <span class="cov8" title="1">{
        return fmt.Sprintf(tpl, GitCommit, GitBranch, GitUpstream, BuildDate, Version)
}</span>

// LogFields logs build and version information to the given logger.
func LogFields() []any <span class="cov8" title="1">{
        return []any{
                "GitCommit", GitCommit,
                "GitBranch", GitBranch,
                "GitUpstream", GitUpstream,
                "BuildDate", BuildDate,
                "Version", Version,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
