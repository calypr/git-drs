
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anvil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/calypr/git-drs/client/anvil/anvil_client.go (0.0%)</option>
				
				<option value="file1">github.com/calypr/git-drs/client/anvil/remote.go (100.0%)</option>
				
				<option value="file2">github.com/calypr/git-drs/client/indexd/add_url.go (0.0%)</option>
				
				<option value="file3">github.com/calypr/git-drs/client/indexd/client.go (56.8%)</option>
				
				<option value="file4">github.com/calypr/git-drs/client/indexd/gen3_remote.go (90.9%)</option>
				
				<option value="file5">github.com/calypr/git-drs/client/indexd/register.go (79.3%)</option>
				
				<option value="file6">github.com/calypr/git-drs/client/tests/mock_types.go (0.0%)</option>
				
				<option value="file7">github.com/calypr/git-drs/cmd/addref/add-ref.go (36.2%)</option>
				
				<option value="file8">github.com/calypr/git-drs/cmd/addurl/main.go (20.0%)</option>
				
				<option value="file9">github.com/calypr/git-drs/cmd/cache/create-cache.go (76.7%)</option>
				
				<option value="file10">github.com/calypr/git-drs/cmd/delete/main.go (24.4%)</option>
				
				<option value="file11">github.com/calypr/git-drs/cmd/deleteproject/main.go (4.3%)</option>
				
				<option value="file12">github.com/calypr/git-drs/cmd/download/main.go (5.4%)</option>
				
				<option value="file13">github.com/calypr/git-drs/cmd/fetch/main.go (78.3%)</option>
				
				<option value="file14">github.com/calypr/git-drs/cmd/initialize/main.go (78.6%)</option>
				
				<option value="file15">github.com/calypr/git-drs/cmd/list/main.go (39.6%)</option>
				
				<option value="file16">github.com/calypr/git-drs/cmd/listconfig/main.go (75.0%)</option>
				
				<option value="file17">github.com/calypr/git-drs/cmd/prepush/main.go (70.9%)</option>
				
				<option value="file18">github.com/calypr/git-drs/cmd/push/main.go (48.1%)</option>
				
				<option value="file19">github.com/calypr/git-drs/cmd/query/main.go (37.5%)</option>
				
				<option value="file20">github.com/calypr/git-drs/cmd/register/main.go (20.6%)</option>
				
				<option value="file21">github.com/calypr/git-drs/cmd/remote/add/anvil.go (0.0%)</option>
				
				<option value="file22">github.com/calypr/git-drs/cmd/remote/add/gen3.go (57.6%)</option>
				
				<option value="file23">github.com/calypr/git-drs/cmd/remote/add/init.go (100.0%)</option>
				
				<option value="file24">github.com/calypr/git-drs/cmd/remote/list.go (78.6%)</option>
				
				<option value="file25">github.com/calypr/git-drs/cmd/remote/root.go (100.0%)</option>
				
				<option value="file26">github.com/calypr/git-drs/cmd/remote/set.go (20.0%)</option>
				
				<option value="file27">github.com/calypr/git-drs/cmd/root.go (100.0%)</option>
				
				<option value="file28">github.com/calypr/git-drs/cmd/transfer/main.go (54.4%)</option>
				
				<option value="file29">github.com/calypr/git-drs/cmd/transferref/main.go (22.3%)</option>
				
				<option value="file30">github.com/calypr/git-drs/cmd/version/main.go (57.9%)</option>
				
				<option value="file31">github.com/calypr/git-drs/common/common.go (100.0%)</option>
				
				<option value="file32">github.com/calypr/git-drs/common/confirmation.go (93.3%)</option>
				
				<option value="file33">github.com/calypr/git-drs/config/config.go (67.0%)</option>
				
				<option value="file34">github.com/calypr/git-drs/drslog/logger.go (75.2%)</option>
				
				<option value="file35">github.com/calypr/git-drs/drsmap/drs_map.go (57.2%)</option>
				
				<option value="file36">github.com/calypr/git-drs/git-drs.go (42.9%)</option>
				
				<option value="file37">github.com/calypr/git-drs/gitrepo/repo.go (83.1%)</option>
				
				<option value="file38">github.com/calypr/git-drs/internal/testutils/config.go (95.2%)</option>
				
				<option value="file39">github.com/calypr/git-drs/internal/testutils/output.go (100.0%)</option>
				
				<option value="file40">github.com/calypr/git-drs/internal/testutils/test_helpers.go (100.0%)</option>
				
				<option value="file41">github.com/calypr/git-drs/lfs/lfs-track.go (88.4%)</option>
				
				<option value="file42">github.com/calypr/git-drs/lfs/messages.go (100.0%)</option>
				
				<option value="file43">github.com/calypr/git-drs/lfs/store.go (78.9%)</option>
				
				<option value="file44">github.com/calypr/git-drs/lfs/util.go (80.0%)</option>
				
				<option value="file45">github.com/calypr/git-drs/s3_utils/s3.go (100.0%)</option>
				
				<option value="file46">github.com/calypr/git-drs/s3_utils/validate.go (100.0%)</option>
				
				<option value="file47">github.com/calypr/git-drs/tests/monorepos/generate-fixtures.go (0.0%)</option>
				
				<option value="file48">github.com/calypr/git-drs/utils/util.go (94.6%)</option>
				
				<option value="file49">github.com/calypr/git-drs/version/version.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anvil_client

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/bytedance/sonic"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "golang.org/x/oauth2/google"
)

type AnvilClient struct {
        Endpoint string
        SConfig  sonic.API
}

func (an *AnvilClient) GetObject(ctx context.Context, objectID string) (*drs.DRSObject, error) <span class="cov0" title="0">{
        // get auth token
        token, err := GetAuthToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auth token: %w", err)
        }</span>

        <span class="cov0" title="0">reqBody := map[string]any{
                "url":    objectID,
                "fields": []string{"hashes", "size", "fileName"},
        }
        bodyBytes, err := an.SConfig.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", an.Endpoint, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, _ := io.ReadAll(resp.Body)
        if resp.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                // Try to extract error message
                var errResp map[string]any
                an.SConfig.Unmarshal(respBody, &amp;errResp)
                msg := fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(respBody))
                if m, ok := errResp["message"].(string); ok </span><span class="cov0" title="0">{
                        msg = m
                }</span>
                <span class="cov0" title="0">return &amp;drs.DRSObject{}, errors.New(msg)</span>
        }

        // Parse expected response
        // subset of ResourceMetadata
        // https://github.com/DataBiosphere/terra-drs-hub/blob/dev/common/openapi.yml#L123
        <span class="cov0" title="0">var parsed struct {
                Hashes   map[string]string `json:"hashes"`
                Size     int64             `json:"size"`
                FileName string            `json:"fileName"`
        }
        if err := an.SConfig.Unmarshal(respBody, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.DRSObject{
                SelfURI:   objectID,
                Id:        objectID,
                Checksums: hash.ConvertStringMapToHashInfo(parsed.Hashes),
                Size:      parsed.Size,
                Name:      parsed.FileName,
        }, nil</span>
}

// GetAuthToken fetches a Google Cloud authentication token using Application Default Credentials.
// The user must run `gcloud auth application-default login` before using this.
func GetAuthToken() (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        creds, err := google.FindDefaultCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">ts := creds.TokenSource
        token, err := ts.Token()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid() || token.AccessToken == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no token retrieved")
        }</span>

        <span class="cov0" title="0">return token.AccessToken, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package anvil_client

import (
        "fmt"
        "log/slog"

        "github.com/calypr/data-client/g3client"
        "github.com/calypr/git-drs/client"
)

// AnvilAuth holds authentication info for Anvil
type AnvilAuth struct {
        TerraProject string `yaml:"terra_project"`
}

// AnvilRemote holds Anvil remote config
type AnvilRemote struct {
        Endpoint string    `yaml:"endpoint"`
        Auth     AnvilAuth `yaml:",inline"`
}

func (s AnvilRemote) GetProjectId() string <span class="cov8" title="1">{
        return s.Auth.TerraProject
}</span>

func (s AnvilRemote) GetEndpoint() string <span class="cov8" title="1">{
        return s.Endpoint
}</span>

func (s AnvilRemote) GetBucketName() string <span class="cov8" title="1">{
        return ""
}</span>

func (s AnvilRemote) GetClient(remoteName string, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov8" title="1">{
        return nil, fmt.Errorf(("AnVIL Client needs to be implemented"))
        // return NewAnvilClient(s, logger)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package indexd

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "slices"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/calypr/data-client/fence"
        "github.com/calypr/data-client/indexd"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/messages"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
)

// getBucketDetails fetches bucket details from Gen3 using data-client.
func (inc *GitDrsIdxdClient) getBucketDetails(ctx context.Context, bucket string, httpClient *http.Client) (*fence.S3Bucket, error) <span class="cov0" title="0">{
        return inc.G3.Fence().GetBucketDetails(ctx, bucket)
}</span>

// FetchS3MetadataWithBucketDetails fetches S3 metadata given bucket details.
func FetchS3MetadataWithBucketDetails(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, bucketDetails *fence.S3Bucket, s3Client *s3.Client, logger *slog.Logger) (int64, string, error) <span class="cov0" title="0">{
        bucket, key, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">if s3Client == nil </span><span class="cov0" title="0">{
                cfg, err := awsConfig.LoadDefaultConfig(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", fmt.Errorf("unable to load base AWS SDK config: %v. %s", err, messages.ADDURL_HELP_MSG)
                }</span>

                <span class="cov0" title="0">var configOptions []func(*awsConfig.LoadOptions) error
                if awsAccessKey != "" &amp;&amp; awsSecretKey != "" </span><span class="cov0" title="0">{
                        configOptions = append(configOptions,
                                awsConfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(awsAccessKey, awsSecretKey, "")),
                        )
                }</span>

                <span class="cov0" title="0">regionToUse := ""
                if region != "" </span><span class="cov0" title="0">{
                        regionToUse = region
                }</span> else<span class="cov0" title="0"> if bucketDetails != nil &amp;&amp; bucketDetails.Region != "" </span><span class="cov0" title="0">{
                        regionToUse = bucketDetails.Region
                }</span>
                <span class="cov0" title="0">if regionToUse != "" </span><span class="cov0" title="0">{
                        configOptions = append(configOptions, awsConfig.WithRegion(regionToUse))
                }</span>

                <span class="cov0" title="0">if len(configOptions) &gt; 0 </span><span class="cov0" title="0">{
                        cfg, err = awsConfig.LoadDefaultConfig(ctx, configOptions...)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, "", fmt.Errorf("unable to load AWS SDK config with overrides: %v. %s", err, messages.ADDURL_HELP_MSG)
                        }</span>
                }

                <span class="cov0" title="0">endpointToUse := ""
                if endpoint != "" </span><span class="cov0" title="0">{
                        endpointToUse = endpoint
                }</span> else<span class="cov0" title="0"> if bucketDetails != nil &amp;&amp; bucketDetails.EndpointURL != "" </span><span class="cov0" title="0">{
                        endpointToUse = bucketDetails.EndpointURL
                }</span>

                <span class="cov0" title="0">s3Client = s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov0" title="0">{
                        if endpointToUse != "" </span><span class="cov0" title="0">{
                                o.BaseEndpoint = aws.String(endpointToUse)
                        }</span>
                        <span class="cov0" title="0">o.UsePathStyle = true</span>
                })
        }

        <span class="cov0" title="0">input := &amp;s3.HeadObjectInput{
                Bucket: &amp;bucket,
                Key:    aws.String(key),
        }

        resp, err := s3Client.HeadObject(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to head object, %v", err)
        }</span>

        <span class="cov0" title="0">var contentLength int64
        if resp.ContentLength != nil </span><span class="cov0" title="0">{
                contentLength = *resp.ContentLength
        }</span>

        <span class="cov0" title="0">return contentLength, resp.LastModified.Format(time.RFC3339), nil</span>
}

func (inc *GitDrsIdxdClient) fetchS3Metadata(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, s3Client *s3.Client, httpClient *http.Client, logger *slog.Logger) (int64, string, error) <span class="cov0" title="0">{
        bucket, _, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">bucketDetails, err := inc.getBucketDetails(ctx, bucket, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("Warning: unable to get bucket details from Gen3: %v", err))
        }</span>

        <span class="cov0" title="0">return FetchS3MetadataWithBucketDetails(ctx, s3URL, awsAccessKey, awsSecretKey, region, endpoint, bucketDetails, s3Client, logger)</span>
}

func (inc *GitDrsIdxdClient) upsertIndexdRecord(ctx context.Context, url string, sha256 string, fileSize int64, logger *slog.Logger) (*drs.DRSObject, error) <span class="cov0" title="0">{
        projectId := inc.GetProjectId()
        uuid := drsmap.DrsUUID(projectId, sha256)

        records, err := inc.GetObjectByHash(ctx, &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: sha256})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying indexd server: %v", err)
        }</span>

        <span class="cov0" title="0">var matchingRecord *drs.DRSObject
        for i := range records </span><span class="cov0" title="0">{
                if records[i].Id == uuid </span><span class="cov0" title="0">{
                        matchingRecord = &amp;records[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if matchingRecord != nil </span><span class="cov0" title="0">{
                existingURLs := indexd.IndexdURLFromDrsAccessURLs(matchingRecord.AccessMethods)
                if slices.Contains(existingURLs, url) </span><span class="cov0" title="0">{
                        logger.Debug("Nothing to do: file already registered")
                        return matchingRecord, nil
                }</span>

                <span class="cov0" title="0">logger.Debug("updating existing record with new url")
                updatedRecord := drs.DRSObject{AccessMethods: []drs.AccessMethod{{AccessURL: drs.AccessURL{URL: url}}}}
                return inc.UpdateRecord(ctx, &amp;updatedRecord, matchingRecord.Id)</span>
        }

        // If no record exists, create one
        <span class="cov0" title="0">logger.Debug("creating new record")
        _, relPath, _ := utils.ParseS3URL(url)

        drsObj, err := drs.BuildDrsObj(relPath, sha256, fileSize, uuid, inc.Config.BucketName, projectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add authz explicitly since BuildDrsObj might not set it exactly as needed for all cases
        // Actually BuildDrsObj does set authz.
        <span class="cov0" title="0">return inc.RegisterRecord(ctx, drsObj)</span>
}

func (inc *GitDrsIdxdClient) AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, regionFlag, endpointFlag string, opts ...s3_utils.AddURLOption) (s3_utils.S3Meta, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cfg := &amp;s3_utils.AddURLConfig{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        <span class="cov0" title="0">if inc.Logger == nil </span><span class="cov0" title="0">{
                inc.Logger = drslog.NewNoOpLogger()
        }</span>

        <span class="cov0" title="0">if err := s3_utils.ValidateInputs(s3URL, sha256); err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, err
        }</span>

        <span class="cov0" title="0">_, relPath, err := utils.ParseS3URL(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        <span class="cov0" title="0">isLFS, err := lfs.IsLFSTracked(".gitattributes", relPath)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("unable to determine if file is tracked by LFS: %w", err)
        }</span>
        <span class="cov0" title="0">if !isLFS </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("file is not tracked by LFS")
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug("Fetching S3 metadata...")
        fileSize, modifiedDate, err := inc.fetchS3Metadata(ctx, s3URL, awsAccessKey, awsSecretKey, regionFlag, endpointFlag, cfg.S3Client, cfg.HttpClient, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w", err)
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug(fmt.Sprintf("Fetched S3 metadata successfully: %d bytes, modified: %s", fileSize, modifiedDate))

        inc.Logger.Debug("Processing indexd record...")
        drsObj, err := inc.upsertIndexdRecord(ctx, s3URL, sha256, fileSize, inc.Logger)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, fmt.Errorf("failed to create indexd record: %w", err)
        }</span>

        <span class="cov0" title="0">drsObjPath, err := drsmap.GetObjectPath(common.DRS_OBJS_PATH, drsObj.Checksums.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, err
        }</span>
        <span class="cov0" title="0">if err := drsmap.WriteDrsObj(drsObj, sha256, drsObjPath); err != nil </span><span class="cov0" title="0">{
                return s3_utils.S3Meta{}, err
        }</span>

        <span class="cov0" title="0">inc.Logger.Debug("Indexd updated")

        return s3_utils.S3Meta{
                Size:         fileSize,
                LastModified: modifiedDate,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package indexd

import (
        "context"
        "fmt"
        "log/slog"
        "net/url"

        "github.com/calypr/data-client/common"
        "github.com/calypr/data-client/conf"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/gitrepo"
)

// Config holds configuration parameters for the GitDrsIdxdClient.
type Config struct {
        ProjectId          string
        BucketName         string
        Upsert             bool
        MultiPartThreshold int64
}

type GitDrsIdxdClient struct {
        Base   *url.URL
        Logger *slog.Logger
        G3     g3client.Gen3Interface
        Config *Config
}

func NewGitDrsIdxdClient(profileConfig conf.Credential, remote Gen3Remote, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov10" title="42">{
        baseUrl, err := url.Parse(profileConfig.APIEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="42">projectId := remote.GetProjectId()
        if projectId == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no gen3 project specified")
        }</span>

        <span class="cov9" title="41">bucketName := remote.GetBucketName()

        // Initialize data-client Gen3Interface with slog-adapted logger if needed,
        // or assume we use the one passed in if we update data-client to take slog.
        // For now we assume data-client/logs/TeeLogger is still used by data-client internals,
        // so we bridge it.
        // Initialize data-client Gen3Interface with slog-adapted logger.
        // We disable data-client's console output because drslog already handles stderr/file logging.
        // We also disable data-client's separate message file by default to aggregate logs in git-drs.log,
        // but allow re-enabling it via config.
        // but allow re-enabling it via config.
        enableDataClientLogs := gitrepo.GetGitConfigBool("lfs.customtransfer.drs.enable-data-client-logs", false)

        logOpts := []logs.Option{
                logs.WithBaseLogger(logger),
                logs.WithNoConsole(), // drslog already writes to stderr if configured
        }

        if enableDataClientLogs </span><span class="cov0" title="0">{
                logOpts = append(logOpts, logs.WithMessageFile())
        }</span> else<span class="cov9" title="41"> {
                logOpts = append(logOpts, logs.WithNoMessageFile())
        }</span>

        <span class="cov9" title="41">dLogger, closer := logs.New(profileConfig.Profile, logOpts...)
        _ = closer

        // If no options provided, use defaults for GitDrsIdxdClient
        if len(opts) == 0 </span><span class="cov9" title="41">{
                opts = append(opts, g3client.WithClients(g3client.IndexdClient, g3client.FenceClient, g3client.SowerClient))
        }</span>
        <span class="cov9" title="41">g3 := g3client.NewGen3InterfaceFromCredential(&amp;profileConfig, dLogger, opts...)

        upsert := gitrepo.GetGitConfigBool("lfs.customtransfer.drs.upsert", false)
        multiPartThresholdInt := gitrepo.GetGitConfigInt("lfs.customtransfer.drs.multipart-threshold", 500)
        var multiPartThreshold int64 = multiPartThresholdInt * common.MB

        config := &amp;Config{
                ProjectId:          projectId,
                BucketName:         bucketName,
                Upsert:             upsert,
                MultiPartThreshold: multiPartThreshold,
        }

        return &amp;GitDrsIdxdClient{
                Base:   baseUrl,
                Logger: logger,
                G3:     g3,
                Config: config,
        }, nil</span>
}

func (cl *GitDrsIdxdClient) GetProjectId() string <span class="cov6" title="9">{
        return cl.Config.ProjectId
}</span>

func (cl *GitDrsIdxdClient) GetObject(ctx context.Context, id string) (*drs.DRSObject, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().GetObject(ctx, id)
}</span>

func (cl *GitDrsIdxdClient) ListObjects(ctx context.Context) (chan drs.DRSObjectResult, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().ListObjects(ctx)
}</span>

func (cl *GitDrsIdxdClient) ListObjectsByProject(ctx context.Context, projectId string) (chan drs.DRSObjectResult, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().ListObjectsByProject(ctx, projectId)
}</span>

func (cl *GitDrsIdxdClient) GetDownloadURL(ctx context.Context, oid string) (*drs.AccessURL, error) <span class="cov0" title="0">{
        cl.Logger.Debug(fmt.Sprintf("Try to get download url for file OID %s", oid))

        // get the DRS object using the OID
        records, err := cl.GetObjectByHash(ctx, &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error getting DRS object for OID %s: %s", oid, err))
                return nil, fmt.Errorf("error getting DRS object for OID %s: %v", oid, err)
        }</span>
        <span class="cov0" title="0">return cl.getDownloadURLFromRecords(ctx, oid, records)</span>
}

func (cl *GitDrsIdxdClient) getDownloadURLFromRecords(ctx context.Context, oid string, records []drs.DRSObject) (*drs.AccessURL, error) <span class="cov0" title="0">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no DRS object found for OID %s", oid))
                return nil, fmt.Errorf("no DRS object found for OID %s", oid)
        }</span>

        // Find a record that matches the client's project ID
        <span class="cov0" title="0">matchingRecord, err := drsmap.FindMatchingRecord(records, cl.Config.ProjectId)
        if err != nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("error finding matching record for project %s: %s", cl.Config.ProjectId, err))
                return nil, fmt.Errorf("error finding matching record for project %s: %v", cl.Config.ProjectId, err)
        }</span>
        <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no matching record found for project %s", cl.Config.ProjectId))
                return nil, fmt.Errorf("no matching record found for project %s", cl.Config.ProjectId)
        }</span>

        <span class="cov0" title="0">cl.Logger.Debug(fmt.Sprintf("Matching record: %#v for oid %s", matchingRecord, oid))
        drsObj := matchingRecord

        // Check if access methods exist
        if len(drsObj.AccessMethods) == 0 </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no access methods available for DRS object %s", drsObj.Id))
                return nil, fmt.Errorf("no access methods available for DRS object %s", drsObj.Id)
        }</span>

        // naively get access ID from splitting first path into :
        <span class="cov0" title="0">accessType := drsObj.AccessMethods[0].Type
        if accessType == "" </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0]))
                return nil, fmt.Errorf("no accessType found in access method for DRS object %v", drsObj.AccessMethods[0])
        }</span>
        <span class="cov0" title="0">did := drsObj.Id

        accessUrl, err := cl.G3.Indexd().GetDownloadURL(ctx, did, accessType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.AccessURL{URL: accessUrl.URL, Headers: accessUrl.Headers}, nil</span>
}

func (cl *GitDrsIdxdClient) GetObjectByHash(ctx context.Context, sum *hash.Checksum) ([]drs.DRSObject, error) <span class="cov4" title="5">{
        res, err := cl.G3.Indexd().GetObjectByHash(ctx, string(sum.Type), sum.Checksum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by project ID logic is git-drs specific business logic (ensure we only see our project's files)
        <span class="cov4" title="5">resourcePath, err := common.ProjectToResource(cl.Config.ProjectId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">filtered := make([]drs.DRSObject, 0)
        for _, o := range res </span><span class="cov4" title="5">{
                found := false
                for _, am := range o.AccessMethods </span><span class="cov4" title="5">{
                        if am.Authorizations != nil &amp;&amp; am.Authorizations.Value == resourcePath </span><span class="cov4" title="5">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov4" title="5">if found </span><span class="cov4" title="5">{
                        filtered = append(filtered, o)
                }</span>
        }
        <span class="cov4" title="5">return filtered, nil</span>
}

func (cl *GitDrsIdxdClient) DeleteRecordsByProject(ctx context.Context, projectId string) error <span class="cov0" title="0">{
        return cl.G3.Indexd().DeleteRecordsByProject(ctx, projectId)
}</span>

func (cl *GitDrsIdxdClient) DeleteRecord(ctx context.Context, oid string) error <span class="cov2" title="2">{
        return cl.G3.Indexd().DeleteRecordByHash(ctx, oid, cl.Config.ProjectId)
}</span>

func (cl *GitDrsIdxdClient) GetProjectSample(ctx context.Context, projectId string, limit int) ([]drs.DRSObject, error) <span class="cov1" title="1">{
        return cl.G3.Indexd().GetProjectSample(ctx, projectId, limit)
}</span>

func (c *GitDrsIdxdClient) RegisterRecord(ctx context.Context, record *drs.DRSObject) (*drs.DRSObject, error) <span class="cov5" title="7">{
        return c.G3.Indexd().RegisterRecord(ctx, record)
}</span>

func (c *GitDrsIdxdClient) UpdateRecord(ctx context.Context, updateInfo *drs.DRSObject, did string) (*drs.DRSObject, error) <span class="cov1" title="1">{
        return c.G3.Indexd().UpdateRecord(ctx, updateInfo, did)
}</span>

func (c *GitDrsIdxdClient) BuildDrsObj(fileName string, checksum string, size int64, drsId string) (*drs.DRSObject, error) <span class="cov4" title="4">{
        return drs.BuildDrsObj(fileName, checksum, size, drsId, c.Config.BucketName, c.Config.ProjectId)
}</span>

func (cl *GitDrsIdxdClient) GetGen3Interface() g3client.Gen3Interface <span class="cov4" title="4">{
        return cl.G3
}</span>

func (cl *GitDrsIdxdClient) GetBucketName() string <span class="cov1" title="1">{
        return cl.Config.BucketName
}</span>

func (cl *GitDrsIdxdClient) GetUpsert() bool <span class="cov1" title="1">{
        return cl.Config.Upsert
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package indexd

import (
        "context"
        "log/slog"

        "github.com/calypr/data-client/conf"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client"
)

// Gen3Server holds Gen3 server config
type Gen3Remote struct {
        Endpoint  string `yaml:"endpoint"`
        ProjectID string `yaml:"project_id"`
        Bucket    string `yaml:"bucket"`
}

func (s Gen3Remote) GetProjectId() string <span class="cov10" title="43">{
        return s.ProjectID
}</span>

func (s Gen3Remote) GetEndpoint() string <span class="cov2" title="2">{
        return s.Endpoint
}</span>

func (s Gen3Remote) GetBucketName() string <span class="cov9" title="42">{
        return s.Bucket
}</span>

func (s Gen3Remote) GetClient(remoteName string, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov9" title="41">{
        manager := conf.NewConfigure(logger)
        cred, err := manager.Load(remoteName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="40">gen3Logger := logs.NewGen3Logger(logger, "", remoteName)
        if err := g3client.EnsureValidCredential(context.Background(), cred, manager, gen3Logger, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="40">return NewGitDrsIdxdClient(*cred, s, logger, opts...)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package indexd

import (
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/calypr/data-client/common"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/upload"
        "github.com/calypr/git-drs/drsmap"
)

// RegisterFile implements DRSClient.RegisterFile
// It registers (or reuses) an indexd record for the oid, uploads the object if it
// is not already available in the bucket, and returns the resulting DRS object.
func (cl *GitDrsIdxdClient) RegisterFile(ctx context.Context, oid string, path string) (*drs.DRSObject, error) <span class="cov10" title="4">{
        cl.Logger.DebugContext(ctx, fmt.Sprintf("register file started for oid: %s", oid))

        // load the DRS object from oid created by prepush
        drsObject, err := drsmap.DrsInfoFromOid(oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting drs object for oid %s: %v", oid, err)
        }</span>

        <span class="cov10" title="4">cl.Logger.InfoContext(ctx, fmt.Sprintf("registering record for oid %s in indexd (did: %s)", oid, drsObject.Id))
        _, err = cl.RegisterRecord(ctx, drsObject)
        if err != nil </span><span class="cov5" title="2">{
                // handle "already exists" error ie upsert behavior
                if strings.Contains(err.Error(), "already exists") </span><span class="cov5" title="2">{
                        if !cl.Config.Upsert </span><span class="cov0" title="0">{
                                cl.Logger.DebugContext(ctx, fmt.Sprintf("indexd record already exists, proceeding for oid %s: did: %s err: %v", oid, drsObject.Id, err))
                        }</span> else<span class="cov5" title="2"> {
                                cl.Logger.DebugContext(ctx, fmt.Sprintf("indexd record already exists, deleting and re-adding for oid %s: did: %s", oid, drsObject.Id))
                                err = cl.DeleteRecord(ctx, oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error deleting existing indexd record oid %s: did: %s err: %v", oid, drsObject.Id, err)
                                }</span>
                                <span class="cov5" title="2">_, err = cl.RegisterRecord(ctx, drsObject)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error re-saving indexd record after deletion: oid %s: did: %s err: %v", oid, drsObject.Id, err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("error saving oid %s indexd record: %v", oid, err)
                }</span>
        }
        <span class="cov10" title="4">cl.Logger.InfoContext(ctx, fmt.Sprintf("indexd record registration complete for oid %s", oid))

        // Now attempt to upload the file if not already available
        cl.Logger.InfoContext(ctx, fmt.Sprintf("checking if oid %s is already downloadable", oid))
        downloadable, err := cl.isFileDownloadable(ctx, drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error checking if file is downloadable: oid %s %v", oid, err)
        }</span>
        <span class="cov10" title="4">if downloadable </span><span class="cov5" title="2">{
                cl.Logger.DebugContext(ctx, fmt.Sprintf("file %s is already available for download, skipping upload", oid))
                return drsObject, nil
        }</span>
        <span class="cov5" title="2">cl.Logger.InfoContext(ctx, fmt.Sprintf("file %s is not downloadable, proceeding to upload", oid))

        // Proceed to upload the file
        // Reuse the Gen3 interface
        g3 := cl.G3

        filePath := path
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov5" title="2">defer func(file *os.File) </span><span class="cov5" title="2">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cl.Logger.DebugContext(ctx, fmt.Sprintf("warning: error closing file %s: %v", filePath, err))
                }</span>
        }(file)

        // Use multipart threshold from config or default to 5GB
        <span class="cov5" title="2">multiPartThreshold := int64(5 * 1024 * 1024 * 1024) // 5GB default
        if cl.Config.MultiPartThreshold &gt; 0 </span><span class="cov5" title="2">{
                multiPartThreshold = cl.Config.MultiPartThreshold
        }</span>

        <span class="cov5" title="2">if drsObject.Size &lt; multiPartThreshold </span><span class="cov1" title="1">{
                cl.Logger.DebugContext(ctx, fmt.Sprintf("UploadSingle size: %d path: %s", drsObject.Size, filePath))
                req := common.FileUploadRequestObject{
                        SourcePath: filePath,
                        ObjectKey:  drsObject.Checksums.SHA256,
                        GUID:       drsObject.Id,
                        Bucket:     cl.Config.BucketName,
                }
                err := upload.UploadSingle(ctx, g3, req, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("UploadSingle error: %s", err)
                }</span>
        } else<span class="cov1" title="1"> {
                cl.Logger.DebugContext(ctx, fmt.Sprintf("MultipartUpload size: %d path: %s", drsObject.Size, filePath))
                err = upload.MultipartUpload(
                        ctx,
                        g3,
                        common.FileUploadRequestObject{
                                SourcePath:   filePath,
                                ObjectKey:    drsObject.Checksums.SHA256,
                                GUID:         drsObject.Id,
                                FileMetadata: common.FileMetadata{},
                                Bucket:       cl.Config.BucketName,
                        },
                        file, false,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("MultipartUpload error: %s", err)
                }</span>
        }
        <span class="cov5" title="2">return drsObject, nil</span>
}

// isFileDownloadable checks if a file is already available for download
func (cl *GitDrsIdxdClient) isFileDownloadable(ctx context.Context, drsObject *drs.DRSObject) (bool, error) <span class="cov10" title="4">{
        // Try to get a download URL - if successful, file is downloadable
        if len(drsObject.AccessMethods) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov10" title="4">accessType := drsObject.AccessMethods[0].Type
        res, err := cl.G3.Indexd().GetDownloadURL(ctx, drsObject.Id, accessType)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get a download URL, assume file is not downloadable
                return false, nil
        }</span>
        // Check if the URL is accessible
        <span class="cov10" title="4">err = common.CanDownloadFile(res.URL)
        return err == nil, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package indexd_tests

import (
        "net/http"
        "sync"
)

// MockIndexdRecord represents a test record in the mock server
type MockIndexdRecord struct {
        Did      string
        FileName string
        Size     int64
        Hashes   map[string]string
        URLs     []string
        Authz    []string
}

// MockIndexdServer is a mock server for testing
type MockIndexdServer struct {
        records     map[string]*MockIndexdRecord
        hashIndex   map[string][]string
        recordMutex sync.RWMutex
        server      *http.Server
}

// MockAuthHandler is a mock authentication handler for testing
type MockAuthHandler struct{}

func (m *MockAuthHandler) RefreshAccessToken() (string, error) <span class="cov0" title="0">{
        return "mock-token", nil
}</span>

func (m *MockAuthHandler) GetAccessToken() string <span class="cov0" title="0">{
        return "mock-token"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package addref

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "add-ref &lt;drs_uri&gt; &lt;dst path&gt;",
        Short: "Add a reference to an existing DRS object via URI",
        Long:  "Add a reference to an existing DRS object, eg passing a DRS URI from AnVIL. Requires that the sha256 of the file is already in the cache",
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                drsUri := args[0]
                dstPath := args[1]

                logger := drslog.GetLogger()

                logger.Debug(fmt.Sprintf("Adding reference to DRS object %s to %s", drsUri, dstPath))

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">client, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">obj, err := client.GetObject(context.Background(), drsUri)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">objSha := ""
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                objSha = sum
                        }</span>
                }
                <span class="cov0" title="0">if objSha == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("object %s sha256 not available", drsUri)
                }</span>
                <span class="cov0" title="0">dirPath := filepath.Dir(dstPath)
                _, err = os.Stat(dirPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // The directory does not exist
                        os.MkdirAll(dirPath, os.ModePerm)
                }</span>

                <span class="cov0" title="0">err = CreateLfsPointer(obj, dstPath)
                return err</span>
        },
}

func CreateLfsPointer(drsObj *drs.DRSObject, dst string) error <span class="cov3" title="3">{
        sumMap := hash.ConvertHashInfoToMap(drsObj.Checksums)
        if len(sumMap) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no checksums found for DRS object")
        }</span>

        // find sha256 checksum
        <span class="cov2" title="2">var shaSum string
        for csType, cs := range sumMap </span><span class="cov2" title="2">{
                if csType == hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                        shaSum = cs
                        break</span>
                }
        }
        <span class="cov2" title="2">if shaSum == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("no sha256 checksum found for DRS object")
        }</span>

        // create pointer file content
        <span class="cov1" title="1">pointerContent := "version https://git-lfs.github.com/spec/v1\n"
        pointerContent += fmt.Sprintf("oid sha256:%s\n", shaSum)
        pointerContent += fmt.Sprintf("size %d\n", drsObj.Size)

        // write to file
        err := os.WriteFile(dst, []byte(pointerContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write LFS pointer file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package addurl

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/gitrepo"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

// AddURLCmd represents the add-url command
var AddURLCmd = &amp;cobra.Command{
        Use:   "add-url &lt;url&gt; &lt;sha256&gt;",
        Short: "Add a file to the Git DRS repo using an S3 URL",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 2 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 2 arguments (S3 URL and SHA256), received %d\n\nUsage: %s\n\nSee 'git drs add-url --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                myLogger := drslog.GetLogger()

                // set git config lfs.allowincompletepush = true
                // set git config lfs.allowincompletepush = true
                if err := gitrepo.SetGitConfigOptions(map[string]string{"lfs.allowincompletepush": "true"}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to configure git to push pointers: %v", err)
                }</span>

                // Parse arguments
                <span class="cov0" title="0">s3URL := args[0]
                sha256 := args[1]
                awsAccessKey, _ := cmd.Flags().GetString(s3_utils.AWS_KEY_FLAG_NAME)
                awsSecretKey, _ := cmd.Flags().GetString(s3_utils.AWS_SECRET_FLAG_NAME)
                awsRegion, _ := cmd.Flags().GetString(s3_utils.AWS_REGION_FLAG_NAME)
                awsEndpoint, _ := cmd.Flags().GetString(s3_utils.AWS_ENDPOINT_URL_FLAG_NAME)
                remote, _ := cmd.Flags().GetString("remote")

                // if providing credentials, access key and secret must both be provided
                if (awsAccessKey == "" &amp;&amp; awsSecretKey != "") || (awsAccessKey != "" &amp;&amp; awsSecretKey == "") </span><span class="cov0" title="0">{
                        return errors.New("incomplete credentials provided as environment variables. Please run `export " + s3_utils.AWS_KEY_ENV_VAR + "=&lt;key&gt;` and `export " + s3_utils.AWS_SECRET_ENV_VAR + "=&lt;secret&gt;` to configure both")
                }</span>

                // if none provided, use default AWS configuration on file
                <span class="cov0" title="0">if awsAccessKey == "" &amp;&amp; awsSecretKey == "" </span><span class="cov0" title="0">{
                        myLogger.Debug("No AWS credentials provided. Using default AWS configuration from file.")
                }</span>

                <span class="cov0" title="0">cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting current remote client: %v", err)
                }</span>

                // Call client.AddURL to handle Gen3 interactions
                <span class="cov0" title="0">meta, err := drsClient.AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, awsRegion, awsEndpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Generate and add pointer file
                <span class="cov0" title="0">_, relFilePath, err := utils.ParseS3URL(s3URL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse S3 URL: %w", err)
                }</span>
                <span class="cov0" title="0">if err := generatePointerFile(relFilePath, sha256, meta.Size); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate pointer file: %w", err)
                }</span>
                <span class="cov0" title="0">myLogger.Debug("S3 URL successfully added to Git DRS repo.")
                return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        AddURLCmd.Flags().String(s3_utils.AWS_KEY_FLAG_NAME, os.Getenv(s3_utils.AWS_KEY_ENV_VAR), "AWS access key")
        AddURLCmd.Flags().String(s3_utils.AWS_SECRET_FLAG_NAME, os.Getenv(s3_utils.AWS_SECRET_ENV_VAR), "AWS secret key")
        AddURLCmd.Flags().String(s3_utils.AWS_REGION_FLAG_NAME, os.Getenv(s3_utils.AWS_REGION_ENV_VAR), "AWS S3 region")
        AddURLCmd.Flags().String(s3_utils.AWS_ENDPOINT_URL_FLAG_NAME, os.Getenv(s3_utils.AWS_ENDPOINT_URL_ENV_VAR), "AWS S3 endpoint")
        AddURLCmd.Flags().String("remote", "", "target remote DRS server (default: default_remote)")
}</span>

func generatePointerFile(filePath string, sha256 string, fileSize int64) error <span class="cov1" title="1">{
        // Define the pointer file content
        pointerContent := fmt.Sprintf("version https://git-lfs.github.com/spec/v1\noid sha256:%s\nsize %d\n", sha256, fileSize)

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory for pointer file: %w", err)
        }</span>

        // Write the pointer file
        <span class="cov1" title="1">if err := os.WriteFile(filePath, []byte(pointerContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write pointer file: %w", err)
        }</span>

        // Add the pointer file to Git
        <span class="cov1" title="1">if err := gitrepo.AddFile(filePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add pointer file to Git: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "encoding/csv"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "create-cache &lt;manifest.tsv&gt;",
        Short: "create a local version of a file manifest containing DRS URIs",
        Long:  "create a local version of a file manifest containing DRS URIs. Enables LFS to map its file object id (sha256) back to a DRS URI by file",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov1" title="1">{
                file := args[0]

                // load file
                f, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open manifest file: %w", err)
                }</span>
                <span class="cov1" title="1">defer f.Close()

                // Use encoding/csv with tab delimiter for TSV
                r := csv.NewReader(f)
                r.Comma = '\t'

                // Read header
                header, err := r.Read()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read header: %w", err)
                }</span>

                // Map column names to indices
                <span class="cov1" title="1">colIdx := make(map[string]int, len(header))
                for i, col := range header </span><span class="cov10" title="2">{
                        colIdx[col] = i
                }</span>

                // Check required columns
                <span class="cov1" title="1">shaIdx, shaOk := colIdx["files.sha256"]
                drsIdx, drsOk := colIdx["files.drs_uri"]
                if !shaOk || !drsOk </span><span class="cov0" title="0">{
                        return fmt.Errorf("manifest must contain 'files.sha256' and 'files.drs_uri' columns")
                }</span>

                // Read each row
                <span class="cov1" title="1">for </span><span class="cov10" title="2">{
                        row, err := r.Read()
                        if err != nil </span><span class="cov1" title="1">{
                                if err == io.EOF </span><span class="cov1" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("error reading manifest file: %w", err)</span>
                        }
                        <span class="cov1" title="1">sha := row[shaIdx]
                        drsURI := row[drsIdx]
                        fmt.Printf("Indexing DRS URI %s with sha256 %s\n", drsURI, sha)

                        // create sha to DRS URI mapping
                        objPath, err := drsmap.GetObjectPath(common.DRS_REF_DIR, sha)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get object path for %s: %w", sha, err)
                        }</span>

                        <span class="cov1" title="1">if err := os.MkdirAll(filepath.Dir(objPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", objPath, err)
                        }</span>

                        <span class="cov1" title="1">contents := fmt.Sprintf("files.drs_uri\n%s\n", drsURI)
                        if err := os.WriteFile(objPath, []byte(contents), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write DRS URI for %s: %w", sha, err)
                        }</span>

                        // Split DRS URI into a custom path and write sha to custom path
                        <span class="cov1" title="1">customPath, err := drsmap.CreateCustomPath(common.DRS_REF_DIR, drsURI)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create custom path for %s: %w", drsURI, err)
                        }</span>
                        <span class="cov1" title="1">if err := os.MkdirAll(filepath.Dir(customPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", customPath, err)
                        }</span>
                        <span class="cov1" title="1">if err := os.WriteFile(customPath, []byte(sha), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write sha for %s: %w", drsURI, err)
                        }</span>
                }

                <span class="cov1" title="1">fmt.Printf("Cache created in %s\n", common.DRS_REF_DIR)
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package delete

import (
        "context"
        "fmt"
        "os"

        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag bool
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete &lt;hash-type&gt; &lt;oid&gt;",
        Short:  "Delete a file using hash and file object ID",
        Long:   "Delete a file using file object ID. Use lfs ls-files to get oid",
        Hidden: true,
        Args:   cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                hashType, oid := args[0], args[1]

                // check hash type is valid Checksum type and sha256
                if hashType != hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                        return fmt.Errorf("only sha256 supported, you requested to remove: %s", hashType)
                }</span>

                <span class="cov1" title="1">logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov1" title="1">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        return err
                }</span>

                // Get record details before deletion for confirmation
                <span class="cov0" title="0">records, err := drsClient.GetObjectByHash(context.Background(), &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting records for OID %s: %v", oid, err)
                }</span>
                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no records found for OID %s", oid)
                }</span>

                // Find matching record for current project
                <span class="cov0" title="0">projectId := drsClient.GetProjectId()
                matchingRecord, err := drsmap.FindMatchingRecord(records, projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
                }</span>
                <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no matching record found for project %s and OID %s", projectId, oid)
                }</span>

                // Show details and get confirmation unless --confirm flag is set
                <span class="cov0" title="0">if !confirmFlag </span><span class="cov0" title="0">{
                        common.DisplayWarningHeader(os.Stderr, "DELETE a DRS record")
                        common.DisplayField(os.Stderr, "Remote", string(remoteName))
                        common.DisplayField(os.Stderr, "Project", projectId)
                        common.DisplayField(os.Stderr, "OID", oid)
                        common.DisplayField(os.Stderr, "Hash Type", hashType)
                        common.DisplayField(os.Stderr, "DID", matchingRecord.Id)
                        if matchingRecord.Name != "" </span><span class="cov0" title="0">{
                                common.DisplayField(os.Stderr, "Filename", matchingRecord.Name)
                        }</span>
                        <span class="cov0" title="0">common.DisplayField(os.Stderr, "Size", fmt.Sprintf("%d bytes", matchingRecord.Size))
                        common.DisplayFooter(os.Stderr)

                        if err := common.PromptForConfirmation(
                                os.Stderr,
                                "Type 'yes' to confirm deletion",
                                common.ConfirmationYes,
                                false,
                        ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching record
                <span class="cov0" title="0">err = drsClient.DeleteRecord(context.Background(), oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting file for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully deleted record for OID %s", oid))
                return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVar(&amp;confirmFlag, "confirm", false, "skip interactive confirmation prompt")
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package deleteproject

import (
        "context"
        "fmt"
        "os"

        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete-project &lt;project_id&gt;",
        Short:  "Delete all indexd records for a given project",
        Long:   "Delete all indexd records for a given project",
        Hidden: true,
        Args:   cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                projectId := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        return err
                }</span>

                // Cast to GitDrsIdxdClient to access GetProjectSample
                <span class="cov0" title="0">indexdClient, ok := drsClient.(*indexd.GitDrsIdxdClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("client is not an IndexDClient, cannot proceed with delete-project")
                }</span>

                // Get a sample record to show the user what will be deleted
                <span class="cov0" title="0">sampleRecords, err := indexdClient.GetProjectSample(context.Background(), projectId, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting sample records for project %s: %v", projectId, err)
                }</span>

                // Show details and get confirmation unless --confirm flag matches project_id
                <span class="cov0" title="0">if confirmFlag != "" &amp;&amp; confirmFlag != projectId </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: --confirm value '%s' does not match project ID '%s'", confirmFlag, projectId)
                }</span>
                <span class="cov0" title="0">if confirmFlag != projectId </span><span class="cov0" title="0">{
                        common.DisplayWarningHeader(os.Stderr, "DELETE ALL RECORDS for a project")
                        common.DisplayField(os.Stderr, "Remote", string(remoteName))
                        common.DisplayField(os.Stderr, "Project ID", projectId)

                        if len(sampleRecords) &gt; 0 </span><span class="cov0" title="0">{
                                sample := sampleRecords[0]
                                fmt.Fprintf(os.Stderr, "\nSample record from this project:\n")
                                common.DisplayField(os.Stderr, "  DID", sample.Id)
                                if sample.Name != "" </span><span class="cov0" title="0">{
                                        common.DisplayField(os.Stderr, "  Filename", sample.Name)
                                }</span>
                                <span class="cov0" title="0">common.DisplayField(os.Stderr, "  Size", fmt.Sprintf("%d bytes", sample.Size))
                                if sample.CreatedTime != "" </span><span class="cov0" title="0">{
                                        common.DisplayField(os.Stderr, "  Created", sample.CreatedTime)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "\nNo records found for this project.\n")
                        }</span>

                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\nThis will DELETE ALL records in project '%s'.\n", projectId)
                        common.DisplayFooter(os.Stderr)

                        if err := common.PromptForConfirmation(os.Stderr, fmt.Sprintf("Type the project ID '%s' to confirm deletion", projectId), projectId, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Delete the matching records
                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Deleting all records for project %s...", projectId))
                err = drsClient.DeleteRecordsByProject(context.Background(), projectId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting project %s: %v", projectId, err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully deleted all records for project %s", projectId))
                return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVar(&amp;confirmFlag, "confirm", "", "skip interactive confirmation by providing the project_id (e.g., --confirm my-project)")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package download

import (
        "context"
        "fmt"

        dataClientCommon "github.com/calypr/data-client/common"
        "github.com/calypr/data-client/download"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

var (
        dstPath string
        remote  string
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "download &lt;oid&gt;",
        Short: "Download file using file object ID",
        Long:  "Download file using file object ID (sha256 hash). Use lfs ls-files to get oid",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (file object ID), received %d\n\nUsage: %s\n\nSee 'git drs download --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                oid := args[0]

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        return err
                }</span>

                // get the matching record for this OID
                <span class="cov0" title="0">checksumSpec := &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid}
                records, err := drsClient.GetObjectByHash(context.Background(), checksumSpec)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error looking up OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">matchingRecord, err := drsmap.FindMatchingRecord(records, drsClient.GetProjectId())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error finding matching record for project %s: %v", drsClient.GetProjectId(), err)
                }</span>
                <span class="cov0" title="0">if matchingRecord == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("No matching record found for project %s and OID %s", drsClient.GetProjectId(), oid)
                }</span>

                // download url to destination path or LFS objects if not specified
                <span class="cov0" title="0">if dstPath == "" </span><span class="cov0" title="0">{
                        dstPath, err = drsmap.GetObjectPath(common.LFS_OBJS_PATH, oid)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error getting destination path for OID %s: %v", oid, err)
                }</span>

                <span class="cov0" title="0">ctx := dataClientCommon.WithOid(context.Background(), oid)
                err = download.DownloadToPath(
                        ctx,
                        drsClient.GetGen3Interface(),
                        matchingRecord.Id,
                        dstPath,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error downloading file for OID %s (GUID: %s): %v", oid, matchingRecord.Id, err)
                }</span>

                <span class="cov0" title="0">logger.Debug("file downloaded")

                return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;dstPath, "dst", "d", "", "Destination path to save the downloaded file")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package fetch

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "fetch [remote-name]",
        Short: "fetch drs objects from remote",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) &gt; 1 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs fetch --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov6" title="2">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="2">{
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov6" title="2">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov1" title="1">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov1" title="1"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov1" title="1">{
                                logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov1" title="1">drsClient, err := cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PullRemoteDrsObjects(drsClient, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package initialize

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strconv"
        "time"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/gitrepo"
        "github.com/spf13/cobra"
)

var (
        transfers            int
        upsert               bool
        multiPartThreshold   int
        enableDataClientLogs bool
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize repo for git-drs",
        Long: "Description:" +
                "\n  Initialize repo for git-drs",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov5" title="6">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs init --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov4" title="5">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov4" title="5">{
                logg := drslog.GetLogger()

                // check if .git dir exists to ensure you're in a git repository
                _, err := gitrepo.GitTopLevel()
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error: not in a git repository. Please run this command in the root of your git repository")
                }</span>

                // create config file if it doesn't exist
                <span class="cov4" title="4">err = config.CreateEmptyConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: unable to create config file: %v", err)
                }</span>

                // load the config
                <span class="cov4" title="4">_, err = config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("We should probably fix this: %v", err))
                        return fmt.Errorf("error: unable to load config file: %v", err)
                }</span>

                <span class="cov4" title="4">err = initGitConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error initializing custom transfer for DRS: %v", err)
                }</span>

                // install pre-push hook
                <span class="cov4" title="4">err = installPrePushHook(logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error installing pre-push hook: %v", err)
                }</span>

                // final logs
                <span class="cov4" title="4">logg.Debug("Git DRS initialized")
                logg.Debug(fmt.Sprintf("Using %d concurrent transfers", transfers))
                return nil</span>
        },
}

func initGitConfig() error <span class="cov5" title="6">{
        configs := map[string]string{
                "lfs.standalonetransferagent":                    "drs",
                "lfs.customtransfer.drs.path":                    "git-drs",
                "lfs.customtransfer.drs.args":                    "transfer",
                "lfs.allowincompletepush":                        "false",
                "lfs.customtransfer.drs.concurrent":              strconv.FormatBool(transfers &gt; 1),
                "lfs.concurrenttransfers":                        strconv.Itoa(transfers),
                "lfs.customtransfer.drs.upsert":                  strconv.FormatBool(upsert),
                "lfs.customtransfer.drs.multipart-threshold":     strconv.Itoa(multiPartThreshold),
                "lfs.customtransfer.drs.enable-data-client-logs": strconv.FormatBool(enableDataClientLogs),
        }

        if err := gitrepo.SetGitConfigOptions(configs); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write git config: %w", err)
        }</span>
        <span class="cov5" title="6">return nil</span>
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().IntVarP(&amp;transfers, "transfers", "t", 1, "Number of concurrent transfers")
        Cmd.Flags().BoolVarP(&amp;upsert, "upsert", "u", false, "Enable upsert for indexd records")
        Cmd.Flags().IntVarP(&amp;multiPartThreshold, "multipart-threshold", "m", 500, "Multipart threshold in MB")
        Cmd.Flags().BoolVar(&amp;enableDataClientLogs, "enable-data-client-logs", false, "Enable data-client internal logs")
}</span>

func installPrePushHook(logger *slog.Logger) error <span class="cov5" title="6">{
        hooksDir, err := gitrepo.GetGitHooksDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get hooks directory: %w", err)
        }</span>

        <span class="cov5" title="6">if err := os.MkdirAll(hooksDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create hooks directory: %w", err)
        }</span>

        <span class="cov5" title="6">hookPath := filepath.Join(hooksDir, "pre-push")
        hookBody := `
# . git/hooks/pre-push
remote="$1"
url="$2"

# Buffer stdin for both commands
TMPFILE="${TMPDIR:-/tmp}/git-drs-$$"
trap "rm -f $TMPFILE" EXIT
cat &gt; "$TMPFILE"

# Run DRS preparation
git drs pre-push-prepare "$remote" "$url" &lt; "$TMPFILE" || exit 1

# Run LFS push
exec git lfs pre-push "$remote" "$url" &lt; "$TMPFILE"
`
        hookScript := "#!/bin/sh\n" + hookBody

        existingContent, err := os.ReadFile(hookPath)
        if err == nil </span><span class="cov3" title="3">{
                // there is an existing hook, rename it, and let the user know
                // Backup existing hook with timestamp
                timestamp := time.Now().Format("20060102T150405")
                backupPath := hookPath + "." + timestamp
                if err := os.WriteFile(backupPath, existingContent, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to back up existing pre-push hook: %w", err)
                }</span>
                <span class="cov3" title="3">if err := os.Remove(hookPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove hook after backing up: %w", err)
                }</span>
                <span class="cov3" title="3">logger.Debug(fmt.Sprintf("pre-push hook updated; backup written to %s", backupPath))</span>
        }
        // If there was an error other than expected not existing, return it
        <span class="cov5" title="6">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to read pre-push hook: %w", err)
        }</span>

        <span class="cov5" title="6">err = os.WriteFile(hookPath, []byte(hookScript), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write pre-push hook: %w", err)
        }</span>
        <span class="cov5" title="6">logger.Debug("pre-push hook installed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package list

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var (
        outJson     bool = false
        outFile     string
        listOutFile string
        remote      string
)

var checksumPref = []hash.ChecksumType{hash.ChecksumTypeSHA256, hash.ChecksumTypeMD5, hash.ChecksumTypeETag}

func getChecksumPos(q hash.ChecksumType, a []hash.ChecksumType) int <span class="cov4" title="4">{
        for i, s := range a </span><span class="cov5" title="7">{
                if q == s </span><span class="cov3" title="3">{
                        return i
                }</span>
        }
        <span class="cov1" title="1">return -1</span>
}

// Pick out the most preferred checksum to display
func getCheckSumStr(obj drs.DRSObject) string <span class="cov1" title="1">{
        curPos := len(checksumPref) + 1
        curVal := ""
        for checksumType, checksum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov2" title="2">{
                c := getChecksumPos(hash.ChecksumType(checksumType), checksumPref)
                if c != -1 &amp;&amp; c &lt; curPos </span><span class="cov2" title="2">{
                        curPos = c
                        curVal = checksumType + ":" + checksum
                }</span>
        }
        <span class="cov1" title="1">return curVal</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS entities from server",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                logger := drslog.GetLogger()

                var outWriter io.Writer
                if listOutFile != "" </span><span class="cov0" title="0">{
                        f, err := os.Create(listOutFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        outWriter = f</span>
                } else<span class="cov2" title="2"> {
                        outWriter = os.Stdout
                }</span>

                <span class="cov2" title="2">conf, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov2" title="2">remoteName, err := conf.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov1" title="1">client, err := conf.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Debug("Client failed")
                        return err
                }</span>
                <span class="cov0" title="0">objChan, err := client.ListObjects(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !outJson </span><span class="cov0" title="0">{
                        fmt.Fprintf(outWriter, "%-55s\t%-15s\t%-75s\t%s\n", "URI", "Size", "Checksum", "Name")
                }</span>

                // for each result, check for error and print
                <span class="cov0" title="0">for objResult := range objChan </span><span class="cov0" title="0">{
                        if objResult.Error != nil </span><span class="cov0" title="0">{
                                return objResult.Error
                        }</span>
                        <span class="cov0" title="0">obj := objResult.Object
                        if outJson </span><span class="cov0" title="0">{
                                out, err := sonic.ConfigFastest.Marshal(*obj)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">fmt.Fprintf(outWriter, "%s\n", string(out))</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(outWriter, "%s\t%-15d\t%-75s\t%s\n", obj.SelfURI, obj.Size, getCheckSumStr(*obj), obj.Name)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}
var ListProjectCmd = &amp;cobra.Command{
        Use:   "list-project &lt;project-id&gt;",
        Short: "List DRS entities from server",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                if len(args) != 1 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (project ID), received %d\n\nUsage: %s\n\nSee 'git drs list-project --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                conf, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := conf.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">client, err := conf.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">objChan, err := client.ListObjectsByProject(context.Background(), args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var f *os.File
                var outWriter io.Writer
                if outFile != "" </span><span class="cov0" title="0">{
                        f, err = os.Create(outFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        outWriter = f</span>
                } else<span class="cov0" title="0"> {
                        outWriter = os.Stdout
                }</span>
                <span class="cov0" title="0">for objResult := range objChan </span><span class="cov0" title="0">{
                        if objResult.Error != nil </span><span class="cov0" title="0">{
                                return objResult.Error
                        }</span>
                        <span class="cov0" title="0">obj := objResult.Object
                        out, err := sonic.ConfigFastest.Marshal(*obj)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = outWriter.Write(out)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = outWriter.Write([]byte("\n"))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        ListProjectCmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        ListProjectCmd.Flags().StringVarP(&amp;outFile, "out", "o", outFile, "File path to save output to")
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;listOutFile, "out", "o", listOutFile, "File path to save output to")
        Cmd.Flags().BoolVarP(&amp;outJson, "json", "j", outJson, "Output formatted as JSON")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package listconfig

import (
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        jsonOutput bool
)

// Cmd represents the list-config command
var Cmd = &amp;cobra.Command{
        Use:   "list-config",
        Short: "Display the current configuration",
        Long:  "Pretty prints the current configuration file in YAML format",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list-config --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov1" title="1">{
                // Load the current configuration
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                <span class="cov1" title="1">if jsonOutput </span><span class="cov0" title="0">{
                        // Output as JSON if requested
                        encoder := sonic.ConfigFastest.NewEncoder(os.Stdout)
                        encoder.SetIndent("", "  ")
                        return encoder.Encode(cfg)
                }</span> else<span class="cov1" title="1"> {
                        // Default YAML output with nice formatting
                        encoder := yaml.NewEncoder(os.Stdout)
                        encoder.SetIndent(2)
                        defer encoder.Close()

                        return encoder.Encode(cfg)
                }</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().BoolVarP(&amp;jsonOutput, "json", "j", false, "output in JSON format")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package prepush

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "sort"
        "strings"

        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "pre-push-prepare",
        Short: "pre-push hook to update DRS objects",
        Long:  "Pre-push hook that updates DRS objects before transfer",
        Args:  cobra.RangeArgs(0, 2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="4">{
                //myLogger := drslog.GetLogger()
                myLogger, err := drslog.NewLogger("", false)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating logger: %v", err)
                }</span>

                <span class="cov6" title="4">myLogger.Debug("~~~~~~~~~~~~~ START: pre-push ~~~~~~~~~~~~~")

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting config: %v", err)
                }</span>

                //Command-line arguments: The hook receives two parameters:
                //* The name of the remote (e.g., origin).
                //* The remote's location/URL (e.g., github.com).
                // Create gitRemoteName and gitRemoteLocation from args.
                <span class="cov6" title="4">myLogger.Debug(fmt.Sprintf("pre-push args: %v", args))
                var gitRemoteName, gitRemoteLocation string
                if len(args) &gt;= 1 </span><span class="cov6" title="4">{
                        gitRemoteName = args[0]
                }</span>
                <span class="cov6" title="4">if len(args) &gt;= 2 </span><span class="cov6" title="4">{
                        gitRemoteLocation = args[1]
                }</span>
                <span class="cov6" title="4">if gitRemoteName == "" </span><span class="cov0" title="0">{
                        gitRemoteName = "origin"
                }</span>
                <span class="cov6" title="4">myLogger.Debug(fmt.Sprintf("git remote name: %s, git remote location: %s", gitRemoteName, gitRemoteLocation))

                // get the default remote from the .git/drs/config
                var remote config.Remote
                remote, err = cfg.GetDefaultRemote()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Warning. Error getting default remote: %v", err))
                        // Print warning to stderr and return success (exit 0)
                        fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting default remote:", err)
                        return nil
                }</span>

                // get the remote client
                <span class="cov6" title="4">cli, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        // Print warning to stderr and return success (exit 0)
                        fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting remote client:", err)
                        myLogger.Debug(fmt.Sprintf("Warning. Skipping DRS preparation. Error getting remote client: %v", err))
                        // Check for GitDrsIdxdClient
                }</span>
                <span class="cov6" title="4">dc, ok := cli.(*indexd.GitDrsIdxdClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cli is not IndexdClient: %T", cli)
                }</span>
                <span class="cov6" title="4">myLogger.Debug(fmt.Sprintf("Current server: %s", dc.Config.ProjectId))

                // Buffer stdin to a temp file and invoke `git lfs pre-push &lt;remote&gt; &lt;url&gt;` with same args and stdin.
                tmp, err := os.CreateTemp("", "prepush-stdin-*")
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("error creating temp file for stdin: %v", err))
                        return err
                }</span>
                <span class="cov6" title="4">defer func() </span><span class="cov6" title="4">{
                        _ = tmp.Close()
                        _ = os.Remove(tmp.Name())
                }</span>()

                // Copy all of stdin into the temp file.
                <span class="cov6" title="4">if _, err := io.Copy(tmp, os.Stdin); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("error buffering stdin: %v", err))
                        return err
                }</span>

                // Rewind to start so the child process can read it.
                <span class="cov6" title="4">if _, err := tmp.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("error seeking temp stdin: %v", err))
                        return err
                }</span>

                // read the temp file and get a list of all unique local branches being pushed
                <span class="cov6" title="4">branches, err := readPushedBranches(tmp)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("error reading pushed branches: %v", err))
                        return err
                }</span>

                <span class="cov6" title="4">myLogger.Debug(fmt.Sprintf("Preparing DRS objects for push branches: %v", branches))
                err = drsmap.UpdateDrsObjects(cli, gitRemoteName, gitRemoteLocation, branches, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("UpdateDrsObjects failed: %v", err))
                        return err
                }</span>
                <span class="cov6" title="4">myLogger.Debug("DRS objects prepared for push!")

                myLogger.Debug("~~~~~~~~~~~~~ COMPLETED: pre-push ~~~~~~~~~~~~~")
                return nil</span>
        },
}

// readPushedBranches reads git push lines from the provided temp file,
// extracts unique local branch names for refs under `refs/heads/` and
// returns them sorted. The file is rewound to the start before returning.
func readPushedBranches(f *os.File) ([]string, error) <span class="cov9" title="9">{
        // Ensure we read from start
        // example:
        // refs/heads/main 67890abcdef1234567890abcdef1234567890abcd refs/heads/main 12345abcdef67890abcdef1234567890abcdef12
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="9">scanner := bufio.NewScanner(f)
        set := make(map[string]struct{})
        for scanner.Scan() </span><span class="cov10" title="10">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="10">localRef := fields[0]
                const prefix = "refs/heads/"
                if strings.HasPrefix(localRef, prefix) </span><span class="cov9" title="8">{
                        branch := strings.TrimPrefix(localRef, prefix)
                        if branch != "" </span><span class="cov9" title="8">{
                                set[branch] = struct{}{}
                        }</span>
                }
        }
        <span class="cov9" title="9">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="9">branches := make([]string, 0, len(set))
        for b := range set </span><span class="cov9" title="8">{
                branches = append(branches, b)
        }</span>
        <span class="cov9" title="9">sort.Strings(branches)
        // Rewind so caller can reuse the file
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="9">return branches, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package push

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"

        "github.com/calypr/git-drs/client/indexd"
)

var Cmd = &amp;cobra.Command{
        Use:   "push [remote-name]",
        Short: "push local objects to drs server.",
        Long:  "push local objects to drs server. Any local files that do not have drs records are written to a bucket.",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) &gt; 1 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs push --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov6" title="2">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="2">{
                myLogger := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error loading config: %v", err))
                        return err
                }</span>

                <span class="cov6" title="2">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov6" title="2"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov6" title="2">{
                                myLogger.Debug(fmt.Sprintf("Error getting default remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error creating indexd client: %s", err))
                        return err
                }</span>

                // Check for GitDrsIdxdClient
                <span class="cov0" title="0">icli, ok := drsClient.(*indexd.GitDrsIdxdClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("remote client is not an *indexdCl.IndexDClient (got %T), cannot push", drsClient)
                }</span>

                <span class="cov0" title="0">err = drsmap.PushLocalDrsObjects(drsClient, icli.GetGen3Interface(), icli.GetBucketName(), icli.GetUpsert(), myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package query

import (
        "context"
        "fmt"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

// printDRSObject marshals and prints a DRS object based on the pretty flag
func printDRSObject(obj drs.DRSObject, pretty bool) error <span class="cov2" title="2">{
        var out []byte
        var err error

        if pretty </span><span class="cov1" title="1">{
                out, err = sonic.ConfigFastest.MarshalIndent(obj, "", "  ")
        }</span> else<span class="cov1" title="1"> {
                out, err = sonic.ConfigFastest.Marshal(obj)
        }</span>

        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">fmt.Printf("%s\n", string(out))
        return nil</span>
}

var remote string
var checksum = false
var pretty = false

type checksumClient interface {
        GetObjectByHash(ctx context.Context, hash *hash.Checksum) ([]drs.DRSObject, error)
}

func queryByChecksum(client checksumClient, checksum string) ([]drs.DRSObject, error) <span class="cov4" title="4">{
        // Auto-detect checksum type based on hash length
        checksumType := hash.ChecksumTypeSHA256
        switch len(checksum) </span>{
        case 32:<span class="cov1" title="1">
                // 128-bit / 32-hex-character checksum (e.g., MD5)
                checksumType = hash.ChecksumTypeMD5</span>
        case 40:<span class="cov1" title="1">
                // 160-bit / 40-hex-character checksum (e.g., SHA1)
                checksumType = hash.ChecksumTypeSHA1</span>
        case 64:<span class="cov1" title="1">
                // 256-bit / 64-hex-character checksum (e.g., SHA256)
                checksumType = hash.ChecksumTypeSHA256</span>
        case 128:<span class="cov1" title="1">
                // 512-bit / 128-hex-character checksum (e.g., SHA512)
                checksumType = hash.ChecksumTypeSHA512</span>
        }

        <span class="cov4" title="4">return client.GetObjectByHash(context.Background(), &amp;hash.Checksum{
                Checksum: checksum,
                Type:     checksumType,
        })</span>
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "query &lt;drs_id&gt;",
        Short: "Query DRS server by DRS ID",
        Long:  "Query DRS server by DRS ID",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (DRS ID), received %d\n\nUsage: %s\n\nSee 'git drs query --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                config, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">remoteName, err := config.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">client, err := config.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var obj *drs.DRSObject

                if checksum </span><span class="cov0" title="0">{
                        objs, err := queryByChecksum(client, args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, drsObj := range objs </span><span class="cov0" title="0">{
                                if err := printDRSObject(drsObj, pretty); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        obj, err = client.GetObject(context.Background(), args[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := printDRSObject(*obj, pretty); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVarP(&amp;checksum, "checksum", "c", checksum, "Find by checksum")
        Cmd.Flags().BoolVarP(&amp;pretty, "pretty", "p", pretty, "Print indented JSON")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package register

import (
        "context"
        "fmt"

        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "register",
        Short: "Register all pending DRS objects with indexd",
        Long:  "Reads pending objects from .git/drs/lfs/objects/ and registers them with indexd (does not upload files)",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov2" title="2">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs register --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov1" title="1">{
                logger, err := drslog.NewLogger("", true)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        return err
                }</span>

                <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating indexd client: %v", err)
                }</span>
                // Check for GitDrsIdxdClient
                <span class="cov0" title="0">icli, ok := cli.(*indexd.GitDrsIdxdClient)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("remote client is not an *indexd.GitDrsIdxdClient (got %T)", cli)
                }</span>

                // Get all pending objects
                <span class="cov0" title="0">pendingObjects, err := lfs.GetPendingObjects(logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error reading pending objects: %v", err)
                }</span>

                <span class="cov0" title="0">if len(pendingObjects) == 0 </span><span class="cov0" title="0">{
                        logger.Debug("No pending objects to register")
                        return nil
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Found %d pending object(s) to register", len(pendingObjects)))

                registeredCount := 0
                skippedCount := 0
                errorCount := 0

                // Register each pending object with indexd
                for _, obj := range pendingObjects </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("Processing %s (OID: %s)", obj.Path, obj.OID))

                        // Read the IndexdRecord from disk
                        indexdObj, err := drsmap.DrsInfoFromOid(obj.OID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error reading DRS object for %s: %v", obj.Path, err))
                                errorCount++
                                continue</span>
                        }

                        // Check if records with this hash already exist in indexd
                        <span class="cov0" title="0">records, err := cli.GetObjectByHash(context.Background(), &amp;hash.Checksum{Type: "sha256", Checksum: obj.OID})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error querying indexd for %s: %v", obj.Path, err))
                                errorCount++
                                continue</span>
                        }

                        // Check if a record with this exact DID already exists
                        <span class="cov0" title="0">alreadyExists := false
                        for _, record := range records </span><span class="cov0" title="0">{
                                if record.Id == indexdObj.Id </span><span class="cov0" title="0">{
                                        alreadyExists = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if alreadyExists </span><span class="cov0" title="0">{
                                logger.Debug(fmt.Sprintf("Record for %s (DID: %s) already exists in indexd, skipping", obj.Path, indexdObj.Id))
                                skippedCount++
                                continue</span>
                        }

                        // Register the indexd record
                        <span class="cov0" title="0">_, err = icli.RegisterRecord(context.Background(), indexdObj)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error registering %s with indexd: %v", obj.Path, err))
                                errorCount++
                                continue</span>
                        }

                        <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Successfully registered %s with DID %s", obj.Path, indexdObj.Id))
                        registeredCount++</span>
                }

                // Summary
                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Registration complete: %d registered, %d skipped, %d errors",
                        registeredCount, skippedCount, errorCount))

                if errorCount &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("completed with %d error(s)", errorCount)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov10" title="47">{
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package add

import (
        "fmt"
        "log/slog"

        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
)

var AnvilCmd = &amp;cobra.Command{
        Use: "anvil [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add anvil --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return fmt.Errorf("error: anvil remote is not yet implemented. Use 'git drs remote add gen3' instead. See 'git drs remote add gen3 --help' for more details")
        }</span>,
}

func anvilInit(terraProject string, logger *slog.Logger) error <span class="cov0" title="0">{
        // make sure terra project is provided
        if terraProject != "" </span><span class="cov0" title="0">{
                // populate anvil config
                remoteAnvil := config.RemoteSelect{
                        Anvil: &amp;anvil_client.AnvilRemote{
                                Endpoint: anvil_client.ANVIL_ENDPOINT,
                                Auth: anvil_client.AnvilAuth{
                                        TerraProject: terraProject,
                                },
                        },
                }
                // TODO: different than ORIGIN?
                remoteName := config.Remote(config.AnvilServerType)
                _, err := config.UpdateRemote(remoteName, remoteAnvil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error: unable to update config file: %v\n", err)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package add

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/calypr/data-client/conf"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var Gen3Cmd = &amp;cobra.Command{
        Use: "gen3 [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add gen3 --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                logg := drslog.GetLogger()

                // make sure at least one of the credentials params is provided
                if credFile == "" &amp;&amp; fenceToken == "" &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a credentials file or accessToken to setup project locally. Please provide either a --cred or --token flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                // When adding a new remote, bucket field is required.
                <span class="cov10" title="4">if bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a bucket name to be specified when adding a new remote. Please specify a bucket with --bucket flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                <span class="cov10" title="4">remoteName := config.ORIGIN
                if len(args) &gt; 0 </span><span class="cov10" title="4">{
                        remoteName = args[0]
                }</span>

                <span class="cov10" title="4">err := gen3Init(remoteName, credFile, fenceToken, project, bucket, logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error configuring gen3 server: %v", err)
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
}

func gen3Init(remoteName, credFile, fenceToken, project, bucket string, logg *slog.Logger) error <span class="cov10" title="4">{
        if remoteName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote name is required")
        }</span>
        <span class="cov10" title="4">if project == "" || bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project and bucket are required for Gen3 remote")
        }</span>

        <span class="cov10" title="4">var accessToken, apiKey, keyID, apiEndpoint string
        configure := conf.NewConfigure(logg)
        switch </span>{
        case fenceToken != "":<span class="cov0" title="0">
                accessToken = fenceToken
                var err error
                apiEndpoint, err = utils.ParseAPIEndpointFromToken(accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from provided access token: %w", err)
                }</span>

        case credFile != "":<span class="cov10" title="4">
                cred, err := configure.Import(credFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read credentials file %s: %w", credFile, err)
                }</span>
                <span class="cov10" title="4">accessToken = cred.AccessToken
                apiKey = cred.APIKey
                keyID = cred.KeyID

                apiEndpoint, err = utils.ParseAPIEndpointFromToken(cred.APIKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from API key in credentials file: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                existing, err := configure.Load(remoteName)
                if err == nil </span><span class="cov0" title="0">{
                        accessToken = existing.AccessToken
                        apiKey = existing.APIKey
                        keyID = existing.KeyID
                        apiEndpoint = existing.APIEndpoint
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("must provide either --cred or --token (or have existing profile %s)", remoteName)
                }</span>
        }

        <span class="cov10" title="4">if apiEndpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not determine Gen3 API endpoint")
        }</span>

        <span class="cov10" title="4">remoteGen3 := config.RemoteSelect{
                Gen3: &amp;indexd.Gen3Remote{
                        Endpoint:  apiEndpoint,
                        ProjectID: project,
                        Bucket:    bucket,
                },
        }

        remote := config.Remote(remoteName)
        if _, err := config.UpdateRemote(remote, remoteGen3); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update remote config: %w", err)
        }</span>
        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Remote added/updated: %s  %s (project: %s, bucket: %s)", remoteName, apiEndpoint, project, bucket))

        // Step 3: Ensure credential profile is up-to-date (refreshes token if needed)
        cred := &amp;conf.Credential{
                Profile:            remoteName,
                APIEndpoint:        apiEndpoint,
                APIKey:             apiKey,
                KeyID:              keyID,
                AccessToken:        accessToken, // may be stale
                UseShepherd:        "false",     // or preserve from existing?
                MinShepherdVersion: "",
        }

        gen3Logger := logs.NewGen3Logger(logg, "", remoteName)
        if err := g3client.EnsureValidCredential(context.Background(), cred, configure, gen3Logger, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify/refresh Gen3 credential: %w", err)
        }</span>

        <span class="cov10" title="4">if err := configure.Save(cred); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure/update Gen3 profile: %w", err)
        }</span>

        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Gen3 profile '%s' configured and token refreshed successfully", remoteName))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package add

import "github.com/spf13/cobra"

var (
        server       string
        apiEndpoint  string
        bucket       string
        credFile     string
        fenceToken   string
        project      string
        terraProject string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "add",
        Short: "add server access for git-drs",
}

func init() <span class="cov10" title="48">{
        Gen3Cmd.Flags().StringVar(&amp;server, "server", "gen3", "Options for DRS server: gen3 or anvil")
        Gen3Cmd.Flags().StringVar(&amp;apiEndpoint, "url", "", "[gen3] Specify the API endpoint of the data commons")
        Gen3Cmd.Flags().StringVar(&amp;bucket, "bucket", "", "[gen3] Specify the bucket name")
        Gen3Cmd.Flags().StringVar(&amp;credFile, "cred", "", "[gen3] Specify the gen3 credential file that you want to use")
        Gen3Cmd.Flags().StringVar(&amp;fenceToken, "token", "", "[gen3] Specify the token to be used as a replacement for a credential file for temporary access")
        Gen3Cmd.Flags().StringVar(&amp;project, "project", "", "[gen3] Specify the gen3 project ID in the format &lt;program&gt;-&lt;project&gt;")
        AnvilCmd.Flags().StringVar(&amp;terraProject, "terraProject", "", "[AnVIL] Specify the Terra project ID")

        Cmd.AddCommand(Gen3Cmd)
        Cmd.AddCommand(AnvilCmd)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS repos",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="2">{
                if len(args) != 0 </span><span class="cov1" title="1">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs remote list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov1" title="1">{
                logg := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("Error loading config: %s", err))
                        return err
                }</span>

                <span class="cov1" title="1">for name, remoteSelect := range cfg.Remotes </span><span class="cov1" title="1">{
                        // Determine if this is the default
                        isDefault := name == cfg.DefaultRemote
                        marker := " "
                        if isDefault </span><span class="cov1" title="1">{
                                marker = "*"
                        }</span>

                        // Determine remote type and endpoint
                        <span class="cov1" title="1">var remoteType string
                        var remote config.DRSRemote
                        if remoteSelect.Gen3 != nil </span><span class="cov1" title="1">{
                                remoteType = string(config.Gen3ServerType)
                                remote = remoteSelect.Gen3
                        }</span> else<span class="cov0" title="0"> if remoteSelect.Anvil != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.AnvilServerType)
                                remote = remoteSelect.Anvil
                        }</span> else<span class="cov0" title="0"> {
                                remoteType = "unknown"
                        }</span>

                        <span class="cov1" title="1">endpoint := "N/A"
                        if remote != nil </span><span class="cov1" title="1">{
                                endpoint = remote.GetEndpoint()
                        }</span>

                        <span class="cov1" title="1">fmt.Printf("%s %-10s %-8s %s\n", marker, name, remoteType, endpoint)</span>
                }
                <span class="cov1" title="1">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package remote

import (
        "github.com/calypr/git-drs/cmd/remote/add"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "remote",
        Short: "Manage remote DRS server configs",
}

func init() <span class="cov10" title="47">{
        Cmd.AddCommand(add.Cmd)
        Cmd.AddCommand(ListCmd)
        Cmd.AddCommand(SetCmd)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var SetCmd = &amp;cobra.Command{
        Use:   "set &lt;remote-name&gt;",
        Short: "Set the default DRS remote",
        Long:  "Set which DRS remote to use by default for all operations",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
                if len(args) != 1 </span><span class="cov6" title="2">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (remote name), received %d\n\nUsage: %s\n\nRun 'git drs remote list' to see available remotes or 'git drs remote set --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov1" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                remoteName := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                // validate remote exists
                <span class="cov0" title="0">remote := config.Remote(remoteName)
                if _, ok := cfg.Remotes[remote]; !ok </span><span class="cov0" title="0">{
                        availableRemotes := make([]string, 0, len(cfg.Remotes))
                        for name := range cfg.Remotes </span><span class="cov0" title="0">{
                                availableRemotes = append(availableRemotes, string(name))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf(
                                "remote '%s' not found.\nAvailable remotes: %v",
                                remoteName,
                                availableRemotes,
                        )</span>
                }

                // save new default
                <span class="cov0" title="0">cfg.DefaultRemote = remote

                if err := config.SaveConfig(cfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save config: %w", err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Default remote set to: %s", remoteName))
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package cmd

import (
        "github.com/calypr/git-drs/cmd/addref"
        "github.com/calypr/git-drs/cmd/addurl"
        "github.com/calypr/git-drs/cmd/cache"
        "github.com/calypr/git-drs/cmd/delete"
        "github.com/calypr/git-drs/cmd/deleteproject"
        "github.com/calypr/git-drs/cmd/download"
        "github.com/calypr/git-drs/cmd/fetch"
        "github.com/calypr/git-drs/cmd/initialize"
        "github.com/calypr/git-drs/cmd/list"
        "github.com/calypr/git-drs/cmd/listconfig"
        "github.com/calypr/git-drs/cmd/prepush"
        "github.com/calypr/git-drs/cmd/push"
        "github.com/calypr/git-drs/cmd/query"
        "github.com/calypr/git-drs/cmd/register"
        "github.com/calypr/git-drs/cmd/remote"
        "github.com/calypr/git-drs/cmd/transfer"
        "github.com/calypr/git-drs/cmd/transferref"
        "github.com/calypr/git-drs/cmd/version"
        "github.com/spf13/cobra"
)

// RootCmd represents the root command
var RootCmd = &amp;cobra.Command{
        Use:   "git-drs",
        Short: "Git DRS - Git-LFS file management for DRS servers",
        Long:  "Git DRS provides the benefits of Git-LFS file management using DRS for seamless integration with Gen3 servers",
        PersistentPreRun: func(cmd *cobra.Command, args []string) {<span class="cov10" title="46">
                //pre-run code can go here
        }</span>,
}

func init() <span class="cov10" title="46">{
        RootCmd.AddCommand(addref.Cmd)
        RootCmd.AddCommand(cache.Cmd)
        RootCmd.AddCommand(delete.Cmd)
        RootCmd.AddCommand(deleteproject.Cmd)
        RootCmd.AddCommand(register.Cmd)
        RootCmd.AddCommand(download.Cmd)
        RootCmd.AddCommand(initialize.Cmd)
        RootCmd.AddCommand(list.Cmd)
        RootCmd.AddCommand(list.ListProjectCmd)
        RootCmd.AddCommand(listconfig.Cmd)
        RootCmd.AddCommand(prepush.Cmd)
        RootCmd.AddCommand(query.Cmd)
        RootCmd.AddCommand(transfer.Cmd)
        RootCmd.AddCommand(transferref.Cmd)
        RootCmd.AddCommand(version.Cmd)
        RootCmd.AddCommand(addurl.AddURLCmd)
        RootCmd.AddCommand(remote.Cmd)
        RootCmd.AddCommand(fetch.Cmd)
        RootCmd.AddCommand(push.Cmd)

        RootCmd.CompletionOptions.HiddenDefaultCmd = true
        RootCmd.SilenceUsage = true
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package transfer

import (
        "bufio"
        "context"
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        dataClientCommon "github.com/calypr/data-client/common"
        "github.com/calypr/git-drs/common"

        "github.com/calypr/data-client/download"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

// TransferJob carries the raw JSON data and shared client
type TransferJob struct {
        data      []byte
        drsClient client.DRSClient
}

// TransferResult sent back to the single writer
type TransferResult struct {
        data    any
        isError bool
}

var (
        // Set once after init  determines which path all workers take
        transferOperation string    // "upload" or "download"
        sConfig           sonic.API = sonic.ConfigFastest
)

const (
        OPERATION_UPLOAD   = "upload"
        OPERATION_DOWNLOAD = "download"
)

var Cmd = &amp;cobra.Command{
        Use:   "transfer",
        Short: "[RUN VIA GIT LFS] register LFS files into gen3 during git push",
        Long:  `[RUN VIA GIT LFS] git-lfs transfer mechanism to register LFS files up to gen3 during git push. For new files, creates an indexd record and uploads to the bucket`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov9" title="35">{
                logger := drslog.GetLogger()
                logger.Info("~~~~~~~~~~~~~ START: drs transfer ~~~~~~~~~~~~~")

                // Gotta go fast  big buffer
                scanner := bufio.NewScanner(os.Stdin)
                const maxCapacity = 10 * 1024 * 1024 // 10 MB
                buf := make([]byte, 0, 64*1024)
                scanner.Buffer(buf, maxCapacity)
                streamEncoder := encoder.NewStreamEncoder(os.Stdout)

                // Read init message
                if !scanner.Scan() </span><span class="cov1" title="1">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="34">initBytes := make([]byte, len(scanner.Bytes()))
                copy(initBytes, scanner.Bytes())
                var initMsg lfs.InitMessage
                if err := sConfig.Unmarshal(initBytes, &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error decoding initial JSON message: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="34">if initMsg.Event != "init" </span><span class="cov0" title="0">{
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%s'", initMsg.Event)
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="34">var drsClient client.DRSClient

                // Load config first
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error loading config: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                // Determine remote
                <span class="cov9" title="34">remote, err := cfg.GetDefaultRemote()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                <span class="cov9" title="34">drsClient, err = cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error creating DRS client: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>

                // Determine if upload or download
                <span class="cov9" title="34">if initMsg.Operation == OPERATION_UPLOAD || initMsg.Operation == OPERATION_DOWNLOAD </span><span class="cov9" title="34">{
                        transferOperation = initMsg.Operation
                        logger.Debug(fmt.Sprintf("Transfer operation: %s", transferOperation))
                }</span> else<span class="cov0" title="0"> {
                        err := fmt.Errorf("invalid or missing operation in init message: %s", initMsg.Operation)
                        logger.Error(err.Error())
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        return err
                }</span>
                <span class="cov9" title="34">if err := streamEncoder.Encode(map[string]any{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error sending init acknowledgment: %v", err))
                        return err
                }</span>

                <span class="cov9" title="34">for scanner.Scan() </span><span class="cov10" title="42">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("error decoding JSON: %s", err))
                                continue</span>
                        }

                        <span class="cov10" title="42">if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov4" title="4">{
                                // Handle download event
                                logger.Debug("Download requested")

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, "", 400, errMsg)
                                        continue</span>
                                }
                                <span class="cov4" title="4">ctx := dataClientCommon.WithProgress(context.Background(), lfs.NewProgressCallback(streamEncoder))
                                ctx = dataClientCommon.WithOid(ctx, downloadMsg.Oid)
                                logger.InfoContext(ctx, fmt.Sprintf("Downloading file OID %s", downloadMsg.Oid))

                                // get the matching record for this OID
                                checksumSpec := &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: downloadMsg.Oid}
                                records, err := drsClient.GetObjectByHash(ctx, checksumSpec)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error looking up OID %s: %v", downloadMsg.Oid, err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }

                                <span class="cov4" title="4">matchingRecord, err := drsmap.FindMatchingRecord(records, drsClient.GetProjectId())
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error finding matching record for project %s: %v", drsClient.GetProjectId(), err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }
                                <span class="cov4" title="4">if matchingRecord == nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("No matching record found for project %s and OID %s", drsClient.GetProjectId(), downloadMsg.Oid)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 404, errMsg)
                                        continue</span>
                                }

                                // download using data-client
                                <span class="cov4" title="4">dstPath, err := drsmap.GetObjectPath(common.LFS_OBJS_PATH, downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error getting destination path for OID %s: %v", downloadMsg.Oid, err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                <span class="cov4" title="4">err = download.DownloadToPath(
                                        ctx,
                                        drsClient.GetGen3Interface(),
                                        matchingRecord.Id,
                                        dstPath,
                                )
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s (GUID: %s): %v", downloadMsg.Oid, matchingRecord.Id, err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }

                                <span class="cov4" title="4">lfs.WriteProgressMessage(streamEncoder, downloadMsg.Oid, downloadMsg.Size, downloadMsg.Size)

                                // send success message back
                                logger.InfoContext(ctx, fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))

                                lfs.WriteCompleteMessage(streamEncoder, downloadMsg.Oid, dstPath)</span>

                        } else<span class="cov9" title="38"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov4" title="4">{
                                // Handle upload event
                                logger.Debug("Upload requested")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                <span class="cov4" title="4">ctx := dataClientCommon.WithProgress(context.Background(), lfs.NewProgressCallback(streamEncoder))
                                ctx = dataClientCommon.WithOid(ctx, uploadMsg.Oid)
                                logger.InfoContext(ctx, fmt.Sprintf("Uploading file OID %s", uploadMsg.Oid))

                                drsObj, err := drsClient.RegisterFile(ctx, uploadMsg.Oid, uploadMsg.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error registering file: %v\n", err)
                                        logger.ErrorContext(ctx, errMsg)
                                        lfs.WriteErrorMessage(streamEncoder, uploadMsg.Oid, 502, errMsg)
                                        continue</span>
                                }
                                // send success message back
                                <span class="cov4" title="4">lfs.WriteCompleteMessage(streamEncoder, uploadMsg.Oid, drsObj.Name)
                                logger.InfoContext(ctx, fmt.Sprintf("Upload for Oid %s complete", uploadMsg.Oid))</span>

                        } else<span class="cov9" title="34"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov9" title="34">{
                                logger.Info("LFS transfer terminate received.")
                        }</span>
                }

                <span class="cov9" title="34">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("stdin error: %s", err))
                }</span>

                <span class="cov9" title="34">logger.Info("~~~~~~~~~~~~~ COMPLETED: custom transfer ~~~~~~~~~~~~~")
                return nil</span>

        },
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package transferref

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

var (
        drsClient client.DRSClient
        sConfig   sonic.API = sonic.ConfigFastest
)

// TODO: used for AnvIL use case, requires implementation
var Cmd = &amp;cobra.Command{
        Use:   "transfer-ref",
        Short: "[RUN VIA GIT LFS] handle transfers of existing DRS object into git during git push",
        Long:  "[RUN VIA GIT LFS] custom transfer mechanism to pull LFS files during git lfs pull. Does nothing on push.",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="2">{
                //setup logging to file for debugging
                myLogger := drslog.GetLogger()

                myLogger.Info("~~~~~~~~~~~~~ START: custom anvil transfer ~~~~~~~~~~~~~")

                scanner := bufio.NewScanner(os.Stdin)
                encoder := encoder.NewStreamEncoder(os.Stdout)

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("Error loading config: %v", err))
                        return err
                }</span>

                <span class="cov10" title="2">var remoteName string

                // Read the first (init) message outside the main loop
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        // No OID yet, so pass empty string
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov10" title="2">var initMsg map[string]any
                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;initMsg); err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("error decoding initial JSON message: %s", err))
                        return err
                }</span>

                // Handle "init" event and extract remote
                <span class="cov10" title="2">if evt, ok := initMsg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov10" title="2">{
                        // if no remote name specified, use default remote
                        defaultRemote, err := cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                                lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                                return err
                        }</span>
                        <span class="cov10" title="2">remoteName = string(defaultRemote)
                        myLogger.Debug(fmt.Sprintf("Initializing connection, remote not specified  using default: %s", remoteName))

                        // Respond with an empty json object via stdout
                        encoder.Encode(struct{}{})</span>
                } else<span class="cov0" title="0"> {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%v'", initMsg["event"])
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov10" title="2">drsClient, err = cfg.GetRemoteClient(config.Remote(remoteName), myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Error(fmt.Sprintf("Error creating indexd client: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        return err
                }</span>

                <span class="cov10" title="2">for scanner.Scan() </span><span class="cov1" title="1">{
                        var msg map[string]any
                        err := sConfig.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil </span><span class="cov0" title="0">{
                                myLogger.Debug(fmt.Sprintf("error decoding JSON: %s", err))
                                continue</span>
                        }
                        <span class="cov1" title="1">myLogger.Debug(fmt.Sprintf("Received message: %s", msg))

                        // Example: handle only "init" event
                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "init" </span><span class="cov0" title="0">{
                                // Log for debugging
                                myLogger.Debug(fmt.Sprintf("Handling init: %s", msg))

                                // Respond with an empty json object via stdout
                                encoder.Encode(struct{}{})
                                myLogger.Debug("Responding to init with empty object")
                        }</span> else<span class="cov1" title="1"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" </span><span class="cov0" title="0">{
                                // Handle download event
                                myLogger.Debug(fmt.Sprintf("Handling download event: %s", msg))

                                // get download message
                                var downloadMsg lfs.DownloadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 400, errMsg)
                                        continue</span>
                                }

                                // call DRS Downloader via downloadFile
                                <span class="cov0" title="0">dstPath, err := downloadFile(config.Remote(remoteName), downloadMsg.Oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v\n", downloadMsg.Oid, err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, downloadMsg.Oid, 500, errMsg)
                                        continue</span>
                                }

                                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Downloaded file for OID %s", downloadMsg.Oid))

                                // send success message back
                                myLogger.Debug(fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   downloadMsg.Oid,
                                        Path:  dstPath,
                                }
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov1" title="1"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" </span><span class="cov0" title="0">{
                                // Handle upload event
                                myLogger.Info(fmt.Sprintf("Handling upload event: %s", msg))
                                myLogger.Info("skipping upload, just registering existing DRS object")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.WriteErrorMessage(encoder, uploadMsg.Oid, 400, errMsg)
                                }</span>
                                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Got UploadMessage: %+v", uploadMsg))

                                // send success message back
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   uploadMsg.Oid,
                                }
                                myLogger.Info(fmt.Sprintf("Complete message: %+v", completeMsg))
                                encoder.Encode(completeMsg)</span>
                        } else<span class="cov1" title="1"> if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" </span><span class="cov1" title="1">{
                                // Handle terminate event
                                myLogger.Debug(fmt.Sprintf("terminate event received: %s", msg))
                        }</span>
                }

                <span class="cov10" title="2">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("stdin error: %s", err))
                }</span>

                <span class="cov10" title="2">myLogger.Info("~~~~~~~~~~~~~ COMPLETED: custom anvil transfer ~~~~~~~~~~~~~")

                return nil</span>
        },
}

func downloadFile(remote config.Remote, sha string) (string, error) <span class="cov0" title="0">{
        myLogger := drslog.GetLogger()

        myLogger.Debug(fmt.Sprintf("Downloading file for sha %s", sha))

        // get terra project
        cfg, err := config.LoadConfig() // should this be handled only via indexd client?
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>

        <span class="cov0" title="0">cli, err := cfg.GetRemoteClient(remote, myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">terraProject := cli.GetProjectId()

        filePath, err := drsmap.GetObjectPath(common.DRS_REF_DIR, sha)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting object path for sha %s: %v", sha, err)
        }</span>
        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("File path for sha %s: %s", sha, filePath))

        // get DRS URI in the second line of the file
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        myLogger.Debug(fmt.Sprintf("Opened file %s for reading", filePath))

        scanner := bufio.NewScanner(file)
        var drsUri string
        lineNum := 0
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNum++
                line := scanner.Text()
                myLogger.Debug(fmt.Sprintf("Reading line %d: %s", lineNum, line))
                if lineNum == 2 </span><span class="cov0" title="0">{
                        // second line should be the DRS URI
                        drsUri = strings.TrimSpace(line)
                        myLogger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
                        break</span>
                }
        }

        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
        if drsUri == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error: file %s does not contain a valid DRS URI in the second line", filePath)
        }</span>
        <span class="cov0" title="0">drsObj, err := drsClient.GetObject(context.Background(), drsUri)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error fetching DRS object for URI %s: %v", drsUri, err)
        }</span>
        <span class="cov0" title="0">if drsObj == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no DRS object found for URI %s", drsUri)
        }</span>

        <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("DRS Object fetched: %+v", drsObj))

        // call DRS downloader as a binary, redirect output to log file
        logFile, err := os.OpenFile(common.DRS_LOG_FILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error opening log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        //TODO: This should be done in the DRSClient code
        // download file, make sure its name is the sha
        dstPath, err := drsmap.GetObjectPath(common.LFS_OBJS_PATH, sha)
        dstDir := filepath.Dir(dstPath)
        cmd := exec.Command("drs_downloader", "terra", "--user-project", terraProject, "--manifest-path", filePath, "--destination-dir", dstDir)

        // write command to log file
        logFile.WriteString(fmt.Sprintf("Running command: %s\n", cmd.String()))

        cmd.Stdout = logFile
        cmd.Stderr = logFile
        cmdOut, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error running drs_downloader for sha %s: %s", sha, cmdOut)
        }</span>

        //rename file to sha
        <span class="cov0" title="0">tmpPath := filepath.Join(dstDir, drsObj.Name)
        err = os.Rename(tmpPath, dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error renaming downloaded file from %s to %s: %v", tmpPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return dstPath, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package version

import (
        "fmt"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Cmd represents the "version" command
var Cmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Get version",
        Long:  ``,
        Run: func(cmd *cobra.Command, args []string) <span class="cov4" title="5">{
                fmt.Println("git-drs", buildVersion())
        }</span>,
}

func buildVersion() string <span class="cov4" title="6">{
        tag := ""
        commit := ""
        if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov4" title="6">{
                if info.Main.Version != "" &amp;&amp; info.Main.Version != "(devel)" </span><span class="cov0" title="0">{
                        tag = info.Main.Version
                }</span>
                <span class="cov4" title="6">for _, setting := range info.Settings </span><span class="cov10" title="72">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                commit = setting.Value</span>
                        case "vcs.tag":<span class="cov0" title="0">
                                if tag == "" </span><span class="cov0" title="0">{
                                        tag = setting.Value
                                }</span>
                        }
                }
        }

        <span class="cov4" title="6">commitShort := commit
        if len(commitShort) &gt; 7 </span><span class="cov0" title="0">{
                commitShort = commitShort[:7]
        }</span>

        <span class="cov4" title="6">switch </span>{
        case tag != "" &amp;&amp; commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s", tag, commitShort)</span>
        case tag != "":<span class="cov0" title="0">
                return tag</span>
        case commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("dev-%s", commitShort)</span>
        default:<span class="cov4" title="6">
                return "dev-unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package common

// AddUnique appends items from 'toAdd' to 'existing' only if they're not already present.
// Returns the updated slice with unique items.
func AddUnique[T comparable](existing []T, toAdd []T) []T <span class="cov1" title="1">{
        // seen map uses struct{} as the value for memory efficiency
        seen := make(map[T]struct{}, len(existing))

        // Populate the set with existing items
        for _, item := range existing </span><span class="cov10" title="2">{
                seen[item] = struct{}{}
        }</span>

        <span class="cov1" title="1">for _, item := range toAdd </span><span class="cov10" title="2">{
                // check if item not yet in the set
                if _, found := seen[item]; !found </span><span class="cov1" title="1">{
                        existing = append(existing, item)
                        // Add the new unique item to the set
                        seen[item] = struct{}{}
                }</span>
        }
        <span class="cov1" title="1">return existing</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package common

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
)

// PromptForConfirmation displays a prompt and reads user input to confirm an operation.
// Returns nil if the response matches expectedResponse, error otherwise.
// If caseSensitive is false, comparison is case-insensitive.
func PromptForConfirmation(w io.Writer, prompt string, expectedResponse string, caseSensitive bool) error <span class="cov10" title="2">{
        fmt.Fprintf(w, "%s: ", prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading confirmation: %v", err)
        }</span>

        <span class="cov10" title="2">response = strings.TrimSpace(response)
        if !caseSensitive </span><span class="cov1" title="1">{
                response = strings.ToLower(response)
                expectedResponse = strings.ToLower(expectedResponse)
        }</span>

        <span class="cov10" title="2">if response != expectedResponse </span><span class="cov1" title="1">{
                return fmt.Errorf("operation cancelled: confirmation did not match")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DisplayWarningHeader writes a formatted warning header to the writer
func DisplayWarningHeader(w io.Writer, operation string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\n  WARNING: You are about to %s\n\n", operation)
}</span>

// DisplayField writes a formatted key-value field to the writer
func DisplayField(w io.Writer, key, value string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "%-11s %s\n", key+":", value)
}</span>

// DisplayFooter writes the standard "cannot be undone" footer to the writer
func DisplayFooter(w io.Writer) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\nThis action CANNOT be undone.\n\n")
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "fmt"
        "log/slog"
        "strings"

        "github.com/calypr/data-client/g3client"
        "github.com/calypr/git-drs/client"
        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/gitrepo"
        "github.com/go-git/go-git/v5"
)

// RemoteType represents the type of server being initialized
type RemoteType string
type Remote string

const (
        ORIGIN = "origin"

        Gen3ServerType  RemoteType = "gen3"
        AnvilServerType RemoteType = "anvil"
)

func AllRemoteTypes() []RemoteType <span class="cov5" title="8">{
        return []RemoteType{Gen3ServerType, AnvilServerType}
}</span>

func IsValidRemoteType(mode string) error <span class="cov3" title="4">{
        modeOptions := make([]string, len(AllRemoteTypes()))
        for i, m := range AllRemoteTypes() </span><span class="cov5" title="8">{
                modeOptions[i] = string(m)
        }</span>

        <span class="cov3" title="4">for _, validMode := range modeOptions </span><span class="cov5" title="7">{
                if mode == string(validMode) </span><span class="cov2" title="2">{
                        return nil
                }</span>
        }

        <span class="cov2" title="2">return fmt.Errorf("invalid mode '%s'. Valid options are: %s", mode, strings.Join(modeOptions, ", "))</span>
}

// DRSRemote holds pointers to remote types
type DRSRemote interface {
        GetProjectId() string
        GetEndpoint() string
        GetBucketName() string
        GetClient(remoteName string, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error)
}

type RemoteSelect struct {
        Gen3  *indexd.Gen3Remote
        Anvil *anvil_client.AnvilRemote
}

// Config holds the overall config structure
type Config struct {
        DefaultRemote Remote
        Remotes       map[Remote]RemoteSelect
}

func (c Config) GetRemoteClient(remote Remote, logger *slog.Logger, opts ...g3client.Option) (client.DRSClient, error) <span class="cov8" title="42">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("GetRemoteClient no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov8" title="40">if x.Gen3 != nil </span><span class="cov8" title="40">{
                return x.Gen3.GetClient(string(remote), logger, opts...)
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil.GetClient(string(remote), logger, opts...)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("no valid remote configuration found for current remote: %s", remote)</span>
}

func (c Config) GetRemote(remote Remote) DRSRemote <span class="cov0" title="0">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if x.Gen3 != nil </span><span class="cov0" title="0">{
                return x.Gen3
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDefaultRemote returns the configured default remote with validation
func (c Config) GetDefaultRemote() (Remote, error) <span class="cov9" title="47">{
        if c.DefaultRemote == "" </span><span class="cov4" title="6">{
                return "", fmt.Errorf(
                        "no default remote configured.\n"+
                                "Set one with: git drs remote set &lt;name&gt;\n"+
                                "Available remotes: %v",
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov8" title="41">if _, ok := c.Remotes[c.DefaultRemote]; !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "default remote '%s' not found in configuration.\n"+
                                "Available remotes: %v",
                        c.DefaultRemote,
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov8" title="41">return c.DefaultRemote, nil</span>
}

// GetRemoteOrDefault returns the specified remote if provided, otherwise returns the default remote
func (c Config) GetRemoteOrDefault(remote string) (Remote, error) <span class="cov4" title="6">{
        if remote != "" </span><span class="cov2" title="2">{
                return Remote(remote), nil
        }</span>
        <span class="cov3" title="4">return c.GetDefaultRemote()</span>
}

// listRemoteNames returns a slice of all remote names for error messages
func (c Config) listRemoteNames() []string <span class="cov4" title="6">{
        names := make([]string, 0, len(c.Remotes))
        for name := range c.Remotes </span><span class="cov0" title="0">{
                names = append(names, string(name))
        }</span>
        <span class="cov4" title="6">return names</span>
}

// getRepo opens the current git repository
func getRepo() (*git.Repository, error) <span class="cov10" title="74">{
        return gitrepo.GetRepo()
}</span>

// UpdateRemote updates and saves configuration using go-git
func UpdateRemote(name Remote, remote RemoteSelect) (*Config, error) <span class="cov4" title="5">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update drs.remote.&lt;name&gt; subsection
        <span class="cov4" title="5">subsection := fmt.Sprintf("remote.%s", name)

        if remote.Gen3 != nil </span><span class="cov4" title="5">{
                conf.Raw.Section("drs").Subsection(subsection).SetOption("type", "gen3")
                conf.Raw.Section("drs").Subsection(subsection).SetOption("endpoint", remote.Gen3.Endpoint)
                conf.Raw.Section("drs").Subsection(subsection).SetOption("project", remote.Gen3.ProjectID)
                conf.Raw.Section("drs").Subsection(subsection).SetOption("bucket", remote.Gen3.Bucket)
        }</span> else<span class="cov0" title="0"> if remote.Anvil != nil </span><span class="cov0" title="0">{
                conf.Raw.Section("drs").Subsection(subsection).SetOption("type", "anvil")
        }</span>

        // Set default remote if not set
        <span class="cov4" title="5">defaultRemote := conf.Raw.Section("drs").Option("default-remote")
        if defaultRemote == "" </span><span class="cov4" title="5">{
                conf.Raw.Section("drs").SetOption("default-remote", string(name))
        }</span>

        // Save config
        <span class="cov4" title="5">if err := repo.Storer.SetConfig(conf); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="5">return LoadConfig()</span>
}

// LoadConfig loads configuration using go-git
func LoadConfig() (*Config, error) <span class="cov9" title="63">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="63">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="63">cfg := &amp;Config{
                Remotes: make(map[Remote]RemoteSelect),
        }

        drsSection := conf.Raw.Section("drs")
        cfg.DefaultRemote = Remote(drsSection.Option("default-remote"))

        for _, subsection := range drsSection.Subsections </span><span class="cov9" title="50">{
                // Expect subsection name "remote.&lt;name&gt;"
                parts := strings.SplitN(subsection.Name, ".", 2)
                if len(parts) != 2 || parts[0] != "remote" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov9" title="50">remoteName := Remote(parts[1])
                rs := RemoteSelect{}

                remoteType := subsection.Option("type")
                if remoteType == "gen3" || remoteType == "" </span><span class="cov9" title="50">{ // Default to gen3 for compatibility/inference
                        rs.Gen3 = &amp;indexd.Gen3Remote{
                                Endpoint:  subsection.Option("endpoint"),
                                ProjectID: subsection.Option("project"),
                                Bucket:    subsection.Option("bucket"),
                        }
                }</span> else<span class="cov0" title="0"> if remoteType == "anvil" </span><span class="cov0" title="0">{
                        rs.Anvil = &amp;anvil_client.AnvilRemote{}
                }</span>

                <span class="cov9" title="50">cfg.Remotes[remoteName] = rs</span>
        }

        <span class="cov9" title="63">return cfg, nil</span>
}

func CreateEmptyConfig() error <span class="cov4" title="5">{
        // With go-git, we just verify we are in a repo?
        // Existing behavior was ensuring file existence.
        // We can check if we can open the repo.
        _, err := getRepo()
        return err
}</span>

func GetProjectId(remote Remote) (string, error) <span class="cov0" title="0">{
        cfg, err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>
        <span class="cov0" title="0">rmt := cfg.GetRemote(remote)
        if rmt == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov0" title="0">return rmt.GetProjectId(), nil</span>
}

// SaveConfig writes the configuration using go-git
func SaveConfig(cfg *Config) error <span class="cov1" title="1">{
        repo, err := getRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if cfg.DefaultRemote != "" </span><span class="cov1" title="1">{
                conf.Raw.Section("drs").SetOption("default-remote", string(cfg.DefaultRemote))
        }</span>

        <span class="cov1" title="1">return repo.Storer.SetConfig(conf)</span>
}

// GetGitConfigInt reads an integer value from git config
// getGitConfigValue retrieves a value from git config by key
</pre>
		
		<pre class="file" id="file34" style="display: none">// go
package drslog

import (
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"

        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/gitrepo"

        "github.com/calypr/data-client/logs"
)

var globalLogger *slog.Logger
var globalLogFile io.Closer
var globalLoggerOnce sync.Once
var globalLoggerMu sync.RWMutex
var GIT_TRANSFER_TRACE int
var modulePathSuffixOnce sync.Once
var modulePathSuffixValue string
var repoRootOnce sync.Once
var repoRootValue string

const (
        levelDebugStr   = "DEBUG"
        levelInfoStr    = "INFO"
        levelWarnStr    = "WARN"
        levelWarningStr = "WARNING"
        levelErrorStr   = "ERROR"
)

// init initializes package-level settings from the environment.
//
// Documented calls inside:
//   - os.Getenv("GIT_TRANSFER_TRACE")
//     Reads environment variable to optionally enable trace logging.
//   - strconv.Atoi(envValue)
//     Parses the numeric env value.
//
// Side-effects:
// - sets package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - runtime automatically invokes init(); no external callers needed.
func init() <span class="cov6" title="69">{
        GIT_TRANSFER_TRACE = 0
        if envValue := os.Getenv("GIT_TRANSFER_TRACE"); envValue != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(envValue); err == nil </span><span class="cov0" title="0">{
                        GIT_TRANSFER_TRACE = parsed
                }</span>
        }
}

// TraceEnabled returns whether transfer trace logging is enabled.
//
// Documented calls inside:
// - reads package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - logging setup and callsites that want to be verbose only when trace is enabled.
func TraceEnabled() bool <span class="cov6" title="53">{
        return GIT_TRANSFER_TRACE == 1
}</span>

// NewLogger creates and installs a global slog.Logger that writes to the specified file
// and optionally to stderr. It is safe to call multiple times; the first successful call
// establishes the global logger.
//
// Documented calls inside:
//   - projectdir.DRS_DIR usage
//     Uses projectdir.DRS_DIR to create log directory.
//   - os.MkdirAll(projectdir.DRS_DIR, 0755)
//     Ensures the directory exists; returns error on failure.
//   - filepath.Join(projectdir.DRS_DIR, "git-drs.log")
//     Constructs default filename when none provided.
//   - os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
//     Opens/creates the log file (returns *os.File).
//   - io.MultiWriter(writers...)
//     Combines file and optionally os.Stderr into a single Writer.
//   - slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{...})
//     Creates the text handler for slog that writes to the combined writer.
//   - slog.New(handler).With("pid", os.Getpid())
//     Builds the logger and attaches pid attribute.
//   - globalLoggerMu.Lock()/Unlock()
//     Protects globalLogFile and globalLogger assignment.
//
// Side-effects:
// - sets package-level globalLogger and globalLogFile.
// Typical callers:
// - application startup code that wants to initialize logging (e.g. main).
func NewLogger(filename string, logToStderr bool) (*slog.Logger, error) <span class="cov6" title="53">{
        var writers []io.Writer

        if filename == "" </span><span class="cov6" title="52">{
                // create drs dir if it doesn't exist
                if err := os.MkdirAll(common.DRS_DIR, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov6" title="52">filename = filepath.Join(common.DRS_DIR, "git-drs.log")</span>
        }

        <span class="cov6" title="53">file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="53">writers = append(writers, file)

        if logToStderr </span><span class="cov6" title="47">{
                writers = append(writers, os.Stderr)
        }</span>

        <span class="cov6" title="53">multiWriter := io.MultiWriter(writers...)

        handler := slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{
                AddSource:   true,
                Level:       resolveLogLevel(),
                ReplaceAttr: replaceSourceAttr,
        })
        core := slog.New(logs.NewProgressHandler(handler)).With("pid", os.Getpid())

        globalLoggerMu.Lock()
        globalLogFile = file
        globalLogger = core
        globalLoggerMu.Unlock()

        return globalLogger, nil</span>
}

// GetLogger returns the global logger, initializing a no-op logger on first access.
//
// Documented calls inside:
//   - globalLoggerOnce.Do(func() { ... })
//     Ensures initialization runs only once.
//   - NewNoOpLogger()
//     Creates a logger that discards output if no global logger was set.
//
// Typical callers:
// - any package code that needs access to the package-level logger.
func GetLogger() *slog.Logger <span class="cov6" title="55">{
        globalLoggerOnce.Do(func() </span><span class="cov6" title="51">{
                if globalLogger == nil </span><span class="cov3" title="8">{
                        globalLogger = NewNoOpLogger()
                }</span>
        })
        <span class="cov6" title="55">return globalLogger</span>
}

// Close closes the active log file if one was opened.
//
// Documented calls inside:
//   - globalLoggerMu.Lock()/Unlock()
//     Protects access to globalLogFile.
//   - globalLogFile.Close()
//     Closes the underlying file and returns any error.
//
// Side-effects:
// - sets globalLogFile to nil.
// Typical callers:
// - application shutdown code or tests that want to release file handles.
func Close() error <span class="cov1" title="2">{
        globalLoggerMu.Lock()
        defer globalLoggerMu.Unlock()
        if globalLogFile != nil </span><span class="cov1" title="2">{
                err := globalLogFile.Close()

                globalLogFile = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewNoOpLogger returns a logger that discards all output.
//
// Documented calls inside:
//   - slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{Level: slog.LevelDebug})
//     Creates a text handler writing to io.Discard.
//   - slog.New(handler)
//     Builds the logger.
//
// Typical callers:
// - GetLogger on first access when no global logger was configured.
// - tests that need a deterministic logger that produces no output.
func NewNoOpLogger() *slog.Logger <span class="cov4" title="13">{
        handler := slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        return slog.New(logs.NewProgressHandler(handler))
}</span>

// resolveLogLevel determines the effective log level.
//
// Documented calls inside:
//   - TraceEnabled()
//     If trace is enabled, returns Debug level immediately.
//   - readLogLevelFromGitConfig()
//     Attempts to read configured level from git config; returns level and ok.
//   - defaults to slog.LevelInfo when nothing else matches.
//
// Typical callers:
// - NewLogger -&gt; used when creating slog.HandlerOptions.Level.
func resolveLogLevel() slog.Level <span class="cov6" title="53">{
        if TraceEnabled() </span><span class="cov0" title="0">{
                return slog.LevelDebug
        }</span>

        <span class="cov6" title="53">level, ok := readLogLevelFromGitConfig()
        if ok </span><span class="cov0" title="0">{
                return level
        }</span>

        <span class="cov6" title="53">return slog.LevelInfo</span>
}

// readLogLevelFromGitConfig queries git configuration for a custom log level.
//
// Documented calls inside:
//   - exec.Command("git", "config", "--get", "lfs.customtransfer.drs.loglevel")
//     Constructs the command to query git config.
//   - cmd.Output()
//     Executes the command and returns raw output or an error.
//   - strings.TrimSpace(string(output))
//     Trims whitespace/newlines from git output.
//   - parseLogLevel(value)
//     Parses the trimmed value into a slog.Level.
//
// Behavior:
// - On any error or empty output, returns (slog.LevelInfo, false) to indicate no valid config was found.
// Typical callers:
// - resolveLogLevel when initializing a logger.
func readLogLevelFromGitConfig() (slog.Level, bool) <span class="cov6" title="53">{
        val, err := gitrepo.GetGitConfigString("lfs.customtransfer.drs.loglevel")
        if err != nil || val == "" </span><span class="cov6" title="53">{
                return slog.LevelInfo, false
        }</span>

        <span class="cov0" title="0">parsed, ok := parseLogLevel(val)
        if !ok </span><span class="cov0" title="0">{
                return slog.LevelInfo, false
        }</span>
        <span class="cov0" title="0">return parsed, true</span>
}

// parseLogLevel maps textual level names to slog.Level.
//
// Documented calls inside:
//   - strings.ToUpper(strings.TrimSpace(value))
//     Normalizes the input for comparison.
//   - switch on normalized value to return corresponding slog.Level constants.
//
// Typical callers:
// - readLogLevelFromGitConfig
// - resolveLogLevel indirectly.

func parseLogLevel(value string) (slog.Level, bool) <span class="cov0" title="0">{
        switch strings.ToUpper(strings.TrimSpace(value)) </span>{
        case levelDebugStr:<span class="cov0" title="0">
                return slog.LevelDebug, true</span>
        case levelInfoStr:<span class="cov0" title="0">
                return slog.LevelInfo, true</span>
        case levelWarnStr, levelWarningStr:<span class="cov0" title="0">
                return slog.LevelWarn, true</span>
        case levelErrorStr:<span class="cov0" title="0">
                return slog.LevelError, true</span>
        default:<span class="cov0" title="0">
                return slog.LevelDebug, false</span>
        }
}

// replaceSourceAttr rewrites the slog.Source attr to a shorter path suitable for logs.
//
// Documented calls inside:
//   - attr.Key comparison with slog.SourceKey
//     Determines whether the attribute is the source attribute.
//   - attr.Value.Any().(*slog.Source)
//     Retrieves and type-asserts the attribute value to *slog.Source.
//   - formatSourcePath(source.File)
//     Formats the file path according to module or repo root heuristics.
//   - attr.Value = slog.AnyValue(source)
//     Replaces attribute value with modified source.
//
// Typical callers:
// - passed as ReplaceAttr to slog.HandlerOptions in NewLogger.
func replaceSourceAttr(_ []string, attr slog.Attr) slog.Attr <span class="cov10" title="808">{
        if attr.Key != slog.SourceKey </span><span class="cov9" title="621">{
                return attr
        }</span>
        <span class="cov8" title="187">source, ok := attr.Value.Any().(*slog.Source)
        if !ok || source == nil </span><span class="cov0" title="0">{
                return attr
        }</span>
        <span class="cov8" title="187">source.File = formatSourcePath(source.File)
        attr.Value = slog.AnyValue(source)
        return attr</span>
}

// formatSourcePath shortens file paths using module suffix or repo root heuristics.
//
// Documented calls inside:
//   - filepath.ToSlash(path)
//     Normalizes OS-specific separators to forward slashes.
//   - modulePathSuffix()
//     Gets the module path suffix (derived from build info).
//   - strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
//     Normalizes module suffix.
//   - strings.Index(pathSlash, "/"+moduleSuffixSlash+"/")
//     Searches for module suffix within the path to trim leading segments.
//   - strings.HasPrefix(pathSlash, moduleSuffixSlash+"/")
//     Handles case where path already starts with module suffix.
//   - repoRootPath()
//     Attempts to resolve the repository root (by locating go.mod).
//   - strings.HasPrefix(pathSlash, repoRootSlash+"/")
//     Trims repository-root prefix to produce a relative path.
//   - filepath.ToSlash(filepath.Join(moduleSuffix, rel))
//     Reconstructs path when combining module suffix and relative path.
//
// Typical callers:
// - replaceSourceAttr when rewriting source file paths for log output.
func formatSourcePath(path string) string <span class="cov8" title="187">{
        pathSlash := filepath.ToSlash(path)
        moduleSuffix := modulePathSuffix()
        if moduleSuffix != "" </span><span class="cov8" title="187">{
                moduleSuffixSlash := strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
                if idx := strings.Index(pathSlash, "/"+moduleSuffixSlash+"/"); idx &gt;= 0 </span><span class="cov7" title="134">{
                        return pathSlash[idx+1:]
                }</span>
                <span class="cov6" title="53">if strings.HasPrefix(pathSlash, moduleSuffixSlash+"/") </span><span class="cov0" title="0">{
                        return pathSlash
                }</span>
        }
        <span class="cov6" title="53">repoRoot := repoRootPath()
        if repoRoot != "" </span><span class="cov6" title="53">{
                repoRootSlash := filepath.ToSlash(repoRoot)
                if strings.HasPrefix(pathSlash, repoRootSlash+"/") </span><span class="cov0" title="0">{
                        rel := strings.TrimPrefix(pathSlash, repoRootSlash+"/")
                        if moduleSuffix != "" </span><span class="cov0" title="0">{
                                return filepath.ToSlash(filepath.Join(moduleSuffix, rel))
                        }</span>
                        <span class="cov0" title="0">return rel</span>
                }
        }
        <span class="cov6" title="53">return pathSlash</span>
}

// modulePathSuffix returns the module path suffix derived from build info.
//
// Documented calls inside:
//   - runtime/debug.ReadBuildInfo()
//     Reads build info at runtime; used to extract Main.Path.
//   - strings.Split(info.Main.Path, "/")
//     Splits module path to drop the first element (typically hostname).
//
// Side-effects:
// - caches computed value via modulePathSuffixOnce.
// Typical callers:
// - formatSourcePath to help shorten file paths.
func modulePathSuffix() string <span class="cov8" title="187">{
        modulePathSuffixOnce.Do(func() </span><span class="cov6" title="44">{
                if info, ok := debug.ReadBuildInfo(); ok &amp;&amp; info.Main.Path != "" </span><span class="cov6" title="44">{
                        parts := strings.Split(info.Main.Path, "/")
                        if len(parts) &gt; 1 </span><span class="cov6" title="44">{
                                modulePathSuffixValue = strings.Join(parts[1:], "/")
                        }</span>
                }
        })
        <span class="cov8" title="187">return modulePathSuffixValue</span>
}

// repoRootPath attempts to locate the repository root by searching for go.mod upward.
//
// Documented calls inside:
//   - os.Getwd()
//     Retrieves current working directory as a starting point.
//   - os.Stat(filepath.Join(dir, "go.mod"))
//     Checks for presence of go.mod in each directory while walking up.
//   - filepath.Dir(dir)
//     Moves up one directory level on each iteration.
//
// Side-effects:
// - caches resolved repo root via repoRootOnce.
// Typical callers:
// - formatSourcePath when computing shorter file paths for logs.
func repoRootPath() string <span class="cov6" title="53">{
        repoRootOnce.Do(func() </span><span class="cov6" title="42">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="42">dir := cwd
                for </span><span class="cov7" title="168">{
                        if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov6" title="42">{
                                repoRootValue = dir
                                return
                        }</span>
                        <span class="cov7" title="126">parent := filepath.Dir(dir)
                        if parent == dir </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov7" title="126">dir = parent</span>
                }
        })
        <span class="cov6" title="53">return repoRootValue</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package drsmap

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/g3client"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/data-client/upload"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/lfs"
        "github.com/go-git/go-git/v5"
        "github.com/google/uuid"
)

// execCommand is a variable to allow mocking in tests
var execCommand = exec.Command
var execCommandContext = exec.CommandContext

var NAMESPACE = uuid.NewMD5(uuid.NameSpaceURL, []byte("calypr.org"))

type LfsDryRunSpec struct {
        Remote string // e.g. "origin"
        Ref    string // e.g. "refs/heads/main" or "HEAD"
}

// RunLfsPushDryRun executes: git lfs push --dry-run &lt;remote&gt; &lt;ref&gt;
func RunLfsPushDryRun(ctx context.Context, repoDir string, spec LfsDryRunSpec, logger *slog.Logger) (string, error) <span class="cov4" title="5">{
        if spec.Remote == "" || spec.Ref == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing remote or ref")
        }</span>

        // Debug-print the command to stderr
        <span class="cov4" title="5">fullCmd := []string{"git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref}
        logger.Debug(fmt.Sprintf("running command: %v", fullCmd))

        cmd := execCommandContext(ctx, "git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref)
        cmd.Dir = repoDir

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        out := stdout.String()
        if err != nil </span><span class="cov0" title="0">{
                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span>
                <span class="cov0" title="0">return out, fmt.Errorf("git lfs push --dry-run failed: %s", msg)</span>
        }
        <span class="cov4" title="5">return out, nil</span>
}

// output of git lfs ls-files
type LfsLsOutput struct {
        Files []LfsFileInfo `json:"files"`
}

// LfsFileInfo represents the information about an LFS file
type LfsFileInfo struct {
        Name       string `json:"name"`
        Size       int64  `json:"size"`
        Checkout   bool   `json:"checkout"`
        Downloaded bool   `json:"downloaded"`
        OidType    string `json:"oid_type"`
        Oid        string `json:"oid"`
        Version    string `json:"version"`
}

func PushLocalDrsObjects(drsClient client.DRSClient, gen3Client g3client.Gen3Interface, bucketName string, upsert bool, myLogger *slog.Logger) error <span class="cov0" title="0">{
        // Gather all objects in .git/drs/lfs/objects store
        drsLfsObjs, err := lfs.GetDrsLfsObjects(myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make this a map if it does not exist when hitting the server
        <span class="cov0" title="0">sums := make([]*hash.Checksum, 0)
        for _, obj := range drsLfsObjs </span><span class="cov0" title="0">{
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span><span class="cov0" title="0">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov0" title="0">{
                                sums = append(sums, &amp;hash.Checksum{
                                        Checksum: sum,
                                        Type:     hash.ChecksumTypeSHA256,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">outobjs := map[string]*drs.DRSObject{}
        for _, sum := range sums </span><span class="cov0" title="0">{
                records, err := drsClient.GetObjectByHash(context.Background(), sum)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                        continue</span>
                }
                <span class="cov0" title="0">found := false
                // Warning: The loop overwrites map entries if multiple records have the same SHA256 hash.
                // If there are multiple records with SHA256 checksums, only the last one will be stored in the map
                for i, rec := range records </span><span class="cov0" title="0">{
                        if rec.Checksums.SHA256 != "" </span><span class="cov0" title="0">{
                                found = true
                                outobjs[rec.Checksums.SHA256] = &amp;records[i]
                        }</span>
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        outobjs[sum.Checksum] = nil
                }</span>
        }

        <span class="cov0" title="0">for drsObjKey := range outobjs </span><span class="cov0" title="0">{
                val, ok := drsLfsObjs[drsObjKey]
                if !ok </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Drs record not found in sha256 map %s", drsObjKey))
                }</span>
                <span class="cov0" title="0">if _, statErr := os.Stat(val.Name); os.IsNotExist(statErr) </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Error: Object record found locally, but file does not exist locally. Registering Record %s", val.Name))
                        _, err = drsClient.RegisterRecord(context.Background(), val)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                } else<span class="cov0" title="0"> {
                        filePath, err := GetObjectPath(common.LFS_OBJS_PATH, drsObjKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">_, err = upload.RegisterAndUploadFile(
                                context.Background(),
                                gen3Client,
                                val,
                                filePath,
                                bucketName,
                                upsert,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func PullRemoteDrsObjects(drsClient client.DRSClient, logger *slog.Logger) error <span class="cov1" title="1">{
        objChan, err := drsClient.ListObjectsByProject(context.Background(), drsClient.GetProjectId())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">writtenObjs := 0
        for drsObj := range objChan </span><span class="cov1" title="1">{
                if drsObj.Object == nil </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("OBJ is nil: %#v, continuing...", drsObj))
                        continue</span>
                }
                <span class="cov1" title="1">sumMap := hash.ConvertHashInfoToMap(drsObj.Object.Checksums)
                if len(sumMap) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: drs Object '%s' does not contain a checksum", drsObj.Object.Id)
                }</span>
                <span class="cov1" title="1">var drsObjPath, oid string = "", ""
                for sumType, sum := range sumMap </span><span class="cov1" title="1">{
                        if sumType == hash.ChecksumTypeSHA256.String() </span><span class="cov1" title="1">{
                                oid = sum
                                drsObjPath, err = GetObjectPath(common.DRS_OBJS_PATH, oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error getting object path for oid %s: %v", oid, err)
                                }</span>
                        }
                }
                // Only write a record if there exists a proper checksum to use. Checksums besides sha256 are not used
                <span class="cov1" title="1">if drsObjPath != "" &amp;&amp; oid != "" </span><span class="cov1" title="1">{
                        writtenObjs++
                        // write drs objects to DRS_OBJS_PATH
                        err = WriteDrsObj(drsObj.Object, oid, drsObjPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error writing DRS object for oid %s: %v", oid, err)
                        }</span>
                }
        }
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Wrote %d new objs to object store", writtenObjs))
        return nil</span>
}

func UpdateDrsObjects(drsClient client.DRSClient, gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) error <span class="cov4" title="5">{

        logger.Debug("Update to DRS objects started")

        // get all lfs files
        lfsFiles, err := GetAllLfsFiles(gitRemoteName, gitRemoteLocation, branches, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting all LFS files: %v", err)
        }</span>

        // get project
        <span class="cov4" title="5">projectId := drsClient.GetProjectId()
        if projectId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no project configured: %v", err)
        }</span>

        // create a DRS object for each LFS file
        // which will be used at push-time
        <span class="cov4" title="5">for _, file := range lfsFiles </span><span class="cov4" title="5">{
                // check if indexd object already prepared, skip if so
                drsObjPath, err := GetObjectPath(common.DRS_OBJS_PATH, file.Oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
                }</span>
                <span class="cov4" title="5">if _, err := os.Stat(drsObjPath); err == nil </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("Skipping record creation, file %s with OID %s already exists in DRS objects path %s", file.Name, file.Oid, drsObjPath))
                        continue</span>
                }

                // if file is in cache, hasn't been committed to git or pushed to indexd
                // create a local DRS object for it
                // TODO: determine git to gen3 project hierarchy mapping (eg repo name to project ID)
                <span class="cov4" title="5">drsId := DrsUUID(projectId, file.Oid)
                // logger.Printf("File: %s, OID: %s, DRS ID: %s\n", file.Name, file.Oid, drsId)

                // get file info needed to create indexd record
                path, err := GetObjectPath(common.LFS_OBJS_PATH, file.Oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
                }</span>
                <span class="cov4" title="5">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: File %s does not exist in LFS objects path %s. Aborting", file.Name, path)
                }</span>

                <span class="cov4" title="5">drsObj, err := drsClient.BuildDrsObj(file.Name, file.Oid, file.Size, drsId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error building DRS object for oid %s: %v", file.Oid, err)
                }</span>

                // write drs objects to DRS_OBJS_PATH
                <span class="cov4" title="5">err = WriteDrsObj(drsObj, file.Oid, drsObjPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error writing DRS object for oid %s: %v", file.Oid, err)
                }</span>
                <span class="cov4" title="5">logger.Debug(fmt.Sprintf("Prepared File %s OID %s with DRS ID %s for commit", file.Name, file.Oid, drsObj.Id))</span>
        }

        <span class="cov4" title="5">return nil</span>
}

func WriteDrsObj(drsObj *drs.DRSObject, oid string, drsObjPath string) error <span class="cov5" title="7">{
        // get object bytes
        indexdObjBytes, err := sonic.ConfigFastest.Marshal(drsObj)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshalling indexd object for oid %s: %v", oid, err)
        }</span>
        <span class="cov5" title="7">if err := os.MkdirAll(filepath.Dir(drsObjPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating directory for %s: %v", drsObjPath, err)
        }</span>

        // write indexd obj to file as json
        <span class="cov5" title="7">err = os.WriteFile(drsObjPath, indexdObjBytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing %s: %v", drsObjPath, err)
        }</span>
        <span class="cov5" title="7">return nil</span>
}

func DrsUUID(projectId string, hash string) string <span class="cov7" title="16">{
        // create UUID based on project ID and hash
        hashStr := fmt.Sprintf("%s:%s", projectId, hash)
        return uuid.NewSHA1(NAMESPACE, []byte(hashStr)).String()
}</span>

// creates drsObject record from file
func DrsInfoFromOid(oid string) (*drs.DRSObject, error) <span class="cov4" title="5">{
        // unmarshal the DRS object
        path, err := GetObjectPath(common.DRS_OBJS_PATH, oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span>

        <span class="cov4" title="5">drsObjBytes, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov4" title="5">var drsObject drs.DRSObject
        err = sonic.ConfigFastest.Unmarshal(drsObjBytes, &amp;drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling DRS object for oid %s: %v", oid, err)
        }</span>

        <span class="cov4" title="5">return &amp;drsObject, nil</span>
}

func GetObjectPath(basePath string, oid string) (string, error) <span class="cov8" title="26">{
        // check that oid is a valid sha256 hash
        if len(oid) != 64 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("error: %s is not a valid sha256 hash", oid)
        }</span>

        <span class="cov8" title="25">return filepath.Join(basePath, oid[:2], oid[2:4], oid), nil</span>
}

////////////////
// LFS HELPERS /
////////////////

// checkIfLfsFile checks if a given file is tracked by Git LFS
// Returns true and file info if it's an LFS file, false otherwise
func CheckIfLfsFile(fileName string) (bool, *LfsFileInfo, error) <span class="cov2" title="2">{
        // Use git lfs ls-files -I to check if specific file is LFS tracked
        cmd := execCommand("git", "lfs", "ls-files", "-I", fileName, "--json")
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If git lfs ls-files returns error, the file is not LFS tracked
                return false, nil, nil
        }</span>

        // If output is empty, file is not LFS tracked
        <span class="cov2" title="2">if len(strings.TrimSpace(string(out))) == 0 </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        // Parse the JSON output
        <span class="cov2" title="2">var lfsOutput LfsLsOutput
        err = sonic.ConfigFastest.Unmarshal(out, &amp;lfsOutput)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("error unmarshaling git lfs ls-files output for %s: %v", fileName, err)
        }</span>

        // If no files in output, not LFS tracked
        <span class="cov2" title="2">if len(lfsOutput.Files) == 0 </span><span class="cov1" title="1">{
                return false, nil, nil
        }</span>

        // Convert to our LfsFileInfo struct
        <span class="cov1" title="1">file := lfsOutput.Files[0]
        lfsInfo := &amp;LfsFileInfo{
                Name:       file.Name,
                Size:       file.Size,
                Checkout:   file.Checkout,
                Downloaded: file.Downloaded,
                OidType:    file.OidType,
                Oid:        file.Oid,
                Version:    file.Version,
        }

        return true, lfsInfo, nil</span>
}

func getStagedFiles() ([]string, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">repo, err := git.PlainOpenWithOptions(cwd, &amp;git.PlainOpenOptions{DetectDotGit: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">status, err := wt.Status()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var stagedFiles []string
        for file, s := range status </span><span class="cov0" title="0">{
                if s.Staging == git.Added || s.Staging == git.Modified || s.Staging == git.Renamed || s.Staging == git.Copied </span><span class="cov0" title="0">{
                        stagedFiles = append(stagedFiles, file)
                }</span>
        }
        <span class="cov0" title="0">return stagedFiles, nil</span>
}

func GetRepoNameFromGit(remote string) (string, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">repo, err := git.PlainOpenWithOptions(cwd, &amp;git.PlainOpenOptions{DetectDotGit: true})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">rem, err := repo.Remote(remote)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">urls := rem.Config().URLs
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no URLs found for remote %s", remote)
        }</span>

        <span class="cov0" title="0">remoteURL := strings.TrimSpace(urls[0])
        repoName := strings.TrimSuffix(filepath.Base(remoteURL), ".git")
        return repoName, nil</span>
}

func GetAllLfsFiles(gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) (map[string]LfsFileInfo, error) <span class="cov4" title="5">{
        if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger is required")
        }</span>
        <span class="cov4" title="5">repoDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // no timeout for now
        <span class="cov4" title="5">ctx := context.Background()
        // If needed, can re-enable timeout
        // Set a timeout context for git commands, 3 minutes should be enough
        //ctx, cancel := context.WithTimeout(context.Background(), 180*time.Second)
        //defer cancel()

        if gitRemoteName == "" </span><span class="cov0" title="0">{
                gitRemoteName = "origin"
        }</span>
        <span class="cov4" title="5">if gitRemoteLocation != "" </span><span class="cov4" title="4">{
                logger.Debug(fmt.Sprintf("Using git remote %s at %s for LFS dry-run", gitRemoteName, gitRemoteLocation))
        }</span> else<span class="cov1" title="1"> {
                logger.Debug(fmt.Sprintf("Using git remote %s for LFS dry-run", gitRemoteName))
        }</span>

        <span class="cov4" title="5">refs := buildLfsRefs(branches)
        lfsFileMap := make(map[string]LfsFileInfo)
        for _, ref := range refs </span><span class="cov4" title="5">{
                spec := LfsDryRunSpec{
                        Remote: gitRemoteName,
                        Ref:    ref,
                }
                out, err := RunLfsPushDryRun(ctx, repoDir, spec, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov4" title="5">if err := addLfsFilesFromDryRun(out, repoDir, logger, lfsFileMap); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov4" title="5">return lfsFileMap, nil</span>
}

func buildLfsRefs(branches []string) []string <span class="cov4" title="5">{
        if len(branches) == 0 </span><span class="cov0" title="0">{
                return []string{"HEAD"}
        }</span>
        <span class="cov4" title="5">refs := make([]string, 0, len(branches))
        seen := make(map[string]struct{})
        for _, branch := range branches </span><span class="cov4" title="5">{
                branch = strings.TrimSpace(branch)
                if branch == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="5">ref := branch
                if branch != "HEAD" &amp;&amp; !strings.HasPrefix(branch, "refs/") </span><span class="cov4" title="5">{
                        ref = fmt.Sprintf("refs/heads/%s", branch)
                }</span>
                <span class="cov4" title="5">if _, ok := seen[ref]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="5">seen[ref] = struct{}{}
                refs = append(refs, ref)</span>
        }
        <span class="cov4" title="5">if len(refs) == 0 </span><span class="cov0" title="0">{
                return []string{"HEAD"}
        }</span>
        <span class="cov4" title="5">return refs</span>
}

func addLfsFilesFromDryRun(out, repoDir string, logger *slog.Logger, lfsFileMap map[string]LfsFileInfo) error <span class="cov4" title="5">{
        // Log when dry-run returns no output to help with debugging
        if strings.TrimSpace(out) == "" </span><span class="cov0" title="0">{
                logger.Debug("No LFS files to push (dry-run returned no output)")
                return nil
        }</span>

        // accept lowercase or uppercase hex
        <span class="cov4" title="5">sha256Re := regexp.MustCompile(`(?i)^[a-f0-9]{64}$`)

        for _, line := range strings.Split(strings.TrimSpace(string(out)), "\n") </span><span class="cov5" title="7">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="7">parts := strings.Fields(line)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="7">oid := parts[1]
                path := parts[len(parts)-1]

                // Validate OID looks like a SHA256 hex string.
                if !sha256Re.MatchString(oid) </span><span class="cov0" title="0">{
                        logger.Debug(fmt.Sprintf("skipping LFS line with invalid oid %q: %q", oid, line))
                        continue</span>
                }

                // see https://github.com/calypr/git-drs/issues/124#issuecomment-3721837089
                <span class="cov5" title="7">if oid == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" &amp;&amp; strings.Contains(path, ".gitattributes") </span><span class="cov2" title="2">{
                        logger.Debug(fmt.Sprintf("skipping empty LFS pointer for %s", path))
                        continue</span>
                }
                // Remove a trailing parenthetical suffix from p, e.g.:
                // "path/to/file.dat (100 KB)" -&gt; "path/to/file.dat"
                <span class="cov4" title="5">if idx := strings.LastIndex(path, " ("); idx != -1 &amp;&amp; strings.HasSuffix(path, ")") </span><span class="cov0" title="0">{
                        path = strings.TrimSpace(path[:idx])
                }</span>
                <span class="cov4" title="5">size := int64(0)
                absPath := path
                if repoDir != "" &amp;&amp; !filepath.IsAbs(path) </span><span class="cov4" title="5">{
                        absPath = filepath.Join(repoDir, path)
                }</span>
                <span class="cov4" title="5">if stat, err := os.Stat(absPath); err == nil </span><span class="cov4" title="5">{
                        size = stat.Size()
                }</span> else<span class="cov0" title="0"> {
                        logger.Error(fmt.Sprintf("could not stat file %s: %v", path, err))
                        continue</span>
                }

                // If the file is small, read it and detect LFS pointer signature.
                // Pointer files are textual and include the LFS spec version + an oid line.
                <span class="cov4" title="5">if size &gt; 0 &amp;&amp; size &lt; 2048 </span><span class="cov3" title="3">{
                        if data, readErr := os.ReadFile(absPath); readErr == nil </span><span class="cov3" title="3">{
                                s := strings.TrimSpace(string(data))
                                if strings.Contains(s, "version https://git-lfs.github.com/spec/v1") &amp;&amp; strings.Contains(s, "oid sha256:") </span><span class="cov0" title="0">{
                                        logger.Warn(fmt.Sprintf("WARNING: Detected upload of lfs pointer file %s skipping", path))
                                        continue</span>
                                }
                        }
                }

                <span class="cov4" title="5">lfsFileMap[path] = LfsFileInfo{
                        Name:    path,
                        Size:    size,
                        OidType: "sha256",
                        Oid:     oid,
                        Version: "https://git-lfs.github.com/spec/v1",
                }</span>
                //logger.Printf("GetAllLfsFiles added LFS file %s", path)
        }

        <span class="cov4" title="5">return nil</span>
}

// CreateCustomPath creates a custom path based on the DRS URI
// For example, DRS URI drs://&lt;namespace&gt;:&lt;drs_id&gt;
// create custom path &lt;baseDir&gt;/&lt;namespace&gt;/&lt;drs_id&gt;
func CreateCustomPath(baseDir, drsURI string) (string, error) <span class="cov5" title="6">{
        const prefix = "drs://"
        if len(drsURI) &lt;= len(prefix) || drsURI[:len(prefix)] != prefix </span><span class="cov2" title="2">{
                return "", fmt.Errorf("invalid DRS URI: %s", drsURI)
        }</span>
        <span class="cov4" title="4">rest := drsURI[len(prefix):]

        // Split by first colon
        colonIdx := -1
        for i, c := range rest </span><span class="cov10" title="46">{
                if c == ':' </span><span class="cov3" title="3">{
                        colonIdx = i
                        break</span>
                }
        }
        <span class="cov4" title="4">if colonIdx == -1 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("DRS URI missing colon: %s", drsURI)
        }</span>
        <span class="cov3" title="3">namespace := rest[:colonIdx]
        drsId := rest[colonIdx+1:]
        return filepath.Join(baseDir, namespace, drsId), nil</span>
}

// FindMatchingRecord finds a record from the list that matches the given project ID authz
// If no matching record is found return nil
func FindMatchingRecord(records []drs.DRSObject, projectId string) (*drs.DRSObject, error) <span class="cov5" title="8">{
        if len(records) == 0 </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        // Convert project ID to resource path format for comparison
        <span class="cov5" title="7">expectedAuthz, err := drs.ProjectToResource(projectId)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error converting project ID to resource format: %v", err)
        }</span>

        // Get the first record with matching authz if exists

        <span class="cov5" title="6">for _, record := range records </span><span class="cov5" title="7">{
                for _, access := range record.AccessMethods </span><span class="cov5" title="7">{
                        // assert access has Authorizations
                        if access.Authorizations == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("access method for record %v missing authorizations", record)
                        }</span>
                        <span class="cov5" title="7">if access.Authorizations.Value == expectedAuthz </span><span class="cov4" title="5">{
                                return &amp;record, nil
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/cmd"
        "github.com/calypr/git-drs/drslog"
)

func main() <span class="cov10" title="46">{

        _, err := drslog.NewLogger("", true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open log file: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov10" title="46">if err := cmd.RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                drslog.Close() // closes log file if there was one
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package gitrepo

import (
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/calypr/git-drs/common"
        "github.com/go-git/go-git/v5"
)

func DrsTopLevel() (string, error) <span class="cov1" title="1">{
        base, err := GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(base, common.DRS_DIR), nil</span>
}

// GetRepo opens the current git repository
func GetRepo() (*git.Repository, error) <span class="cov8" title="95">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="95">return git.PlainOpenWithOptions(cwd, &amp;git.PlainOpenOptions{DetectDotGit: true})</span>
}

// GitTopLevel returns the absolute path of the git repository root
func GitTopLevel() (string, error) <span class="cov4" title="8">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov4" title="7">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="7">return wt.Filesystem.Root(), nil</span>
}

// GetGitConfigString reads a string value from git config using the git command
// to ensure we pick up values from all scopes (system, global, local).
func GetGitConfigString(key string) (string, error) <span class="cov10" title="180">{
        cmd := exec.Command("git", "config", "--get", key)
        out, err := cmd.Output()
        if err != nil </span><span class="cov8" title="62">{
                // git config returns exit code 1 if the key is not found
                return "", nil
        }</span>
        <span class="cov9" title="118">return strings.TrimSpace(string(out)), nil</span>
}

// GetGitConfigInt reads an integer value from git config
func GetGitConfigInt(key string, defaultValue int64) int64 <span class="cov7" title="41">{
        valStr, err := GetGitConfigString(key)
        if err != nil || valStr == "" </span><span class="cov2" title="3">{
                return defaultValue
        }</span>
        <span class="cov7" title="38">val, err := strconv.ParseInt(valStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov7" title="38">return val</span>
}

// GetGitConfigBool reads a boolean value from git config
func GetGitConfigBool(key string, defaultValue bool) bool <span class="cov8" title="82">{
        valStr, err := GetGitConfigString(key)
        if err != nil || valStr == "" </span><span class="cov4" title="6">{
                return defaultValue
        }</span>
        <span class="cov8" title="76">val, err := strconv.ParseBool(valStr)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov8" title="76">return val</span>
}

func SetGitConfigOptions(configs map[string]string) error <span class="cov4" title="6">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="6">conf, err := repo.Config()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="6">for key, value := range configs </span><span class="cov7" title="54">{
                parts := strings.Split(key, ".")
                if len(parts) == 2 </span><span class="cov6" title="18">{
                        conf.Raw.Section(parts[0]).SetOption(parts[1], value)
                }</span> else<span class="cov7" title="36"> if len(parts) &gt; 2 </span><span class="cov7" title="36">{
                        // Handle subsections e.g. lfs.customtransfer.drs.path
                        section := parts[0]
                        subsection := strings.Join(parts[1:len(parts)-1], ".")
                        key := parts[len(parts)-1]
                        conf.Raw.Section(section).Subsection(subsection).SetOption(key, value)
                }</span>
        }

        <span class="cov4" title="6">return repo.Storer.SetConfig(conf)</span>
}

// GetGitHooksDir returns the absolute path to the .git/hooks directory
func GetGitHooksDir() (string, error) <span class="cov4" title="6">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="6">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // This is a simplification; for complex setups (submodules, worktrees),
        // we might need more robust logic, but this matches previous behavior.
        <span class="cov4" title="6">return filepath.Join(wt.Filesystem.Root(), ".git", "hooks"), nil</span>
}

// AddFile adds a file to the git staging area (index)
func AddFile(path string) error <span class="cov1" title="1">{
        repo, err := GetRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">wt, err := repo.Worktree()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">_, err = wt.Add(path)
        return err</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package testutils

import (
        "fmt"
        "os"
        "os/exec"
        "testing"

        "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/stretchr/testify/require"
)

// SetupTestGitRepo creates a temp directory mocking a real git repo
func SetupTestGitRepo(t *testing.T) string <span class="cov8" title="14">{
        t.Helper()

        tmpDir, err := os.MkdirTemp("", "git-drs-test-*")
        require.NoError(t, err)

        originalDir, err := os.Getwd()
        require.NoError(t, err)

        err = os.Chdir(tmpDir)
        require.NoError(t, err)

        cmd := exec.Command("git", "init")
        cmd.Dir = tmpDir
        err = cmd.Run()
        require.NoError(t, err)

        cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        cmd = exec.Command("git", "config", "user.name", "Test User")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        t.Cleanup(func() </span><span class="cov8" title="14">{
                os.Chdir(originalDir)
                os.RemoveAll(tmpDir)
        }</span>)

        <span class="cov8" title="14">return tmpDir</span>
}

// CreateTestConfig applies the given config to the git repository using git config commands
func CreateTestConfig(t *testing.T, tmpDir string, cfg *config.Config) <span class="cov5" title="5">{
        t.Helper()

        // Helper to run git config
        setConfig := func(key, value string) </span><span class="cov10" title="20">{
                cmd := exec.Command("git", "config", key, value)
                cmd.Dir = tmpDir
                err := cmd.Run()
                require.NoError(t, err, "failed to set git config %s=%s", key, value)
        }</span>

        <span class="cov5" title="5">if cfg.DefaultRemote != "" </span><span class="cov5" title="4">{
                setConfig("drs.default-remote", string(cfg.DefaultRemote))
        }</span>

        <span class="cov5" title="5">for name, remote := range cfg.Remotes </span><span class="cov5" title="4">{
                prefix := fmt.Sprintf("drs.remote.%s", name)
                if remote.Gen3 != nil </span><span class="cov5" title="4">{
                        setConfig(prefix+".type", "gen3")
                        setConfig(prefix+".endpoint", remote.Gen3.Endpoint)
                        setConfig(prefix+".project", remote.Gen3.ProjectID)
                        setConfig(prefix+".bucket", remote.Gen3.Bucket)
                }</span> else<span class="cov0" title="0"> if remote.Anvil != nil </span><span class="cov0" title="0">{
                        setConfig(prefix+".type", "anvil")
                }</span>
        }
}

// CreateDefaultTestConfig creates a standard test configuration
func CreateDefaultTestConfig(t *testing.T, tmpDir string) *config.Config <span class="cov5" title="4">{
        t.Helper()

        testConfig := &amp;config.Config{
                DefaultRemote: config.Remote(config.ORIGIN),
                Remotes: map[config.Remote]config.RemoteSelect{
                        config.Remote(config.ORIGIN): {
                                Gen3: &amp;indexd.Gen3Remote{
                                        Endpoint:  "https://test.gen3.org",
                                        ProjectID: "test-project",
                                        Bucket:    "test",
                                },
                        },
                },
        }

        CreateTestConfig(t, tmpDir, testConfig)
        return testConfig
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package testutils

import (
        "bytes"
        "io"
        "os"
        "testing"

        "github.com/stretchr/testify/require"
)

// CaptureStdout captures stdout during test execution
func CaptureStdout(t *testing.T, f func()) string <span class="cov10" title="6">{
        t.Helper()

        r, w, err := os.Pipe()
        require.NoError(t, err)

        oldStdout := os.Stdout
        os.Stdout = w

        defer func() </span><span class="cov10" title="6">{
                os.Stdout = oldStdout
        }</span>()

        <span class="cov10" title="6">outC := make(chan string)
        go func() </span><span class="cov10" title="6">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, r)
                outC &lt;- buf.String()
        }</span>()

        <span class="cov10" title="6">f()

        w.Close()
        output := &lt;-outC

        return output</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package testutils

import (
        "os"
        "testing"
)

// RunCmdMainTest is a generic test helper for cmd main packages
// It verifies the package compiles and can handle basic argument scenarios
func RunCmdMainTest(t *testing.T, cmdName string) <span class="cov6" title="7">{
        t.Helper()

        // Save original args
        oldArgs := os.Args
        defer func() </span><span class="cov6" title="7">{ os.Args = oldArgs }</span>()

        // Test with no arguments
        <span class="cov6" title="7">os.Args = []string{cmdName}

        t.Logf("%s main function test", cmdName)</span>
}

// RunCmdArgsTest is a generic test helper for validating command arguments
func RunCmdArgsTest(t *testing.T) <span class="cov6" title="7">{
        t.Helper()

        tests := []struct {
                name string
                args []string
        }{
                {"no args", []string{}},
                {"one arg", []string{"arg1"}},
                {"multiple args", []string{"arg1", "arg2"}},
        }

        for _, tt := range tests </span><span class="cov10" title="21">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="21">{
                        if len(tt.args) &gt;= 0 </span><span class="cov10" title="21">{
                                t.Logf("Args count: %d", len(tt.args))
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package lfs

import (
        "fmt"
        "os"
        "strings"

        "github.com/go-git/go-git/v5/plumbing/format/gitattributes"
)

// Matcher defines the interface for pattern matching
type Matcher interface {
        Match(path []string) bool
}

// safeMatcher wraps a Matcher to panic-safe execution
type safeMatcher struct {
        internal Matcher
}

func (m *safeMatcher) Match(path []string) (matched bool) <span class="cov8" title="174">{
        defer func() </span><span class="cov8" title="174">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        matched = false
                }</span>
        }()
        <span class="cov8" title="174">return m.internal.Match(path)</span>
}

// GitAttribute represents a single line in .gitattributes file
type GitAttribute struct {
        Pattern    string
        Attributes map[string]string
        matcher    Matcher
}

// ParseGitAttributes parses the content of a .gitattributes file
func ParseGitAttributes(content string) ([]GitAttribute, error) <span class="cov6" title="45">{
        atrs, err := gitattributes.ReadAttributes(strings.NewReader(content), nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="45">var attributes []GitAttribute
        for _, atr := range atrs </span><span class="cov8" title="174">{
                attrMap := make(map[string]string)
                for _, a := range atr.Attributes </span><span class="cov10" title="444">{
                        name := a.Name()
                        if a.IsSet() </span><span class="cov6" title="45">{
                                attrMap[name] = "true"
                        }</span> else<span class="cov9" title="399"> if a.IsUnset() </span><span class="cov7" title="90">{
                                attrMap[name] = "false"
                        }</span> else<span class="cov9" title="309"> if a.IsValueSet() </span><span class="cov9" title="309">{
                                attrMap[name] = a.Value()
                        }</span>
                }

                <span class="cov8" title="174">var matcher Matcher
                if m, ok := atr.Pattern.(Matcher); ok </span><span class="cov8" title="174">{
                        matcher = &amp;safeMatcher{internal: m}
                }</span>

                // attributes.Pattern string is not easily available from go-git Pattern interface.
                // We leave it empty or store the raw string representation if useful for debugging
                <span class="cov8" title="174">patternStr := fmt.Sprintf("%v", atr.Pattern)

                attributes = append(attributes, GitAttribute{
                        Pattern:    patternStr,
                        Attributes: attrMap,
                        matcher:    matcher,
                })</span>
        }

        <span class="cov6" title="45">return attributes, nil</span>
}

func IsLFSTracked(gitattributesFilePath, filePath string) (bool, error) <span class="cov2" title="3">{
        gitattributesContent, err := os.ReadFile(gitattributesFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read .gitattributes file: %w", err)
        }</span>

        <span class="cov2" title="3">return isLFSTracked(string(gitattributesContent), filePath)</span>
}

// isLFSTracked determines if a given file path is tracked by Git LFS
func isLFSTracked(gitattributesContent string, filePath string) (bool, error) <span class="cov5" title="28">{
        attributes, err := ParseGitAttributes(gitattributesContent)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov5" title="28">isLFS := false

        // split path into parts for matching
        pathParts := strings.Split(filePath, "/")
        if os.PathSeparator != '/' &amp;&amp; strings.Contains(filePath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                pathParts = strings.Split(filePath, string(os.PathSeparator))
        }</span>

        <span class="cov5" title="28">for _, attr := range attributes </span><span class="cov8" title="152">{
                matched := false
                if attr.matcher != nil </span><span class="cov8" title="152">{
                        matched = attr.matcher.Match(pathParts)
                }</span>

                <span class="cov8" title="152">if matched </span><span class="cov5" title="25">{
                        if filter, exists := attr.Attributes["filter"]; exists </span><span class="cov5" title="22">{
                                isLFS = (filter == "lfs")
                        }</span>
                }
        }

        <span class="cov5" title="28">return isLFS, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package lfs

import (
        "github.com/bytedance/sonic/encoder"
        dataClientCommon "github.com/calypr/data-client/common"
)

// InitMessage represents the structure of the initiation data
type InitMessage struct {
        Event               string `json:"event"`               // Always "init" to identify this message
        Operation           string `json:"operation"`           // "upload" or "download" depending on transfer direction
        Remote              string `json:"remote"`              // Git remote name or URL
        Concurrent          bool   `json:"concurrent"`          // Reflects lfs.customtransfer.&lt;name&gt;.concurrent
        ConcurrentTransfers int    `json:"concurrenttransfers"` // Reflects lfs.concurrenttransfers value
}

// CompleteMessage is a minimal response to signal transfer is "complete"
type CompleteMessage struct {
        Event string `json:"event"`
        Oid   string `json:"oid"`
        Path  string `json:"path,omitempty"`
}

// UploadMessage represents a request to upload an object.
type UploadMessage struct {
        Event  string  `json:"event"`  // "upload"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Path   string  `json:"path"`   // Local path to file
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
}

// DownloadMessage represents a request to download an object.
type DownloadMessage struct {
        Event  string  `json:"event"`  // "download"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
        Path   string  `json:"path"`   // Where to store the downloaded file
}

// TerminateMessage is sent when the agent should terminate.
type TerminateMessage struct {
        Event string `json:"event"` // "terminate"
}

// ErrorMessage is sent when an error occurs during a transfer.
type ErrorMessage struct {
        Event string `json:"event"` // "error"
        Oid   string `json:"oid"`   // Object ID involved in the error
        Error Error  `json:"error"` // Error details
}

type InitErrorMessage struct {
        Error Error `json:"error"` // Error details
}

type Error struct {
        Code    int    `json:"code"`    // Error code (standard or custom)
        Message string `json:"message"` // Human-readable error message
}

// ProgressResponse provides progress updates for an object transfer.
type ProgressResponse struct {
        Event          string `json:"event"`          // "progress"
        Oid            string `json:"oid"`            // Object ID being transferred
        BytesSoFar     int64  `json:"bytesSoFar"`     // Bytes transferred so far
        BytesSinceLast int64  `json:"bytesSinceLast"` // Bytes transferred since last progress message
}

// LogResponse provides log updates for an object transfer.
type LogResponse struct {
        Event   string `json:"event"`   // "log"
        Message string `json:"message"` // The log message
}

// TerminateResponse signals the agent has completed termination.
type TerminateResponse struct {
        Event string `json:"event"` // "terminate"
}

// Action is an optional struct representing transfer actions (upload/download URLs, etc.)
type Action struct {
        Href      string            `json:"href"`
        Header    map[string]string `json:"header,omitempty"`
        ExpiresIn int               `json:"expires_in,omitempty"`
}

func WriteInitErrorMessage(encoder *encoder.StreamEncoder, code int, errMsg string) <span class="cov1" title="2">{
        // create failure message and send it back
        errorResponse := InitErrorMessage{
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteErrorMessage(encoder *encoder.StreamEncoder, oid string, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := ErrorMessage{
                Event: "complete",
                Oid:   oid,
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteCompleteMessage(encoder *encoder.StreamEncoder, oid string, path string) <span class="cov3" title="9">{
        // create success message and send it back
        completeResponse := CompleteMessage{
                Event: "complete",
                Oid:   oid,
                Path:  path,
        }
        encoder.Encode(completeResponse)
}</span>

func WriteProgressMessage(encoder *encoder.StreamEncoder, oid string, bytesSoFar int64, bytesSinceLast int64) <span class="cov9" title="10141">{
        progressResponse := ProgressResponse{
                Event:          "progress",
                Oid:            oid,
                BytesSoFar:     bytesSoFar,
                BytesSinceLast: bytesSinceLast,
        }
        encoder.Encode(progressResponse)
}</span>

// NewProgressCallback returns a ProgressCallback that sends progress events
// to git-lfs via the streamEncoder
func NewProgressCallback(streamEncoder *encoder.StreamEncoder) dataClientCommon.ProgressCallback <span class="cov3" title="8">{
        return func(event dataClientCommon.ProgressEvent) error </span><span class="cov10" title="10186">{
                if event.Event == "log" </span><span class="cov4" title="50">{
                        // Don't send log events to Git LFS as they are not part of the protocol
                        // and cause Git LFS to think the transfer is complete.
                        return nil
                }</span>
                <span class="cov9" title="10136">WriteProgressMessage(streamEncoder, event.Oid, event.BytesSoFar, event.BytesSinceLast)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package lfs

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/git-drs/common"
)

// This file contains functions that pertain to .git/drs/lfs/objects directory walk
type PendingObject struct {
        OID  string
        Path string
}

// getPendingObjects walks .git/drs/lfs/objects/ to find all pending records
func GetPendingObjects(logger *slog.Logger) ([]*PendingObject, error) <span class="cov1" title="1">{
        var objects []*PendingObject
        objectsDir := common.DRS_OBJS_PATH

        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov9" title="5">if info.IsDir() </span><span class="cov6" title="3">{
                        return nil
                }</span>
                <span class="cov4" title="2">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov1" title="1">oid := parts[2] // GetObjectPath stores full OID in the 3rd directory level
                objects = append(objects, &amp;PendingObject{
                        OID: oid,
                })
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found %d pending objects in %s", len(objects), objectsDir))
        return objects, nil</span>
}

func GetDrsLfsObjects(logger *slog.Logger) (map[string]*drs.DRSObject, error) <span class="cov1" title="1">{
        objects := map[string]*drs.DRSObject{}
        objectsDir := common.DRS_OBJS_PATH
        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("DRS objects directory not found: %s", objectsDir))
                return nil, nil
        }</span>

        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error accessing path %s: %v", path, err))
                        return err
                }</span>
                <span class="cov10" title="6">if info.IsDir() </span><span class="cov6" title="3">{
                        return nil
                }</span>
                <span class="cov6" title="3">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="3">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov4" title="2">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error reading file %s: %v", path, err))
                        return err
                }</span>
                <span class="cov4" title="2">var drsObject drs.DRSObject
                if err := sonic.ConfigFastest.Unmarshal(data, &amp;drsObject); err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("Error unmarshalling JSON from %s: %v", path, err))
                        return nil
                }</span>

                // This could be problematic
                <span class="cov1" title="1">if drsObject.Checksums.SHA256 != "" </span><span class="cov1" title="1">{
                        objects[drsObject.Checksums.SHA256] = &amp;drsObject
                }</span>

                <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Successfully unmarshaled DRSObject from %s:\n%+v", path, drsObject))
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found and unmarshaled %d DRS objects.", len(objects)))
        return objects, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package lfs

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/git-drs/common"
        "github.com/calypr/git-drs/gitrepo"
)

type DrsWalkFunc func(path string, d *drs.DRSObject) error

func BaseDir() (string, error) <span class="cov1" title="1">{
        gitTopLevel, err := gitrepo.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(gitTopLevel, common.DRS_DIR), nil</span>
}

type dirWalker struct {
        baseDir  string
        userFunc DrsWalkFunc
}

func (d *dirWalker) call(path string, dir fs.DirEntry, cErr error) error <span class="cov10" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov6" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">obj := drs.DRSObject{}
        err = sonic.ConfigFastest.Unmarshal(data, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">relPath, err := filepath.Rel(d.baseDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return d.userFunc(relPath, &amp;obj)</span>
}

func ObjectWalk(f DrsWalkFunc) error <span class="cov1" title="1">{
        baseDir, err := BaseDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">ud := dirWalker{baseDir, f}
        return filepath.WalkDir(baseDir, ud.call)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package s3_utils

import (
        "log/slog"
        "net/http"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

type S3BucketsResponse struct {
        GSBuckets map[string]any       `json:"GS_BUCKETS"`
        S3Buckets map[string]*S3Bucket `json:"S3_BUCKETS"`
}

type S3Bucket struct {
        Region      string   `json:"region,omitempty"`
        EndpointURL string   `json:"endpoint_url,omitempty"`
        Programs    []string `json:"programs,omitempty"`
}

// S3Meta holds S3 object metadata
type S3Meta struct {
        Size         int64
        LastModified string
}

type CustomEndpointResolver struct {
        Endpoint string
}

const (
        AWS_KEY_FLAG_NAME          = "aws-access-key-id"
        AWS_SECRET_FLAG_NAME       = "aws-secret-access-key"
        AWS_KEY_ENV_VAR            = "AWS_ACCESS_KEY_ID"
        AWS_SECRET_ENV_VAR         = "AWS_SECRET_ACCESS_KEY"
        AWS_REGION_FLAG_NAME       = "region"
        AWS_REGION_ENV_VAR         = "AWS_REGION"
        AWS_ENDPOINT_URL_FLAG_NAME = "endpoint-url"
        AWS_ENDPOINT_URL_ENV_VAR   = "AWS_ENDPOINT_URL"
)

func (r *CustomEndpointResolver) ResolveEndpoint(service, region string) (aws.Endpoint, error) <span class="cov8" title="1">{
        return aws.Endpoint{
                URL: r.Endpoint,
        }, nil
}</span>

// AddURLConfig holds optional clients for dependency injection
type AddURLConfig struct {
        S3Client   *s3.Client
        HttpClient *http.Client
        Logger     *slog.Logger
}

// AddURLOption is a functional option for configuring AddURL
type AddURLOption func(*AddURLConfig)

// WithS3Client provides a custom S3 client to AddURL
func WithS3Client(client *s3.Client) AddURLOption <span class="cov8" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov8" title="1">{
                cfg.S3Client = client
        }</span>
}

// WithHTTPClient provides a custom HTTP client to AddURL
func WithHTTPClient(client *http.Client) AddURLOption <span class="cov8" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov8" title="1">{
                cfg.HttpClient = client
        }</span>
}

// WithLogger provides a custom logger to AddURL
func WithLogger(logger *slog.Logger) AddURLOption <span class="cov8" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov8" title="1">{
                cfg.Logger = logger
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package s3_utils

import (
        "encoding/hex"
        "errors"
        "strings"
)

func ValidateInputs(s3URL string, sha256 string) error <span class="cov10" title="26">{
        if !strings.HasPrefix(s3URL, "s3://") </span><span class="cov6" title="8">{
                return errors.New("invalid S3 URL format. URL should be of the format 's3://bucket/path/to/file'")
        }</span>

        // Normalize case and validate SHA256
        <span class="cov8" title="18">sha256 = strings.ToLower(sha256)
        if len(sha256) != 64 </span><span class="cov5" title="5">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="13">if _, err := hex.DecodeString(sha256); err != nil </span><span class="cov2" title="2">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov7" title="11">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Creates directories from stdin lines, each with 16 `sub-directory-N` subfolders, each containing 1001000 files of 1 KiB whose contents are the relative file path. Save as `generate-fixtures.go`.

package main

import (
        "bufio"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

const (
        minSubDirs = 1
        maxSubDirs = 6

        minFilesPerSub = 100
        maxFilesPerSub = 1000

        fileSizeBytes = 1024
)

// main reads directory names from stdin (one per line) and creates a set of
// "fixture" directories and files for each input name. For each top-level
// directory it creates between minSubDirs and maxSubDirs subdirectories
// named "sub-directory-N". Each subdirectory receives between minFilesPerSub
// and maxFilesPerSub files. File contents are written as the relative path
// bytes. The program prints progress and errors to stderr and exits with a
// non-zero code on read errors or when no input is provided.
func main() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())

        // Flags: if &gt;0 they override randomness
        numSubdirsFlag := flag.Int("number-of-subdirectories", 0, "fixed number of subdirectories per top-level directory (overrides random)")
        numFilesFlag := flag.Int("number-of-files", 0, "fixed number of files per subdirectory (overrides random)")
        flag.Parse()

        scanner := bufio.NewScanner(os.Stdin)
        entries := []string{}
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">entries = append(entries, line)</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "reading stdin: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "no input lines; provide one directory name per line on stdin")
                os.Exit(1)
        }</span>

        // Determine digits for file name padding based on configured or default max
        <span class="cov0" title="0">maxFilesConsidered := maxFilesPerSub
        if *numFilesFlag &gt; 0 &amp;&amp; *numFilesFlag &gt; maxFilesConsidered </span><span class="cov0" title="0">{
                maxFilesConsidered = *numFilesFlag
        }</span>
        <span class="cov0" title="0">maxFilesDigits := len(strconv.Itoa(maxFilesConsidered))

        for _, name := range entries </span><span class="cov0" title="0">{
                // Clean the path and disallow absolute paths for safety
                clean := filepath.Clean(name)
                if filepath.IsAbs(clean) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping absolute path: %s\n", name)
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(clean, ".."+string(os.PathSeparator)) || clean == ".." </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping path outside current tree: %s\n", name)
                        continue</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(clean, 0o755); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", clean, err)
                        continue</span>
                }

                // Choose number of subdirectories
                <span class="cov0" title="0">var nSub int
                if *numSubdirsFlag &gt; 0 </span><span class="cov0" title="0">{
                        if *numSubdirsFlag &lt; 1 </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "invalid --number-of-subdirectories: %d (must be &gt;= 1)\n", *numSubdirsFlag)
                                continue</span>
                        }
                        <span class="cov0" title="0">nSub = *numSubdirsFlag</span>
                } else<span class="cov0" title="0"> {
                        nSub = rand.Intn(maxSubDirs-minSubDirs+1) + minSubDirs
                }</span>

                <span class="cov0" title="0">for si := 1; si &lt;= nSub; si++ </span><span class="cov0" title="0">{
                        subdir := filepath.Join(clean, fmt.Sprintf("sub-directory-%d", si))
                        if err := os.MkdirAll(subdir, 0o755); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", subdir, err)
                                continue</span>
                        }

                        // Choose number of files per subdirectory
                        <span class="cov0" title="0">var nFiles int
                        if *numFilesFlag &gt; 0 </span><span class="cov0" title="0">{
                                if *numFilesFlag &lt; 1 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "invalid --number-of-files: %d (must be &gt;= 1)\n", *numFilesFlag)
                                        continue</span>
                                }
                                <span class="cov0" title="0">nFiles = *numFilesFlag</span>
                        } else<span class="cov0" title="0"> {
                                nFiles = rand.Intn(maxFilesPerSub-minFilesPerSub+1) + minFilesPerSub
                        }</span>

                        <span class="cov0" title="0">for fi := 1; fi &lt;= nFiles; fi++ </span><span class="cov0" title="0">{
                                filename := fmt.Sprintf("file-%0*d.dat", maxFilesDigits, fi)
                                path := filepath.Join(subdir, filename)
                                pathBytes := []byte(path)
                                if err := os.WriteFile(path, pathBytes, 0o644); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "write %s: %v\n", path, err)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "created %d files in %s\n", nFiles, subdir)</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "done: %s (%d subdirs)\n", clean, nSub)</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "fmt"
        "net/http"
        "net/url"
        "os/exec"
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

func SimpleRun(cmds []string) (string, error) <span class="cov3" title="3">{
        exePath, err := exec.LookPath(cmds[0])
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("command not found: %s: %w", cmds[0], err)
        }</span>
        <span class="cov2" title="2">cmd := exec.Command(exePath, cmds[1:]...)
        cmdOut, err := cmd.Output()
        return string(cmdOut), err</span>
}

// CanDownloadFile checks if a file can be downloaded from the given signed URL
// by issuing a ranged GET for a single byte to mimic HEAD behavior.
func CanDownloadFile(signedURL string) error <span class="cov2" title="2">{
        req, err := http.NewRequest("GET", signedURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov2" title="2">req.Header.Set("Range", "bytes=0-0")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while sending the request: %v", err)
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        if resp.StatusCode == http.StatusPartialContent || resp.StatusCode == http.StatusOK </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">return fmt.Errorf("failed to access file, HTTP status: %d", resp.StatusCode)</span>
}

func ParseEmailFromToken(tokenString string) (string, error) <span class="cov3" title="5">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode token in ParseEmailFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov3" title="4">context, ok := claims["context"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context' claim structure")
        }</span>
        <span class="cov3" title="3">user, ok := context["user"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user' claim structure")
        }</span>
        <span class="cov2" title="2">name, ok := user["name"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user.name' claim")
        }</span>
        <span class="cov1" title="1">return name, nil</span>
}

func ParseAPIEndpointFromToken(tokenString string) (string, error) <span class="cov4" title="7">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token in ParseAPIEndpointFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov4" title="7">issUrl, ok := claims["iss"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'iss' claim")
        }</span>
        <span class="cov4" title="6">parsedURL, err := url.Parse(issUrl)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov3" title="5">return fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host), nil</span>
}

func ParseS3URL(s3url string) (string, string, error) <span class="cov5" title="13">{
        s3Prefix := "s3://"
        if !strings.HasPrefix(s3url, s3Prefix) </span><span class="cov3" title="4">{
                return "", "", fmt.Errorf("S3 URL requires prefix 's3://': %s", s3url)
        }</span>
        <span class="cov5" title="9">trimmed := strings.TrimPrefix(s3url, s3Prefix)
        slashIndex := strings.Index(trimmed, "/")
        if slashIndex == -1 || slashIndex == len(trimmed)-1 </span><span class="cov3" title="4">{
                return "", "", fmt.Errorf("invalid S3 file URL: %s", s3url)
        }</span>
        <span class="cov3" title="5">return trimmed[:slashIndex], trimmed[slashIndex+1:], nil</span>
}

// IsValidSHA256 checks if a string is a valid SHA-256 hash
func IsValidSHA256(s string) bool <span class="cov4" title="6">{
        if len(s) != 64 </span><span class="cov3" title="3">{
                return false
        }</span>
        <span class="cov3" title="3">for _, r := range s </span><span class="cov10" title="129">{
                if (r &lt; '0' || r &gt; '9') &amp;&amp; (r &lt; 'a' || r &gt; 'f') &amp;&amp; (r &lt; 'A' || r &gt; 'F') </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov2" title="2">return true</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package version reports the Git-DRS version.
package version

import "fmt"

// Build and version details
var (
        GitCommit   = ""
        GitBranch   = ""
        GitUpstream = ""
        BuildDate   = ""
        Version     = ""
)

var tpl = `git commit: %s
git branch: %s
git upstream: %s
build date: %s
version: %s`

// String formats a string with version details.
func String() string <span class="cov8" title="1">{
        return fmt.Sprintf(tpl, GitCommit, GitBranch, GitUpstream, BuildDate, Version)
}</span>

// LogFields logs build and version information to the given logger.
func LogFields() []any <span class="cov8" title="1">{
        return []any{
                "GitCommit", GitCommit,
                "GitBranch", GitBranch,
                "GitUpstream", GitUpstream,
                "BuildDate", BuildDate,
                "Version", Version,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
