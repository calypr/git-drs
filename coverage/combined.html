
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anvil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/calypr/git-drs/client/anvil/anvil_client.go (0.0%)</option>
				
				<option value="file1">github.com/calypr/git-drs/client/anvil/remote.go (100.0%)</option>
				
				<option value="file2">github.com/calypr/git-drs/client/indexd/add_url.go (0.0%)</option>
				
				<option value="file3">github.com/calypr/git-drs/client/indexd/gen3_remote.go (85.7%)</option>
				
				<option value="file4">github.com/calypr/git-drs/client/indexd/indexd_client.go (40.9%)</option>
				
				<option value="file5">github.com/calypr/git-drs/client/indexd/register.go (0.0%)</option>
				
				<option value="file6">github.com/calypr/git-drs/client/tests/mock_types.go (0.0%)</option>
				
				<option value="file7">github.com/calypr/git-drs/cmd/addref/add-ref.go (2.0%)</option>
				
				<option value="file8">github.com/calypr/git-drs/cmd/addurl/main.go (21.2%)</option>
				
				<option value="file9">github.com/calypr/git-drs/cmd/cache/create-cache.go (0.0%)</option>
				
				<option value="file10">github.com/calypr/git-drs/cmd/delete/main.go (3.2%)</option>
				
				<option value="file11">github.com/calypr/git-drs/cmd/deleteproject/main.go (3.1%)</option>
				
				<option value="file12">github.com/calypr/git-drs/cmd/download/main.go (5.9%)</option>
				
				<option value="file13">github.com/calypr/git-drs/cmd/fetch/main.go (0.0%)</option>
				
				<option value="file14">github.com/calypr/git-drs/cmd/initialize/main.go (74.1%)</option>
				
				<option value="file15">github.com/calypr/git-drs/cmd/list/main.go (6.2%)</option>
				
				<option value="file16">github.com/calypr/git-drs/cmd/listconfig/main.go (6.2%)</option>
				
				<option value="file17">github.com/calypr/git-drs/cmd/prepush/main.go (47.9%)</option>
				
				<option value="file18">github.com/calypr/git-drs/cmd/push/main.go (0.0%)</option>
				
				<option value="file19">github.com/calypr/git-drs/cmd/query/main.go (5.7%)</option>
				
				<option value="file20">github.com/calypr/git-drs/cmd/register/main.go (1.6%)</option>
				
				<option value="file21">github.com/calypr/git-drs/cmd/remote/add/anvil.go (0.0%)</option>
				
				<option value="file22">github.com/calypr/git-drs/cmd/remote/add/gen3.go (57.1%)</option>
				
				<option value="file23">github.com/calypr/git-drs/cmd/remote/add/init.go (100.0%)</option>
				
				<option value="file24">github.com/calypr/git-drs/cmd/remote/list.go (0.0%)</option>
				
				<option value="file25">github.com/calypr/git-drs/cmd/remote/root.go (100.0%)</option>
				
				<option value="file26">github.com/calypr/git-drs/cmd/remote/set.go (0.0%)</option>
				
				<option value="file27">github.com/calypr/git-drs/cmd/root.go (100.0%)</option>
				
				<option value="file28">github.com/calypr/git-drs/cmd/transfer/main.go (44.1%)</option>
				
				<option value="file29">github.com/calypr/git-drs/cmd/transferref/main.go (6.4%)</option>
				
				<option value="file30">github.com/calypr/git-drs/cmd/version/main.go (57.9%)</option>
				
				<option value="file31">github.com/calypr/git-drs/config/config.go (65.3%)</option>
				
				<option value="file32">github.com/calypr/git-drs/drslog/compat.go (100.0%)</option>
				
				<option value="file33">github.com/calypr/git-drs/drslog/logger.go (49.1%)</option>
				
				<option value="file34">github.com/calypr/git-drs/drsmap/drs_map.go (44.1%)</option>
				
				<option value="file35">github.com/calypr/git-drs/git-drs.go (42.9%)</option>
				
				<option value="file36">github.com/calypr/git-drs/internal/testutils/cmd_test_helpers.go (100.0%)</option>
				
				<option value="file37">github.com/calypr/git-drs/internal/testutils/config.go (56.8%)</option>
				
				<option value="file38">github.com/calypr/git-drs/internal/testutils/output.go (100.0%)</option>
				
				<option value="file39">github.com/calypr/git-drs/lfs/messages.go (100.0%)</option>
				
				<option value="file40">github.com/calypr/git-drs/lfs/store.go (78.9%)</option>
				
				<option value="file41">github.com/calypr/git-drs/lfs/util.go (80.0%)</option>
				
				<option value="file42">github.com/calypr/git-drs/s3_utils/download.go (75.0%)</option>
				
				<option value="file43">github.com/calypr/git-drs/s3_utils/s3.go (100.0%)</option>
				
				<option value="file44">github.com/calypr/git-drs/s3_utils/validate.go (100.0%)</option>
				
				<option value="file45">github.com/calypr/git-drs/tests/monorepos/generate-fixtures.go (0.0%)</option>
				
				<option value="file46">github.com/calypr/git-drs/utils/common.go (100.0%)</option>
				
				<option value="file47">github.com/calypr/git-drs/utils/confirmation.go (93.3%)</option>
				
				<option value="file48">github.com/calypr/git-drs/utils/lfs-track.go (78.9%)</option>
				
				<option value="file49">github.com/calypr/git-drs/utils/util.go (73.4%)</option>
				
				<option value="file50">github.com/calypr/git-drs/version/version.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anvil_client

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/bytedance/sonic"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "golang.org/x/oauth2/google"
)

type AnvilClient struct {
        Endpoint string
        SConfig  sonic.API
}

func (an *AnvilClient) GetObject(ctx context.Context, objectID string) (*d<span class="cov0" title="0">rs.DRSObject, error) {
        // get auth token
        token, err := GetAuthToken()
        if err != nil </span></span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auth token: %w", err)
        }</span>

        <span class="cov0" title="0">reqBody := map[string]any{
                "url":    objectID,
                "fields": []string{"hashes", "size", "fileName"},
        }
        bodyBytes, err := an.SConfig.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", an.Endpoint, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, _ := io.ReadAll(resp.Body)
        if resp.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                // Try to extract error message
                var errResp map[string]any
                an.SConfig.Unmarshal(respBody, &amp;errResp)
                msg := fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(respBody))
                if m, ok := errResp["message"].(string); ok </span><span class="cov0" title="0">{
                        msg = m
                }</span>
                <span class="cov0" title="0">return &amp;drs.DRSObject{}, errors.New(msg)</span>
        }

        // Parse expected response
        // subset of ResourceMetadata
        // https://github.com/DataBiosphere/terra-drs-hub/blob/dev/common/openapi.yml#L123
        <span class="cov0" title="0">var parsed struct {
                Hashes   map[string]string `json:"hashes"`
                Size     int64             `json:"size"`
                FileName string            `json:"fileName"`
        }
        if err := an.SConfig.Unmarshal(respBody, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;drs.DRSObject{
                SelfURI:   objectID,
                Id:        objectID,
                Checksums: hash.ConvertStringMapToHashInfo(parsed.Hashes),
                Size:      parsed.Size,
                Name:      parsed.FileName,
        }, nil</span>
}

// GetAuthToken fetches a Google Cloud authentication token using Application Default Credentials.
// The user must run `gcloud auth application-default login` before using this.
func GetAuthToken() (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        creds, err := google.FindDefaultCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">ts := creds.TokenSource
        token, err := ts.Token()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid() || token.AccessToken == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no token retrieved")
        }</span>

        <span class="cov0" title="0">return token.AccessToken, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package anvil_client

import (
        "fmt"
        "log/slog"

        "github.com/calypr/git-drs/client"
)

// AnvilAuth holds authentication info for Anvil
type AnvilAuth struct {
        TerraProject string `yaml:"terra_project"`
}

// AnvilRemote holds Anvil remote config
type AnvilRemote struct {
        Endpoint string    `yaml:"endpoint"`
        Auth     AnvilAuth `yaml:",inline"`
}

func (s AnvilRemote) GetProjectId() string <span class="cov8" title="1">{
        return s.Auth.TerraProject
}</span>

func (s AnvilRemote) GetEndpoint() string <span class="cov8" title="1">{
        return s.Endpoint
}</span>

func (s AnvilRemote) GetBucketName() string <span class="cov8" title="1">{
        return ""
}</span>

func (s AnvilRemote) GetClient(params map[string]string, logger *slog.Logger) (client.DRSClient, error) <span class="cov8" title="1">{
        return nil, fmt.Errorf(("AnVIL Client needs to be implemented"))
        // return NewAnvilClient(s, logger)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package indexd_client

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "slices"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/calypr/data-client/fence"
        "github.com/calypr/data-client/indexd"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/messages"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
)

// getBucketDetails fetches bucket details from Gen3 using data-client.
func (inc *GitDrsIdxdClient) getBucketDetails(ctx context.Context, bucket string, httpClient *http.Client) (*fence.S3Bucket, error) <span class="cov0" title="0">{
        return inc.G3.Fence().GetBucketDetails(ctx, bucket)
}</span>

// FetchS3MetadataWithBucketDetails fetches S3 metadata given bucket details.
func FetchS3MetadataWithBucketDetails(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, bucketDetails *fence.S3Bucket, s3Client *s3.Client, logger *slog.Logger) (int64, string, error) {
        bucket, key, err := utils.ParseS3URL(s3URL)
        if err != nil {
        </span>        return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }

        if s3Client == nil {
                cfg, err := awsConfig.LoadDefaultConfig(ctx)
                if err != nil {
                        return 0, "", fmt.Errorf("unable to load base AWS SDK config: %v. %s", err, messages.ADDURL_HELP_MSG)
                }

</span>                var configOptions []func(*awsConfig.LoadOptions) error
                </span>if awsAccessKey != "" &amp;&amp; awsSecretKey != "" {
                        configOptions = append(configOptions,
                                awsConfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(awsAccessKey, awsSecretKey, "")),
        <span class="cov0" title="0">                )
                }

                regionToUse := ""
                if region != "" {
</span>                        regionToUse = region
                } else if bucketDetails != nil &amp;&amp; bucketDetails.Region != "" {
                        regionToUse =</span><span class="cov0" title="0"> bucketDetails.Region
                }
                i</span>f regionToUse != "" {
                        configOptions = append(configOptions, awsConfig.WithRegion(regionToUse))
                }

                if len(configOptions) &gt; 0 {
                        cfg, err = awsConfig.LoadDefaultConfig(ctx, configOptions...)
                        if err != nil {
</span>                                return 0, "", fmt.Errorf("unable to load AWS SDK config with overrides: %v. %s", err, messages.ADDURL_HELP_MSG)
                        }
                }

                endpointToUse := ""
                if endpoint != "" {
                        endpointToUse = endpoint
                }</span> else if bucketDetails != nil &amp;&amp; bucketDetails.EndpointURL != "" {
                        endpointToUse = bucketDetails.EndpointURL
                }

                s3Client = s3.Ne</span><span class="cov0" title="0">wFromConfig(cfg, func(o *s3.Options) {
                        if endpointToUse != "" {
                        </span>        o.Ba<span class="cov0" title="0">seEndpoint = aws.String(endpoin</span><span class="cov0" title="0">tToUse)
                        }
                        </span>o.UsePathStyle = true
                <span class="cov0" title="0">})
</span>        }

</span>        input := &amp;s3.HeadObjectInput{
                Bucket: &amp;bucket,
                <span class="cov0" title="0">Key:    aws.String(key),
</span>        }

</span>        resp, err := s3Client.HeadObject(ctx, input)
        if </span>err != nil {
                return 0, "", fmt.Errorf("failed to head object, %v", err)
        }

        v<span class="cov0" title="0">ar contentLength int64
        if resp.ContentLeng</span><span class="cov0" title="0">th != nil {
                contentLength = *resp.ContentLength
        }

</span></span>        return contentLength, resp.LastModified.Format(time.RFC3339), nil
}
</span>
func (inc *GitDrsIdxdClient) fetchS3Metadata(ctx context.Context, s3URL, awsAccessKey, awsSecretKey, region, endpoint string, s3Client *s3.Client, httpClient *http.Client, logger *slog.Logger) (int64, string, error) {
        bucket, _, err := utils.ParseS3URL(s3URL)
        i<span class="cov0" title="0">f err != nil {
                return 0, "", fmt.Errorf("failed to parse S3 URL: %w", err)
        }

        bucketDetails, err := inc.getBucketDetails(ctx, bucket</span><span class="cov0" title="0">, httpClient)
        if err != nil {
</span>                logger.Debug(fmt.Sprintf("Warning: unable to get bucket details from Gen3: %v", err))
        }
</span>
</span>        return FetchS3MetadataWithBucketDetails(ctx, s3URL, awsAccessKey, awsSecretKey, region, endpoint, bucketDetails, s3Client, logger)
}

func (inc *GitDrsIdxdClient) upsertIndexdRecord(ctx context.Context, url string, sha256 string, fileSize int64, logger *slog.Logger) (*drs.DRSObject, error) {
        projectId := inc.GetProjectId()
        <span class="cov0" title="0">uuid := drsmap.DrsUUID</span><span class="cov0" title="0">(projectId, sha256)

        records, err := inc.GetObjectByHash(ctx, &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: sha256})
        if err != nil {
                return nil, fmt.Errorf("error q</span><span class="cov0" title="0">uerying indexd server: %v", err)
        }

</span>        var matchingRecord *drs.DRSObject
        for</span> i := range records {
                if records[i].Id == uuid {
                        matchingRecord = &amp;records[i]
                        break
                <span class="cov0" title="0">}
</span>        }

</span>        if matchingRecord != nil {
                existingURLs := indexd.IndexdURLFromDrsAccessURLs(matchingRecord.AccessMethods)
                <span class="cov0" title="0">if slices.Contains(exis</span><span class="cov0" title="0">tingURLs, url) {
                        logger.Debug("Nothing to do: file already registered")
                        </span>return matchingRecord, nil
                }

                logger.Debug("updating existing record with new url")
                updatedRecord := drs.DRSObject{AccessMethods: []drs.AccessMethod{{AccessURL: drs.AccessURL{URL: url}}}}
                return inc.UpdateRecord(ctx, &amp;updatedRecord, matchingRecord.Id)
        }

</span>        // If no record exists, create one
        logger.Debug("creating new record")
        _, relPath, _ := utils.ParseS3URL(url)</span><span class="cov0" title="0">

        drs</span>Obj, err := drs.BuildDrsObj(relPath, sha256, fileSize, uuid, inc.Config.BucketName, projectId)
        if<span class="cov0" title="0"> err != nil {
                return nil, err
        }

        // Add authz explicitly since BuildDrsObj might not set it exactly as needed for all cases
        // Actually BuildDrsObj does set authz.
        return inc.RegisterRecord(ctx, drsObj)
}
</span>
func (inc *GitDrsIdxdClient) AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, regionFlag, endpointFlag string, opts ...s3_utils.AddURLOption) (s3_utils.S3Meta, error) {
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

</span>        cfg := &amp;s3_utils.AddURLConfig{}
        f</span>or _, opt := range opts {
                opt(cfg)
        <span class="cov0" title="0">}

        if inc.Logger == nil {
                inc.Logger = drslog.NewNoOpLogger()
        }

        if err := s3_u</span><span class="cov0" title="0">tils.ValidateInputs(s3URL, sha256); err != nil {
                return s3_utils.S3Meta{}, err
        }</span>

        <span class="cov0" title="0">_, relPath, err := utils.ParseS3URL(s3URL)
        if err != nil {
</span>                return s3_utils.S3Meta{}, fmt.Errorf("failed to parse S3 URL: %w", err)
        }</span>

        i</span>sLFS, err := utils.IsLFSTracked(".gitattributes", relPath)
        if err != nil {
        <span class="cov0" title="0">        return s3_utils.S3Meta{}, fmt.Errorf("unable to determine if fil</span>e is tracked by LFS: %w", err)
        }
        if !isLFS {
                return s3_utils.S3Meta{}, fmt.Errorf("file is not tracked by LFS")
        }

        inc.Logger.Debug("Fetching S3 metadata...")
        fileSize, modifiedDate, err := inc.fetchS3Metadata(ctx, s3URL, awsAccessKey, awsSecretKey, regionFlag, endpointFlag, cfg.S3Client, cfg.HttpClient, inc.Logger)
        if err != nil {
                return s3_uti</span><span class="cov0" title="0">ls.S3Meta{}, fmt.Errorf("failed to fetch S3 metadata: %w", err)
        }

</span>        inc.Logger.Debug(fmt.Sprintf("Fetched S3 metadata successfully: %d bytes, modified: %s", fileSize, modifiedDate))

        inc.Logger.Deb</span><span class="cov0" title="0">ug("Processing indexd record...")
        drsObj, err := inc.upsertIndexdRecord(ctx, s3URL, sha256, fileSize, inc.Logger)
        i</span>f err != nil {
        <span class="cov0" title="0">        return s3_utils.S3Meta{</span><span class="cov0" title="0">}, fmt.Errorf("failed to create indexd record: %w", err)
        }

        d</span>rsObjPath, err := drsmap.GetObjectPath(projectdir.DRS_OBJS_PATH, drsObj.Checksums.SHA256)
        if err != nil {
        <span class="cov0" title="0">        return s3_utils.S3Meta{}, err
</span>        }
        if err := drsmap.WriteDrsObj(drsObj, sha256, drsObjPath); err != nil {
                return s3_utils.S3Meta{}, err
        }

        inc.Logger.Debug("Indexd updated")

        return s3_utils.S3Meta{
                Size:         fileSize,
                LastModified: modifiedDate,
        }, nil
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package indexd_client

import (
        "log/slog"

        "github.com/calypr/data-client/conf"
        "github.com/calypr/git-drs/client"
)

// Gen3Server holds Gen3 server config
type Gen3Remote struct {
        Endpoint  string `yaml:"endpoint"`
        ProjectID string `yaml:"project_id"`
        Bucket    string `yaml:"bucket"`
}

func (s Gen3Remote) GetProjectId() string <span class="cov5" title="5">{
        return s.ProjectID
}</span>

</span>func (s Gen3Remote) GetEndpoint() string <span class="cov1" title="1">{
        return s.Endpoint
}</span>

</span>func (s Gen3Remote) GetBucketName() string <span class="cov4" title="4">{
        return s.Bucket
}</span>

</span>func (s Gen3Remote) GetClient(params map[string]string, logger *slog.Logger) (client.DRSClient, error) <span class="cov3" title="3">{
        cred, err := conf.NewConfigure(logger).Load(params["remote_name"])
        if err != nil </span>{
                return nil, e</span>rr
        }</span>
        r</span>eturn NewGitDrsIdxdClient(*cred, s, logger)</span>
}<span class="cov10" title="36">
</pre>
		
		<pre class="file" id="file4" style="display: none">package indexd_client

import (
        "context"
        "fmt"
        "log/slog"
        "net/url"
        "os"

        "github.com/calypr/data-client/common"
        "github.com/calypr/data-client/conf"
        dataClient "github.com/calypr/data-client/g3client"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/data-client/logs"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/drslog"
)

// Config holds configuration parameters for the GitDrsIdxdClient.
type Config struct {
        ProjectId          string
        BucketName         string
        Upsert             bool
        MultiPartThreshold int64
}

type GitDrsIdxdClient struct {
        Base   *url.URL
        Logger *slog.Logger
        G3     dataClient.Gen3Interface
        Config *Config
}

func NewGitDrsIdxdClient(profileConfig conf.Credential, remote Gen3Remote, logger *slog.Logger) (client.DRSClient, error) <span class="cov4" title="4">{
        baseUrl, err := url.Parse(profileConfig.APIEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="4">projectId := remote.GetProjectId()
        if projectId == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no gen3 project specified")
        }</span>

        <span class="cov3" title="3">bucketName := remote.GetBucketName()

        // Initialize data-client Gen3Interface with slog-adapted logger if needed,
        // or assume we use the one passed in if we update data-client to take slog.
        // For now we assume data-client/logs/TeeLogger is still used by data-client internals,
        // so we bridge it.
        dLogger, closer := logs.New(profileConfig.Profile, logs.WithBaseLogger(drslog.AsStdLogger(logger)))
        // Note: closer is ignored here
        _ = closer

        g3 := dataClient.NewGen3InterfaceFromCredential(&amp;profileConfig, dLogger)

        upsert, err := getLfsCustomTransferBool("lfs.customtransfer.drs.upsert", false)
        if err != nil </span>{
                return nil, err
        }
</span>        multiPartThresholdInt, err := getLfsCustomTransferInt("lfs.customtransfer.drs.multipart-threshold", 500)
        i</span>f err != nil {
                return nil, err
        <span class="cov10" title="36">}
        var multiPartThresho</span><span class="cov0" title="0">ld int64 = multiPartThresholdInt * common.MB

        c</span>onfig := &amp;Config{
                ProjectId:          projectId,
        <span class="cov10" title="36">        BucketName:         bucketName,
                Upsert:             upsert,
                MultiPartThreshold: multiPartThreshold,
        }

        return &amp;GitDrsIdxdClient{
                Base:   baseUrl,
                Logger: logger,
                G3:     g3,
                Config: config,
        }, nil
}

func (cl *GitDrsIdxdClient) GetProjectId() string {
</span>        return cl.Config.ProjectId
</span>}

func (cl *GitDrsIdxdClient) GetObject(ctx context.Context, id string) (*drs.DRSObject, error) {
        return cl.G3.Indexd().GetObject(ctx, id)
}
</span>
</span>func (cl *GitDrsIdxdClient) ListObjects(ctx context.Context) (chan drs.DRSObjectResult, error) {
        return cl.G3.Indexd().ListObjects(ctx)
}

</span>func (cl *GitDrsIdxdClient) ListObjectsByProject(ctx context.</span><span class="cov0" title="0">Context, projectId string) (chan drs.DRSObjectResult, error) {
        return cl.G3.Indexd().ListObjectsByProject(ctx, projectId)
}

</span>func (cl *GitDrsIdxdClient) GetDownloadURL(ctx context.Context, did string) (*drs.AccessURL, error) {
        // Delegate fully to data-client if possible?
        // data-client has GetDownloadURL but it might need accessType.
        /<span class="cov8" title="20">/ The wrapper logic here to get object first to find ac</span>cessType is specific logic.
        // Ideally data-client's GetDownloadURL handles this or we keep this logic here.

        <span class="cov10" title="36">// First get the object to find access methods
        obj, err := cl.GetObject(ctx, did)
        if err != nil {
                return nil, err
        }
        if len(obj.AccessMethods) == 0 {
                return nil, fmt.Errorf("no access methods for %s", did)
        }
</span>
        a</span>ccessType := obj.AccessMethods[0].Type
        res, err := cl.G3.Indexd().GetDownloadURL(ctx, did, accessType)
        <span class="cov10" title="36">if err != nil {
                return nil, err
        }
        return &amp;drs.AccessURL{URL: res.URL, Headers: res.Headers}, nil
}

func (cl *GitDrsIdxdClient) GetObjectByHash(ctx context.Context, sum *hash.Checksum) ([]drs.DRSObject, error) {
        res, err := cl.G3.Indexd().GetObjectByHash(ctx, string(sum.Type), sum.Checksum)
        if err != nil {
                return nil, err
        }
        out := make([]drs.DRSObject, len(res))
        for i, o := range res {
                out[i</span>] = o
        }
        // Filter by project ID logic is git-drs specific business logic (ensure we only see our project's files)
        resourcePath, _ := drs.ProjectToResource(cl.C<span class="cov7" title="12">onfig.ProjectId)
        filtered := make([]drs.DRSObject, 0)
        </span>for _, o := range out {
                found := false
                for _, am := range o.AccessMethods {
                        if am.Authorizations != nil &amp;&amp; am.Authorizations.Value == resourcePath {
                                found = true
                                break
                        }
                }
</span>                if found {
                </span>        filtered = append(filtered, o)
                }
        <span class="cov10" title="36">}
        return filtered, nil
}

</span>func (cl *GitDrsIdxdClient) DeleteRecordsByProject(ctx context.Context, projectId string) error {
        r</span>eturn cl.G3.Indexd().DeleteRecordsByProject(ctx, projectId)
}<span class="cov10" title="36">
</span>
func (cl *GitDrsIdxdClient) DeleteRecord(ctx context.Context, oid string) error {
        return cl.G3.Indexd().DeleteRecordByHash(ctx, oid, cl.Config.ProjectId)
}

func (cl *GitDrsIdxdClient) GetProjectSample(ctx context.Context, projectId string, limit int) ([]drs.DRSObject, error) {
        return cl.G3.Indexd().GetProjectSample(ctx, projectId, limit)
}
</span>
fu</span>nc (c *GitDrsIdxdClient) RegisterRecord(ctx context.Context, record *drs.DRSObject) (*drs.DRSObject, error) {
        return c.G3.Indexd().RegisterRecord(ctx, record)
}<span class="cov10" title="36">

func (c *GitDrsIdxdClient) UpdateRecord(ctx context.Context, updateInfo *drs.DRSObject, did string) (*drs.DRSObject, error) {
        return c.G3.In</span><span class="cov0" title="0">dexd().UpdateRecord(ctx, updateInfo, did)
}

</span>func (c *GitDrsIdxdClient) BuildDrsObj(fileName string, checksum string, size int64, drsId string) (*drs.DRSObject, error) {
        <span class="cov10" title="36">return drs.BuildDrsObj(fileNam</span><span class="cov0" title="0">e, checksum, size, drsId, c.Config.BucketName, c.Config.ProjectId)
}

</span>func (cl *GitDrsIdxdClient) GetGen3Interface() dataClient.Gen3Interface {
        <span class="cov10" title="36">return cl.G3
</span>}

func (cl *GitDrsIdxdClient) GetBucketName() string {
        return cl.Config.BucketName
}

</span>func (cl *GitDrsIdxdClient) GetUpsert() bool {
        r</span>eturn cl.Config.Upsert
}<span class="cov0" title="0">
</span>
// Helpers retained from original implementation
func getLfsCustomTransferBool(key string, defaultValue bool) (bool, err<span class="cov0" title="0">or) {
        cmd := os.Getenv("GIT_EXEC_PATH") // Dummy check
        _ = cmd
</span>        // Mocking for now to avoid too much exec
        r</span>eturn defaultValue, nil
}<span class="cov0" title="0">
</span>
</span>func getLfsCustomTransferInt(key string, defaultV</span><span class="cov0" title="0">alue int64) (int64, error) {
        return defaultValue, nil
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package indexd_client

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/calypr/data-client/common"
        drs "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/data-client/upload"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
)

// RegisterFile implements DRSClient.RegisterFile
// It registers (or reuses) an indexd record for the oid, uploads the object if it
// is not already available in the bucket, and returns the resulting DRS object.
func (cl *GitDrsIdxdClient) RegisterFile(oid string, progressCallback common.ProgressCallback) (*drs.DRSObject, error) <span class="cov0" title="0">{
        cl.Logger.Debug(fmt.Sprintf("register file started for oid: %s", oid))

        // load the DRS object from oid created by prepush
        drsObject, err := drsmap.DrsInfoFromOid(oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting drs object for oid %s: %v", oid, err)
        }</span>

        // Register the indexd record
        <span class="cov0" title="0">ctx := context.Background()
        _, err = cl.RegisterRecord(ctx, drsObject)
        if err != nil </span><span class="cov0" title="0">{
                // handle "already exists" error ie upsert behavior
                if strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        if !cl.Config.Upsert </span><span class="cov0" title="0">{
                                cl.Logger.Debug(fmt.Sprintf("indexd record already exists, proceeding for oid %s: did: %s err: %v", oid, drsObject.Id, err))
                        }</span> else<span class="cov0" title="0"> {
                                cl.Logger.Debug(fmt.Sprintf("indexd record already exists, deleting and re-adding for oid %s: did: %s err: %v", oid, drsObject.Id, err))
                                err = cl.DeleteRecord(ctx, oid)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error deleting existing indexd record oid %s: did: %s err: %v", oid, drsObject.Id, err)
                                }</span>
                                <span class="cov0" title="0">_, err = cl.RegisterRecord(ctx, drsObject)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error re-saving indexd record after deletion: oid %s: did: %s err: %v", oid, drsObject.Id, err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("error saving oid %s indexd record: %v", oid, err)
                }</span>
        }

        // Now attempt to upload the file if not already available
        <span class="cov0" title="0">downloadable, err := cl.isFileDownloadable(drsObject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error checking if file is downloadable: oid %s %v", oid, err)
        }</span>
        <span class="cov0" title="0">if downloadable </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("file %s is already available for download, skipping upload", oid))
                return drsObject, nil
        }</span>

        // Proceed to upload the file
        <span class="cov0" title="0">profile := cl.G3.GetCredential().Profile

        // Reuse the Gen3 interface
        g3 := cl.G3

        filePath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, oid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }</span>
        <span class="cov0" title="0">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening file %s: %v", filePath, err)
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cl.Logger.Debug(fmt.Sprintf("warning: error closing file %s: %v", filePath, err))
                }</span>
        }(file)

        // Use multipart threshold from config or default to 5GB
        <span class="cov0" title="0">multiPartThreshold := int64(5 * 1024 * 1024 * 1024) // 5GB default
        if cl.Config.MultiPartThreshold &gt; 0 </span><span class="cov0" title="0">{
                multiPartThreshold = cl.Config.MultiPartThreshold
        }</span>

        <span class="cov0" title="0">if drsObject.Size &lt; multiPartThreshold </span><span class="cov0" title="0">{
                cl.Logger.Debug(fmt.Sprintf("UploadSingle size: %d path: %s", drsObject.Size, filePath))
                err := upload.UploadSingle(context.Background(), profile, drsObject.Id, drsObject.Checksums.SHA256, filePath, cl.Config.BucketName, false, progressCallback)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("UploadSingle error: %s", err)
                }</span>
        } else<span class="cov0" title="0"> {
                cl.Logger.Debug(fmt.Sprintf("MultipartUpload size: %d path: %s", drsObject.Size, filePath))
                err = upload.MultipartUpload(
                        context.TODO(),
                        g3,
                        common.FileUploadRequestObject{
                                FilePath:     filePath,
                                Filename:     filepath.Base(filePath),
                                GUID:         drsObject.Id,
                                OID:          drsObject.Checksums.SHA256,
                                FileMetadata: common.FileMetadata{},
                                Bucket:       cl.Config.BucketName,
                                Progress:     progressCallback,
                        },
                        file, false,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("MultipartUpload error: %s", err)
                }</span>
        }
        <span class="cov0" title="0">return drsObject, nil</span>
}

// isFileDownloadable checks if a file is already available for download
func (cl *GitDrsIdxdClient) isFileDownloadable(drsObject *drs.DRSObject) (bool, error) <span class="cov0" title="0">{
        // Try to get a download URL - if successful, file is downloadable
        if len(drsObject.AccessMethods) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">accessType := drsObject.AccessMethods[0].Type
        _, err := cl.G3.Indexd().GetDownloadURL(context.Background(), drsObject.Id, accessType)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get a download URL, assume file is not downloadable
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package indexd_tests

import (
        "net/http"
        "sync"
)

// MockIndexdRecord represents a test record in the mock server
type MockIndexdRecord struct {
        Did      string
        FileName string
        Size     int64
        Hashes   map[string]string
        URLs     []string
        Authz    []string
}

// MockIndexdServer is a mock server for testing
type MockIndexdServer struct {
        records     map[string]*MockIndexdRecord
        hashIndex   map[string][]string
        recordMutex sync.RWMutex
        server      *http.Server
}

// MockAuthHandler is a mock authentication handler for testing
type MockAuthHandler struct{}

func (m *MockAuthHandler) RefreshAccessToken() (string, error) <span class="cov0" title="0">{
        return "mock-token", nil
}</span>

func (m *MockAuthHandler) GetAccessToken() string <span class="cov0" title="0">{
        return "mock-token"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package addref

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "add-ref &lt;drs_uri&gt; &lt;dst path&gt;",
        Short: "Add a reference to an existing DRS object via URI",
        Long:  "Add a reference to an existing DRS object, eg passing a DRS URI from AnVIL. Requires that the sha256 of the file is already in the cache",
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error {
                drsUri := args[0]
                dstPath := args[1]

                logger := drslog.GetLogger()

                logger.Debug(fmt.Sprintf("Adding reference to DRS object %s to %s", drsUri, dstPath))

                cfg, err := co</span>nfig.LoadConfig()
                if err != nil </span>{
                        </span>return err
                }</span>

                remoteName, er</span>r := cfg.GetRemoteOrDefault(remote)
                if err != nil </span>{
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        </span>return err
                }</span>

                client, err :=</span> cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span>{
                        </span>return err
                }</span>

                obj, err := cl</span>ient.GetObject(context.Background(), drsUri)
                if err != nil </span>{
                        </span>return err
                }</span>
                objSha := ""
</span>                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) </span>{
</span>                        if sumType == hash.ChecksumTypeSHA256.String() {
                                </span>objSha = sum
                        }
                <span class="cov0" title="0">}
</span>                if objSha == "" {
                        </span>return fmt.Errorf("object %s sha256 not available", drsUri)
                <span class="cov0" title="0">}
                dirPath := filepath.Dir(dstPath)
                _, err = os.Stat(dirPa</span><span class="cov0" title="0">th)
                if os.IsNotExist(err) {
                        // The directory does not exist
                        </span>os.MkdirAll(dirPath, os.ModePerm)
                }

                err = Crea</span>teLfsPointer(obj, dstPath)
                return err
        },
}

func CreateLfsPointer(drsObj *drs.DRSObject, dst string) error {
        </span>sumMap := hash.ConvertHashInfoToMap(drsObj.Checksums)
        if len(sumMap) == 0 {
                return fmt.Errorf("no checksums found for DRS object")
        }

        // find sha256 checksum
        var shaSum string
        for csType, cs := range sumMap {
                if csType == hash.ChecksumTypeSHA256.String() {
                        shaSum = cs
                        break
                }
        }
        if shaSum == "" {
                return fmt.Errorf("no sha256 checksum found for DRS object")
        }

        // create pointer file content
        pointerContent := "version https://git-lfs.github.com/spec/v1\n"
        pointerContent += fmt.Sprintf("oid sha256:%s\n", shaSum)
        pointerContent += fmt.Sprintf("size %d\n", drsObj.Size)

        // write to file
        err := os.WriteFile(dst, []byte(pointerContent), 0644)
        if err != nil {
                return fmt.Errorf("failed to write LFS pointer file: %w", err)
        }

        return nil
}

func init() {
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package addurl

import (
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

// AddURLCmd represents the add-url command
var AddURLCmd = &amp;cobra.Command{
        Use:   "add-url &lt;url&gt; &lt;sha256&gt;",
        Short: "Add a file to the Git DRS repo using an S3 URL",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 2 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 2 arguments (S3 URL and SHA256), received %d\n\nUsage: %s\n\nSee 'git drs add-url --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                myLogger := drslog.GetLogger()

                // set git config lfs.allowincompletepush = true
                configCmd := exec.Command("git", "config", "lfs.allowincompletepush", "true")
                if err := configCmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to configure git to push pointers: %v. Please change the .git/config file to include an [lfs] section with allowincompletepush = true", err)
                }</span>

                // Parse arguments
                <span class="cov0" title="0">s3URL := args[0]
                sha256 := args[1]
                awsAccessKey, _ := cmd.Flags().GetString(s3_utils.AWS_KEY_FLAG_NAME)
                awsSecretKey, _ := cmd.Flags().GetString(s3_utils.AWS_SECRET_FLAG_NAME)
                awsRegion, _ := cmd.Flags().GetString(s3_utils.AWS_REGION_FLAG_NAME)
                awsEndpoint, _ := cmd.Flags().GetString(s3_utils.AWS_ENDPOINT_URL_FLAG_NAME)
                remote, _ := cmd.Flags().GetString("remote")

                // if providing credentials, access key and secret must both be provided
                if (awsAccessKey == "" &amp;&amp; awsSecretKey != "") || (awsAccessKey != "" &amp;&amp; awsSecretKey == "") </span><span class="cov0" title="0">{
                        return errors.New("incomplete credentials provided as environment variables. Please run `export " + s3_utils.AWS_KEY_ENV_VAR + "=&lt;key&gt;` and `export " + s3_utils.AWS_SECRET_ENV_VAR + "=&lt;secret&gt;` to configure both")
                }</span>

                // if none provided, use default AWS configuration on file
                <span class="cov0" title="0">if awsAccessKey == "" &amp;&amp; awsSecretKey == "" </span><span class="cov0" title="0">{
                        myLogger.Debug("No AWS credentials provided. Using default AWS configuration from file.")
                }</span>

                <span class="cov0" title="0">cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">remoteName, err := cfg.GetRemoteOrDefault(remote)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remoteName, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting current remote client: %v", err)
                }</span>

                // Call client.AddURL to handle Gen3 interactions
                <span class="cov0" title="0">meta, err := drsClient.AddURL(s3URL, sha256, awsAccessKey, awsSecretKey, awsRegion, awsEndpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Generate and add pointer file
                <span class="cov0" title="0">_, relFilePath, err := utils.ParseS3URL(s3URL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse S3 URL: %w", err)
                }</span>
                <span class="cov0" title="0">if err := generatePointerFile(relFilePath, sha256, meta.Size); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate pointer file: %w", err)
                }</span>
                <span class="cov0" title="0">myLogger.Debug("S3 URL successfully added to Git DRS repo.")
                return nil</span>
        },
}

func init() <span class="cov10" title="45">{
        AddURLCmd.Flags().String(s3_utils.AWS_KEY_FLAG_NAME, os.Getenv(s3_utils.AWS_KEY_ENV_VAR), "AWS access key")
        AddURLCmd.Flags().String(s3_utils.AWS_SECRET_FLAG_NAME, os.Getenv(s3_utils.AWS_SECRET_ENV_VAR), "AWS secret key")
        AddURLCmd.Flags().String(s3_utils.AWS_REGION_FLAG_NAME, os.Getenv(s3_utils.AWS_REGION_ENV_VAR), "AWS S3 region")
        AddURLCmd.Flags().String(s3_utils.AWS_ENDPOINT_URL_FLAG_NAME, os.Getenv(s3_utils.AWS_ENDPOINT_URL_ENV_VAR), "AWS S3 endpoint")
        AddURLCmd.Flags().String("remote", "", "target remote DRS server (default: default_remote)")
}</span>

func generatePointerFile(filePath string, sha256 string, fileSize int64) error <span class="cov1" title="1">{
        // Define the pointer file content
        pointerContent := fmt.Sprintf("version https://git-lfs.github.com/spec/v1\noid sha256:%s\nsize %d\n", sha256, fileSize)

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory for pointer file: %w", err)
        }</span>

        // Write the pointer file
        <span class="cov1" title="1">if err := os.WriteFile(filePath, []byte(pointerContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write pointer file: %w", err)
        }</span>

        // Add the pointer file to Git
        <span class="cov1" title="1">cmd := exec.Command("git", "add", filePath)
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add pointer file to Git: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "encoding/csv"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var Cmd = &amp;cobra.Command{
        Use:   "create-cache &lt;manifest.tsv&gt;",
        Short: "create a local version of a file manifest containing DRS URIs",
        Long:  "create a local version of a file manifest containing DRS URIs. Enables LFS to map its file object id (sha256) back to a DRS URI by file",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                file := args[0]

                // load file
                f, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open manifest file: %w", err)
                }</span>
                <span class="cov0" title="0">defer f.Close()

                // Use encoding/csv with tab delimiter for TSV
                r := csv.NewReader(f)
                r.Comma = '\t'

                // Read header
                header, err := r.Read()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read header: %w", err)
                }</span>

                // Map column names to indices
                <span class="cov0" title="0">colIdx := make(map[string]int, len(header))
                for i, col := range header </span><span class="cov0" title="0">{
                        colIdx[col] = i
                }</span>

                // Check required columns
                <span class="cov0" title="0">shaIdx, shaOk := colIdx["files.sha256"]
                drsIdx, drsOk := colIdx["files.drs_uri"]
                if !shaOk || !drsOk </span><span class="cov0" title="0">{
                        return fmt.Errorf("manifest must contain 'files.sha256' and 'files.drs_uri' columns")
                }</span>

                // Read each row
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        row, err := r.Read()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("error reading manifest file: %w", err)</span>
                        }
                        <span class="cov0" title="0">sha := row[shaIdx]
                        drsURI := row[drsIdx]
                        fmt.Printf("Indexing DRS URI %s with sha256 %s\n", drsURI, sha)

                        // create sha to DRS URI mapping
                        objPath, err := drsmap.GetObjectPath(projectdir.DRS_REF_DIR, sha)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get object path for %s: %w", sha, err)
                        }</span>

                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(objPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", objPath, err)
                        }</span>

                        <span class="cov0" title="0">contents := fmt.Sprintf("files.drs_uri\n%s\n", drsURI)
                        if err := os.WriteFile(objPath, []byte(contents), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write DRS URI for %s: %w", sha, err)
                        }</span>

                        // Split DRS URI into a custom path and write sha to custom path
                        <span class="cov0" title="0">customPath, err := drsmap.CreateCustomPath(projectdir.DRS_REF_DIR, drsURI)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create custom path for %s: %w", drsURI, err)
                        }</span>
                        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(customPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create dir for %s: %w", customPath, err)
                        }</span>
                        <span class="cov0" title="0">if err := os.WriteFile(customPath, []byte(sha), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write sha for %s: %w", drsURI, err)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Cache created in %s\n", projectdir.DRS_REF_DIR)
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package delete

import (
        "context"
        "fmt"
        "os"

        "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag bool
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete &lt;hash-type&gt; &lt;oid&gt;",
        Short:  "Delete a file using hash and file object ID",
        Long:   "Delete a file using file object ID. Use lfs ls-files to get oid",
        Hidden: true,
        Args:   cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error {
                hashType, oid := args[0], args[1]

                // check hash type is valid Checksum type and sh</span>a256
                if hashType != hash.ChecksumTypeSHA256.String() </span>{
                        </span>return fmt.Errorf("only sha256 supported, you requested to remove: %s", hashType)
                }</span>

                logger := drslog.GetLogger()

                cfg, err := co</span>nfig.LoadConfig()
                if err != nil </span>{
                        </span>return fmt.Errorf("error loading config: %v", err)
                }</span>

                remoteName, er</span>r := cfg.GetRemoteOrDefault(remote)
                if err != nil </span>{
                        </span>return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                drsClient, err</span> := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span>{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        </span>return err
                }</span>

                <span class="cov0" title="0">// Get record details before deletion for confirmation
                records, err :</span>= drsClient.GetObjectByHash(context.Background(), &amp;hash.Checksum{Type: hash.ChecksumTypeSHA256, Checksum: oid})
                if err != nil </span>{
                        </span>return fmt.Errorf("error getting records for OID %s: %v", oid, err)
                }</span>
</span>                if len(records) == 0 {
                        </span>return fmt.Errorf("no records found for OID %s", oid)
                }

                <span class="cov0" title="0">// Find matching record for current project
                projectId := drsClient.GetProjectId()
                matchingRecord</span><span class="cov0" title="0">, err := drsmap.FindMatchingRecord(records, projectId)
                if err != nil {
                        </span>return fmt.Errorf("error finding matching record for project %s: %v", projectId, err)
                <span class="cov0" title="0">}
</span>                if matchingRecord == nil {
                        </span>return fmt.Errorf("no matching record found for project %s and OID %s", projectId, oid)
                }

                <span class="cov0" title="0">// Show details </span><span class="cov0" title="0">and get confirmation unless --confirm flag is set
                if !confirmFlag {
                        utils.DisplayWarningHeader(os.Stderr, "DELETE a DRS record")
                        utils.DisplayField(os.Stderr, "Remote", string(remoteName))
                        utils.DisplayField(os.Stderr, "Project", projectId)
                        utils.DisplayField(os.Stderr, "OID", oid)
                        utils.DisplayField(os.Stderr, "Hash Type", hashType)
                        utils.DisplayField(os.Stderr,</span><span class="cov0" title="0"> "DID", matchingRecord.Id)
                        if matchingRecord.Name != "" {
                                </span>utils.DisplayField(os.Stderr, "Filename", matchingRecord.Name)
                        <span class="cov0" title="0">}
                        utils.DisplayField(os.Stderr, "Size", fmt.Sprintf("%d bytes", matchingRecord.Size))
                        utils.DisplayFooter(os.Stderr)

</span>                        if err := utils.PromptForConfirmation(os.Stderr, "Type 'yes' to confirm deletion", utils.ConfirmationYes, false); err != nil {
                                </span>return err
                        }
                }

                <span class="cov0" title="0">// Delete the matching record
                err = drsClien</span><span class="cov0" title="0">t.DeleteRecord(context.Background(), oid)
                if err != nil {
                        </span>return fmt.Errorf("error deleting file for OID %s: %v", oid, err)
                }

                logger.Deb</span>ug(fmt.Sprintf("Successfully deleted record for OID %s", oid))
                return nil
        },
}

func init() {
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        </span>Cmd.Flags().BoolVar(&amp;confirmFlag, "confirm", false, "skip interactive confirmation prompt")
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package deleteproject

import (
        "context"
        "fmt"
        "os"

        indexdCl "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var (
        remote      string
        confirmFlag string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:    "delete-project &lt;project_id&gt;",
        Short:  "Delete all indexd records for a given project",
        Long:   "Delete all indexd records for a given project",
        Hidden: true,
        Args:   cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
                projectId := args[0]
                logger := drslog.GetLogger()

                cfg, err := co</span>nfig.LoadConfig()
                if err != nil </span>{
                        </span>return fmt.Errorf("error loading config: %v", err)
                }</span>

                remoteName, er</span>r := cfg.GetRemoteOrDefault(remote)
                if err != nil </span>{
                        </span>return fmt.Errorf("error getting default remote: %v", err)
                }</span>

                drsClient, err</span> := cfg.GetRemoteClient(remoteName, logger)
                if err != nil </span>{
                        logger.Error(fmt.Sprintf("error creating indexd client: %s", err))
                        </span>return err
                }</span>

                <span class="cov0" title="0">// Cast to GitDrsIdxdClient to access GetProjectSample
                indexdC</span>lient, ok := drsClient.(*indexdCl.GitDrsIdxdClient)
                if !ok </span>{
                        </span>return fmt.Errorf("client is not an IndexDClient, cannot proceed with delete-project")
                }</span>

                <span class="cov0" title="0">// Get a sample record to show the user what will be deleted
                sampleRecords,</span> err := indexdClient.GetProjectSample(context.Background(), projectId, 1)
                if err != nil </span>{
                        </span>return fmt.Errorf("error getting sample records for project %s: %v", projectId, err)
                }</span>

                <span class="cov0" title="0">// Show details and get confirmation unless --con</span><span class="cov0" title="0">firm flag matches project_id
                if confirmFlag != "" &amp;&amp; confirmFlag != projectId {
                        </span>return fmt.Errorf("error: --confirm value '%s' does not match project ID '%s'", confirmFlag, projectId)
                <span class="cov0" title="0">}
</span>                if confirmFlag != projectId {
                        utils.DisplayWarningHeader(os.Stderr, "DELETE ALL RECORDS for a project")
                        utils.DisplayField(os.Stderr, "Remote", string(remoteName))
                        utils.DisplayField(os.Stderr, "Project ID", projectId)

</span>                        if len(sampleRecords) &gt; 0 {
                                sample := sampleRecords[0]
                                fmt.Fprintf(os.Stderr, "\nSample record from this project:\n")
                                utils.DisplayField(os</span><span class="cov0" title="0">.Stderr, "  DID", sample.Id)
                                if sample.Name != "" {
                                        </span>utils.DisplayField(os.Stderr, "  Filename", sample.Name)
                                <span class="cov0" title="0">}
                                utils.DisplayField(os.Stderr</span><span class="cov0" title="0">, "  Size", fmt.Sprintf("%d bytes", sample.Size))
                                if sample.CreatedTime != "" {
                                        </span>utils.DisplayField(os.Stderr, "  Created", sample.CreatedTime)
                                }
                        } else {
                                </span>fmt.Fprintf(os.Stderr, "\nNo records found for this project.\n")
                        }

                        fmt.Fprintf(os.Stderr, "\nThis will DELETE ALL records in project '%s'.\n", projectId)
                        utils.DisplayFooter(os.Stderr)

</span>                        if err := utils.PromptForConfirmation(os.Stderr, fmt.Sprintf("Type the project ID '%s' to confirm deletion", projectId), projectId, true); err != nil {
                                </span>return err
                        }
                }

                <span class="cov0" title="0">// Delete the matching records
                logger.Debug(fmt.Sprintf("Deleting all records for project %s...", projectId))
                err = drsClien</span><span class="cov0" title="0">t.DeleteRecordsByProject(context.Background(), projectId)
                if err != nil {
                        </span>return fmt.Errorf("error deleting project %s: %v", projectId, err)
                }

                logger.Deb</span>ug(fmt.Sprintf("Successfully deleted all records for project %s", projectId))
                return nil
        },
}

func init() {
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        </span>Cmd.Flags().StringVar(&amp;confirmFlag, "confirm", "", "skip interactive confirmation by providing the project_id (e.g., --confirm my-project)")
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package download

import (
        "context"
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/spf13/cobra"
)

var (
        dstPath string
        remote  string
)

// Cmd line declaration
// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "download &lt;oid&gt;",
        Short: "Download file using file object ID",
        Long:  "Download file using file object ID (sha256 h<span class="cov0" title="0">ash). Use lfs ls-files to get oid",
        Args: func(cmd *cob</span><span class="cov0" title="0">ra.Command, args []string) error {
                if len(args) != 1 {
                        cmd.SilenceUsage = false
                        </span>return fmt.Errorf("error: requires exactly 1 argument (file object ID), received %d\n\nUsage: %s\n\nSee 'git drs download --help' for more details", len(args), cmd.UseLine())
                <span class="cov0" title="0">}
</span>                return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
                logger := drslog.GetLogger()

                oid := args[0]

                cfg, err := co</span><span class="cov0" title="0">nfig.LoadConfig()
                if err != nil {
                        </span>return fmt.Errorf("error loading config: %v", err)
                }

                remoteName, er</span><span class="cov0" title="0">r := cfg.GetRemoteOrDefault(remote)
                if err != nil {
                        </span>return fmt.Errorf("error getting default remote: %v", err)
                }

                drsClient, err</span><span class="cov0" title="0"> := cfg.GetRemoteClient(remoteName, logger)
                if err != nil {
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        </span>return err
                }

                <span class="cov0" title="0">// get signed url
                accessUrl, err</span><span class="cov0" title="0"> := drsClient.GetDownloadURL(context.Background(), oid)
                if err != nil {
                        </span>return fmt.Errorf("Error downloading file for OID %s: %v", oid, err)
                <span class="cov0" title="0">}
</span>                if accessUrl.URL == "" {
                        </span>return fmt.Errorf("Unable to get access URL %s", oid)
                }

                <span class="cov0" title="0">// download url t</span><span class="cov0" title="0">o destination path or LFS objects if not specified
                if dstPath == "" {
                        </span>dstPath, err = drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, oid)
                <span class="cov0" title="0">}
</span>                if err != nil {
                        </span>return fmt.Errorf("Error getting destination path for OID %s: %v", oid, err)
                <span class="cov0" title="0">}
                err = s3_utils</span><span class="cov0" title="0">.DownloadSignedUrl(accessUrl.URL, dstPath)
                if err != nil {
                        </span>return fmt.Errorf("Error downloading file for OID %s: %v", oid, err)
                }

</span>                if err != nil {
                        </span>return fmt.Errorf("\nerror downloading file object ID %s: %s", oid, err)
                }

                logger.Debug("file downloaded")

</span>                return nil
        },
}

func init() {
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        </span>Cmd.Flags().StringVarP(&amp;dstPath, "dst", "d", "", "Destination path to save the downloaded file")
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package fetch

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "fetch [remote-name]",
        Short: "fetch drs objects from remote",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs fetch --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error loading config: %v", err)
                }</span>

                <span class="cov0" title="0">var remote config.Remote
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        remote = config.Remote(args[0])
                }</span> else<span class="cov0" title="0"> {
                        remote, err = cfg.GetDefaultRemote()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                                return err
                        }</span>
                }

                <span class="cov0" title="0">drsClient, err := cfg.GetRemoteClient(remote, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("\nerror creating DRS client: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">err = drsmap.PullRemoteDrsObjects(drsClient, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package initialize

import (
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var transfers int

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize repo for git-drs",
        Long: "Description:" +
                "\n  Initialize repo for git-drs",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov4" title="4">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs init --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov4" title="4">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov4" title="4">{
                logg := drslog.GetLogger()

                // check if .git dir exists to ensure you're in a git repository
                _, err := utils.GitTopLevel()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: not in a git repository. Please run this command in the root of your git repository")
                }</span>

                // create config file if it doesn't exist
                <span class="cov4" title="4">err = config.CreateEmptyConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: unable to create config file: %v", err)
                }</span>

                // load the config
                <span class="cov4" title="4">_, err = config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("We should probably fix this: %v", err))
                        return fmt.Errorf("error: unable to load config file: %v", err)
                }</span>

                // setup lfs custom transfer
                // TODO: may need to generalize for anvil
                <span class="cov4" title="4">err = initGitConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error initializing custom transfer for DRS: %v", err)
                }</span>

                // install pre-push hook
                <span class="cov4" title="4">err = installPrePushHook(logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error installing pre-push hook: %v", err)
                }</span>

                // final logs
                <span class="cov4" title="4">logg.Debug("Git DRS initialized")
                logg.Debug(fmt.Sprintf("Using %d concurrent transfers", transfers))
                return nil</span>
        },
}

func initGitConfig() error <span class="cov4" title="5">{
        configs := [][]string{
                {"lfs.standalonetransferagent", "drs"},
                {"lfs.customtransfer.drs.path", "git-drs"},
                {"lfs.customtransfer.drs.args", "transfer"},
                // TODO: different for anvil / read-only?
                {"lfs.allowincompletepush", "false"},
                {"lfs.customtransfer.drs.concurrent", strconv.FormatBool(transfers &gt; 1)},
                {"lfs.customtransfer.drs.concurrenttransfers", strconv.Itoa(transfers)},
        }

        for _, args := range configs </span><span class="cov9" title="30">{
                cmd := exec.Command("git", "config", args[0], args[1])
                if cmdOut, err := cmd.Output(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to set git config %s: %s", args[0], cmdOut)
                }</span>
        }

        <span class="cov4" title="5">return nil</span>
}

func init() <span class="cov10" title="45">{
        Cmd.Flags().IntVarP(&amp;transfers, "transfers", "t", 4, "Number of concurrent transfers")
}</span>

func installPrePushHook(logger *slog.Logger) error <span class="cov5" title="6">{
        cmd := exec.Command("git", "rev-parse", "--git-dir")
        cmdOut, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to locate git directory: %w", err)
        }</span>
        <span class="cov5" title="6">gitDir := strings.TrimSpace(string(cmdOut))
        hooksDir := filepath.Join(gitDir, "hooks")
        if err := os.MkdirAll(hooksDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create hooks directory: %w", err)
        }</span>

        <span class="cov5" title="6">hookPath := filepath.Join(hooksDir, "pre-push")
        hookBody := `
# . git/hooks/pre-push
remote="$1"
url="$2"

# Buffer stdin for both commands
TMPFILE="${TMPDIR:-/tmp}/git-drs-$$"
trap "rm -f $TMPFILE" EXIT
cat &gt; "$TMPFILE"

# Run DRS preparation
git drs pre-push-prepare "$remote" "$url" &lt; "$TMPFILE" || exit 1

# Run LFS push
exec git lfs pre-push "$remote" "$url" &lt; "$TMPFILE"
`
        hookScript := "#!/bin/sh\n" + hookBody

        existingContent, err := os.ReadFile(hookPath)
        if err == nil </span><span class="cov3" title="3">{
                // there is an existing hook, rename it, and let the user know
                // Backup existing hook with timestamp
                timestamp := time.Now().Format("20060102T150405")
                backupPath := hookPath + "." + timestamp
                if err := os.WriteFile(backupPath, existingContent, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to back up existing pre-push hook: %w", err)
                }</span>
                <span class="cov3" title="3">if err := os.Remove(hookPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to remove hook after backing up: %w", err)
                }</span>
                <span class="cov3" title="3">logger.Debug(fmt.Sprintf("pre-push hook updated; backup written to %s", backupPath))</span>
        }
        // If there was an error other than expected not existing, return it
        <span class="cov5" title="6">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to read pre-push hook: %w", err)
        }</span>

        <span class="cov5" title="6">err = os.WriteFile(hookPath, []byte(hookScript), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write pre-push hook: %w", err)
        }</span>
        <span class="cov5" title="6">logger.Debug("pre-push hook installed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package list

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var (
        outJson     bool = false
        outFile     string
        listOutFile string
        remote      string
)

var checksumPref = []hash.ChecksumType{hash.ChecksumTypeSHA256, hash.ChecksumTypeMD5, hash.ChecksumTypeETag}

func getChecksumPos(q</span><span class="cov0" title="0"> hash.ChecksumType, a []hash.ChecksumType) int {
        for i, s :=</span> range a </span>{
                if q == s {
                        </span>return i
                }
        <span class="cov0" title="0">}
</span>        return -1
}

// Pick out the most preferred checksum to dis<span class="cov0" title="0">play
func getCheckSumStr(obj drs.DRSObject) string {
        curPos := len(checksumPref) + 1
        curVal := ""
</span>        for checksumType, checksum := range hash.ConvertHashInfoToMap(obj.Checksums) {
                c := getChecksumPos(hash.</span><span class="cov0" title="0">ChecksumType(checksumType), checksumPref)
                if c != -1 &amp;&amp; c &lt; curPos {
                        curPos = c
                        </span>curVal = checksumType + ":" + checksum
                }
        <span class="cov0" title="0">}
</span>        return curVal
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS entities from server",
        Args: func(cmd *cob</span><span class="cov0" title="0">ra.Command, args []string) error {
                if len(args) != 0 {
                        cmd.SilenceUsage = false
                        </span>return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list --help' for more details", len(args), cmd.UseLine())
                <span class="cov0" title="0">}
</span>                return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
                logger := drslog.GetLogger()

                var outWriter io.Writ</span><span class="cov0" title="0">er
                if listOutFile != "" {
                        f, err := os.C</span><span class="cov0" title="0">reate(listOutFile)
                        if err != nil {
                                </span>return err
                        <span class="cov0" title="0">}
                        defer f.Close</span>()
                        outWr<span class="cov0" title="0">iter = f
                } else {
                        </span>outWriter = os.Stdout
                }

                conf, err := c</span><span class="cov0" title="0">onfig.LoadConfig()
                if err != nil {
                        </span>return fmt.Errorf("error loading config: %v", err)
                }

                remoteName, er</span><span class="cov0" title="0">r := conf.GetRemoteOrDefault(remote)
                if err != nil {
                        </span>return fmt.Errorf("error getting default remote: %v", err)
                }

                client, err :=</span><span class="cov0" title="0"> conf.GetRemoteClient(remoteName, logger)
                if err != nil {
                        logger.Debug("Client failed")
                        </span>return err
                <span class="cov0" title="0">}
                objChan, err :</span><span class="cov0" title="0">= client.ListObjects(context.Background())
                if err != nil {
                        </span>return err
                <span class="cov0" title="0">}
</span>                if !outJson {
                        </span>fmt.Fprintf(outWriter, "%-55s\t%-15s\t%-75s\t%s\n", "URI", "Size", "Checksum", "Name")
                }

                <span class="cov0" title="0">// for each result, check for e</span><span class="cov0" title="0">rror and print
                for objResult := range objC</span><span class="cov0" title="0">han {
                        if objResult.Error != nil {
                                </span>return objResult.Error
                        <span class="cov0" title="0">}
                        obj := objR</span><span class="cov0" title="0">esult.Object
                        if outJson {
                                out, err := so</span><span class="cov0" title="0">nic.ConfigFastest.Marshal(*obj)
                                if err != nil {
                                        </span>return err
                                <span class="cov0" title="0">}
</span>                                fmt.F<span class="cov0" title="0">printf(outWriter, "%s\n", string(out))
                        } else {
                                </span>fmt.Fprintf(outWriter, "%s\t%-15d\t%-75s\t%s\n", obj.SelfURI, obj.Size, getCheckSumStr(*obj), obj.Name)
                        }
                <span class="cov0" title="0">}
</span>                return nil
        },
}
var ListProjectCmd = &amp;cobra.Command{
        Use:   "list-project &lt;project-id&gt;",
        Short: "List DRS entities from server",
        Args: func(cmd *cob</span><span class="cov0" title="0">ra.Command, args []string) error {
                if len(args) != 1 {
                        cmd.SilenceUsage = false
                        </span>return fmt.Errorf("error: requires exactly 1 argument (project ID), received %d\n\nUsage: %s\n\nSee 'git drs list-project --help' for more details", len(args), cmd.UseLine())
                <span class="cov0" title="0">}
</span>                return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
                logger := drslog.GetLogger()

                conf, err := c</span><span class="cov0" title="0">onfig.LoadConfig()
                if err != nil {
                        </span>return fmt.Errorf("error loading config: %v", err)
                }

                remoteName, er</span><span class="cov0" title="0">r := conf.GetRemoteOrDefault(remote)
                if err != nil {
                        </span>return fmt.Errorf("error getting default remote: %v", err)
                }

                client, err :=</span><span class="cov0" title="0"> conf.GetRemoteClient(remoteName, logger)
                if err != nil {
                        </span>return err
                <span class="cov0" title="0">}
                objChan, err :</span><span class="cov0" title="0">= client.ListObjectsByProject(context.Background(), args[0])
                if err != nil {
                        </span>return err
                }

                var f *os.File
                var outWriter io.</span><span class="cov0" title="0">Writer
                if outFile != "" {
                        f, err = os.Cr</span><span class="cov0" title="0">eate(outFile)
                        if err != nil {
                                </span>return err
                        <span class="cov0" title="0">}
                        defer f.Close</span>()
                        outWr<span class="cov0" title="0">iter = f
                } else {
                        </span>outWriter = os.Stdout
                <span class="cov0" title="0">}
</span>                for objResult := range objC</span><span class="cov0" title="0">han {
                        if objResult.Error != nil {
                                </span>return objResult.Error
                        <span class="cov0" title="0">}
                        obj := objResult.Object
                        out, err := so</span><span class="cov0" title="0">nic.ConfigFastest.Marshal(*obj)
                        if err != nil {
                                </span>return err
                        <span class="cov0" title="0">}
                        _, err = outWr</span><span class="cov0" title="0">iter.Write(out)
                        if err != nil {
                                </span>return err
                        <span class="cov0" title="0">}
                        _, err = outWr</span><span class="cov0" title="0">iter.Write([]byte("\n"))
                        if err != nil {
                                </span>return err
                        }
                <span class="cov0" title="0">}
</span>                return nil
        },
}

func init() {
        ListProjectCmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        ListProjectCmd.Flags().StringVarP(&amp;outFile, "out", "o", outFile, "File path to save output to")
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().StringVarP(&amp;listOutFile, "out", "o", listOutFile, "File path to save output to")
        </span>Cmd.Flags().BoolVarP(&amp;outJson, "json", "j", outJson, "Output formatted as JSON")
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package listconfig

import (
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        jsonOutput bool
)

// Cmd represents the list-config command
var Cmd = &amp;cobra.Command{
        Use:   "list-config",
        Short: "Display the current configuration",
        Long:  "Pretty prints the current configuration file in YAML format",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs list-config --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Load the current configuration
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                        // Output as JSON if requested
                        encoder := sonic.ConfigFastest.NewEncoder(os.Stdout)
                        encoder.SetIndent("", "  ")
                        return encoder.Encode(cfg)
                }</span> else<span class="cov0" title="0"> {
                        // Default YAML output with nice formatting
                        encoder := yaml.NewEncoder(os.Stdout)
                        encoder.SetIndent(2)
                        defer encoder.Close()

                        return encoder.Encode(cfg)
                }</span>
        },
}

func init() <span class="cov10" title="45">{
        Cmd.Flags().BoolVarP(&amp;jsonOutput, "json", "j", false, "output in JSON format")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package prepush

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "sort"
        "strings"

        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "pre-push-prepare",
        Short: "pre-push hook to update DRS objects",
        Long:  "Pre-push hook that updates DRS objects before transfer",
        Args:  cobra.RangeArgs(0, 2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                //myLogger := drslog.GetLogger()
                myLogger, err := drslog.NewLogger("", false)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating logger: %v", err)
                }</span>

                <span class="cov10" title="4">myLogger.Debug("~~~~~~~~~~~~~ START: pre-push ~~~~~~~~~~~~~")

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting config: %v", err)
                }</span>

                //Command-line arguments: The hook receives two parameters:
                //* The name of the remote (e.g., origin).
                //* The remote's location/URL (e.g., github.com).
                // Create gitRemoteName and gitRemoteLocation from args.
                <span class="cov10" title="4">myLogger.Debug(fmt.Sprintf("pre-push args: %v", args))
                var gitRemoteName, gitRemoteLocation string
                if len(args) &gt;= 1 </span><span class="cov10" title="4">{
                        gitRemoteName = args[0]
                }</span>
                <span class="cov10" title="4">if len(args) &gt;= 2 </span><span class="cov10" title="4">{
                        gitRemoteLocation = args[1]
                }</span>
                <span class="cov10" title="4">if gitRemoteName == "" </span><span class="cov0" title="0">{
                        gitRemoteName = "origin"
                }</span>
                <span class="cov10" title="4">myLogger.Debug(fmt.Sprintf("git remote name: %s, git remote location: %s", gitRemoteName, gitRemoteLocation))

                // get the default remote from the .git/drs/config
                var remote config.Remote
                remote, err = cfg.GetDefaultRemote()
                if err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("Warning. Error getting default remote: %v", err))
                        // Print warning to stderr and return success (exit 0)
                        fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting default remote:", err)
                        return nil
                }</span>

                // get the remote client
                <span class="cov10" title="4">cli, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil </span><span class="cov0" title="0">{
                        // Print warning to stderr and return success (exit 0)
                        fmt.Fprintln(os.Stderr, "Warning. Skipping DRS preparation. Error getting remote client:", err)
                        myLogger.Debug(fmt.Sprintf("Warning. Skipping DRS preparation. Error getting remote client: %v", err))
                        // Check for GitDrsIdxdClient
                }</span>
                <span class="cov0" title="0">dc, ok := cli.(*indexd_client.GitDrsIdxdClient)
                if !ok </span>{
                        return</span> fmt.Errorf("cli is not IndexdClient: %T", cli)
                }</span>
                m</span>yLogger.Debug(fmt.Sprintf("Current server: %s", dc.Config.ProjectId))

                // Buffer stdin to a temp file and invoke `git lfs pre-push &lt;remote&gt; &lt;url&gt;` with same args and stdin.
                tmp, err := os.CreateTemp("", "prepush-stdin-*")
                if err != nil </span>{
                        myLogger.Debu</span>g(fmt.Sprintf("error creating temp file for stdin: %v", err))
                        return err
                }</span>
                d</span>efer func() </span><span class="cov0" title="0">{
                        _ = tmp.Close()
                        _ = os.Remove(tmp.Name())
                }</span></span>()

</span>                // Copy all of stdin into the temp file.
                <span class="cov0" title="0">if _, err := io.Copy(tmp, os.Stdin); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("error buffering stdin: %v", err))
                        return err
                }</span></span>

</span>                // Rewind to start so the child process can read it.
                <span class="cov0" title="0">if _, err := tmp.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                        myLogger.Debug(fmt.Sprintf("error seeking temp stdin: %v", err))
                        return err
                }</span></span>

</span>                // read the temp file and get a list of all unique local branches being pushed
                <span class="cov0" title="0">branches, err := readPushedBranches(tmp)
                if err != nil </span>{
                        myLogger.Debu</span>g(fmt.Sprintf("error reading pushed branches: %v", err))
                        return err
                }</span>

</span>                <span class="cov0" title="0">myLogger.Debug(fmt.Sprintf("Preparing DRS objects for push branches: %v", branches))
                err = drsmap.UpdateDrsObjects(cli, gitRemoteName, gitRemoteLocation, branches, myLogger)
                if err != nil </span>{
                        myLogger.Debu</span>g(fmt.Sprintf("UpdateDrsObjects failed: %v", err))
                        return err
                }</span>
                m</span>yLogger.Debug("DRS objects prepared for push!")

                myLogger.Debug("~~~~~~~~~~~~~ COMPLETED: pre-push ~~~~~~~~~~~~~")
                return nil</span>
        },
</span>}

// readPushedBranches reads git push lines from the provided temp file,
// extracts unique local branch names for refs under `refs/heads/` and
// returns them sorted. The file is rewound to the start before returning.
func readPushedBranches(f *os.File) ([]string, error) <span class="cov0" title="0">{
        // Ensure we read from start
        // example:
        // refs/heads/main 67890abcdef1234567890abcdef1234567890abcd refs/heads/main 12345abcdef67890abcdef1234567890abcdef12
        if _, err := f.Seek(0, 0); err != nil </span>{
                return nil, err
</span>        }</span>
        s</span>canner := bufio.NewScanner(f)
        set := make(map[string]struct{})
        for scanner.Scan() </span>{
                line := scanner.Te</span>xt()
                fields := strings.Fields(line)
                if len(fields) &lt; 1 </span>{
                        continue
</span>                }
</span>                localRef := fields[0]
                <span class="cov10" title="4">const prefix = "refs/heads/"
                if strings.HasPrefix(localRef, prefix) {
                        branch := strings.TrimPrefix(localRef,</span><span class="cov10" title="4"> prefix)
                        if branch != "" {
                                set[branch] = s</span><span class="cov10" title="4">truct{}{}
                        }
                }
</span>        }
        if err := scanner.Err(); err != nil {
        <span class="cov10" title="4">        return nil, err
</span>        }
        b</span>ranches := make([]string, 0, len(set))
        <span class="cov10" title="4">for b := range set {
                branches = append(</span><span class="cov10" title="4">branches, b)
        }
        s</span>ort.Strings(branches)
        <span class="cov10" title="4">// Rewind so caller can reuse the file
        if _, err := f.Seek(0, 0); err != nil {
                return nil, err
</span>        }
        r</span>eturn branches, nil
}<span class="cov10" title="4">
</pre>
		
		<pre class="file" id="file18" style="display: none">package push

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/spf13/cobra"

        indexdCl "github.com/calypr/git-drs/client/indexd"
)

var Cmd = &amp;cobra.Command{
        Use:   "push [remote-name]",
        Short: "push local objects to drs server.",
        Long:  "push local</span><span class="cov0" title="0"> objects to drs server. Any local files that do not have drs records are written to a bucket.",
        Args: func(cmd *cobra.Command, args []string) error {
                if len(args) &gt; 1 {
                        </span>cmd.SilenceUsage = false
                <span class="cov0" title="0">        return fm</span>t.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs push --help' for more details", len(args), cmd.UseLine())
                }
                return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
                myLogger := dr</span><span class="cov0" title="0">slog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil {
                        </span>myLogger.Debug(fmt.Sprintf("Error loading config: %v", err))
                        return err
                <span class="cov0" title="0">}

</span>                var remote config.Remote
                i</span>f len<span class="cov0" title="0">(args) &gt; 0 {
                        remote = config.Remote(args[0])
                } else {
</span>                        remote, err = cfg.GetDefaultRemote()
                        if err != nil {
                                </span>myLogger.Debug(fmt.Sprintf("Error getting default remote: %v", err))
                                return err
                        }
                <span class="cov0" title="0">}

</span>                drsClient, err := cfg.GetRemoteClient(remote, myLogger)
                if err != nil {
                        </span>myLogger.Debug(fmt.Sprintf("Error creating indexd client: %s", err))
                        return err
                <span class="cov0" title="0">}

</span>                // Check for GitDrsIdxdClient
                i</span>cli, ok := drsClient.(*indexdCl.GitDrsIdxdClient)
                if !ok {
                <span class="cov0" title="0">        return fm</span>t.Errorf("remote client is not an *indexdCl.IndexDClient (got %T), cannot push", drsClient)
                }

                err = drsmap.PushLocalDrsObjects(drsClient, icli.GetGen3Interface(), icli.GetBucketName(), icli.GetUpsert(), myLogger)
                if err != nil {
                        return err
                }

                return nil
        },
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package query

import (
        "context"
        "fmt"

        "github.com/bytedance/sonic"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        conf "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

// printDRSObject marshals and prints a DRS object based o<span class="cov0" title="0">n the pretty flag
func printDRSObject(obj drs.DRSObject, pretty bool) error {
        var out []byte
        var err error

</span>        if pretty </span>{
                </span>out, err = sonic.ConfigFastest.MarshalIndent(obj, "", "  ")
        }</span> else {
                </span>out, err = sonic.ConfigFastest.Marshal(obj)
        }</span>

</span>        if err != nil {
                </span>return err
        }

        fmt.Printf</span>("%s\n", string(out))
        return nil
}

var remote string
var checksum = false
var pretty = false

type checksumClient interface {
        GetObjectByHash(ctx context.Context, hash *hash.Checksum) ([]drs.DRSObject, error)
}

func queryByChecksum(client checksumClient, checksum string) ([]drs.DRSObject, error) {
        // Auto-detect checksum type based on hash length
        checksumType := hash.</span>ChecksumTypeSHA256
        switch l<span class="cov0" title="0">en(checksum) {
        case 32:
                // 128-bit / 32-hex-character check</span>sum (e.g., MD5)
                checksu<span class="cov0" title="0">mType = hash.ChecksumTypeMD5
        case 40:
                // 160-bit / 40-hex-character checks</span>um (e.g., SHA1)
                checksu<span class="cov0" title="0">mType = hash.ChecksumTypeSHA1
        case 64:
                // 256-bit / 64-hex-character checksum</span> (e.g., SHA256)
                checksum<span class="cov0" title="0">Type = hash.ChecksumTypeSHA256
        case 128:
                // 512-bit / 128-hex-character checksu</span>m (e.g., SHA512)
                checksumType = hash.ChecksumTypeSHA512
        }

        return client.GetObjectByHash(context.Background(), &amp;hash.Checksum{
                Checksum: checksum,
                T</span>ype:     checksumType,
        })
}

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "query &lt;drs_id&gt;",
        Short: "Query DRS server by DRS ID",
        Long:  "Query DRS server by DRS ID",
        Args: func(cmd *cob</span><span class="cov0" title="0">ra.Command, args []string) error {
                if len(args) != 1 {
                        cmd.SilenceUsage = false
                        </span>return fmt.Errorf("error: requires exactly 1 argument (DRS ID), received %d\n\nUsage: %s\n\nSee 'git drs query --help' for more details", len(args), cmd.UseLine())
                <span class="cov0" title="0">}
</span>                return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
                logger := drslog.GetLogger()

                config, err :=</span><span class="cov0" title="0"> conf.LoadConfig()
                if err != nil {
                        </span>return err
                }

                remoteName, er</span><span class="cov0" title="0">r := config.GetRemoteOrDefault(remote)
                if err != nil {
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        </span>return err
                }

                client, err :=</span><span class="cov0" title="0"> config.GetRemoteClient(remoteName, logger)
                if err != nil {
                        </span>return err
                }

                var obj *drs.DRSObject

</span>                if checksum {
                        objs, err := q</span><span class="cov0" title="0">ueryByChecksum(client, args[0])
                        if err != nil {
                                </span>return err
                        <span class="cov0" title="0">}
</span>                        for _, drsObj := range objs {
</span>                                if err := printDRSObject(drsObj, pretty); err != nil {
                                        </span>return err
                                }
                        }
                } else {
                        obj, err = cli</span><span class="cov0" title="0">ent.GetObject(context.Background(), args[0])
                        if err != nil {
                                </span>return err
                        <span class="cov0" title="0">}
</span>                        if err := printDRSObject(*obj, pretty); err != nil {
                                </span>return err
                        }
                <span class="cov0" title="0">}
</span>                return nil
        },
}

func init() {
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
        Cmd.Flags().BoolVarP(&amp;checksum, "checksum", "c", checksum, "Find by checksum")
        </span>Cmd.Flags().BoolVarP(&amp;pretty, "pretty", "p", pretty, "Print indented JSON")
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package register

import (
        "context"
        "fmt"

        hash "github.com/calypr/data-client/indexd/hash"
        indexdCl "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        localLfs "github.com/calypr/git-drs/lfs"
        "github.com/spf13/cobra"
)

var remote string
var Cmd = &amp;cobra.Command{
        Use:   "register",
        Short: "Register all pending DRS objects with indexd",
        Long:  "Reads pending objects from .git/drs/lfs/obje<span class="cov0" title="0">cts/ and registers them with indexd (does not upload files)",
        Args: func(cmd *cob</span><span class="cov0" title="0">ra.Command, args []string) error {
                if len(args) != 0 {
                        cmd.SilenceUsage = false
                        </span>return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs register --help' for more details", len(args), cmd.UseLine())
                <span class="cov0" title="0">}
</span>                return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
                logger, err :=</span><span class="cov0" title="0"> drslog.NewLogger("", true)
                if err != nil {
                        </span>return err
                }

                cfg, err := co</span><span class="cov0" title="0">nfig.LoadConfig()
                if err != nil {
                        </span>return err
                }

                remoteName, er</span><span class="cov0" title="0">r := cfg.GetRemoteOrDefault(remote)
                if err != nil {
                        logger.Error(fmt.Sprintf("Error getting remote: %v", err))
                        </span>return err
                }

                cli, err := cf</span><span class="cov0" title="0">g.GetRemoteClient(remoteName, logger)
                if err != nil {
                        </span>return fmt.Errorf("error creating indexd client: %v", err)
                <span class="cov0" title="0">}
                // Chec</span><span class="cov0" title="0">k for GitDrsIdxdClient
                icli, ok := cli.(*indexdCl.GitDrsIdxdClient)
                i</span>f !ok {
                        return fmt.Errorf("remote client is not an *indexdCl.GitDrsIdxdClient (got %T)", cli)
                }

                // Get all pen</span><span class="cov0" title="0">ding objects
                pendingObjects, err := localLfs.GetPendingObjects(logger)
                i</span>f err != nil {
                        return fmt.Errorf("error reading pending objects: %v", err)
                <span class="cov0" title="0">}
</span>
                if len(pendingObjects) == 0 {
                        </span>logger.Debug("No pending objects to register")
                        return nil
                <span class="cov0" title="0">}

                logger.Debug(fmt.Sprintf("Found %d pending object(s) to register", len(pendingObjects)))

                registeredCount := 0
                skippedCount := 0
                errorCount := 0

</span>                // Register each pending object with indexd
                for _, obj := range pendingObjects {
                        logger.Debug(fmt.Sprintf("Processing %s (OID: %s)", obj.Path, obj.OID))

                        // Read the In</span><span class="cov0" title="0">dexdRecord from disk
                        indexdObj, err := drsmap.DrsInfoFromOid(obj.OID)
                        if err != nil {
                                logger.E</span>rror(fmt.Sprintf("Error reading DRS object for %s: %v", obj.Path, err))
                                errorCount++
                                continue
                        }

                        // Check if re</span><span class="cov0" title="0">cords with this hash already exist in indexd
                        records, err := cli.GetObjectByHash(context.Background(), &amp;hash.Checksum{Type: "sha256", Checksum: obj.OID})
                        if err != nil {
                                logger.E</span>rror(fmt.Sprintf("Error querying indexd for %s: %v", obj.Path, err))
                                errorCount++
                                continue
                        }

                        // Check if a record with this </span><span class="cov0" title="0">exact DID already exists
                        alreadyExists := false
</span>                        for _, record := range records {
                                if rec</span>ord.Id == indexdObj.Id {
                                        alreadyExists = true
                                        break
                                }
                        <span class="cov0" title="0">}
</span>
                        if alreadyExists {
                                logger.D</span>ebug(fmt.Sprintf("Record for %s (DID: %s) already exists in indexd, skipping", obj.Path, indexdObj.Id))
                                skippedCount++
                                continue
                        }

                        // Register th</span><span class="cov0" title="0">e indexd record
                        _, err = icli.RegisterRecord(context.Background(), indexdObj)
                        if err != nil {
                                logger.E</span>rror(fmt.Sprintf("Error registering %s with indexd: %v", obj.Path, err))
                                errorCount++
                                continue
                        <span class="cov0" title="0">}

</span>                        logger.Debug(fmt.Sprintf("Successfully registered %s with DID %s", obj.Path, indexdObj.Id))
                        registeredCount++
                }

                // Summary
                logger.Debug(fmt.Sprintf("Registration complete: %d registered, %d skipped, %d errors",
                        registeredCount, </span><span class="cov0" title="0">skippedCount, errorCount))

                i</span>f errorCount &gt; 0 {
                        return fmt.Errorf("completed with %d error(s)", errorCount)
                <span class="cov0" title="0">}
</span>
                return nil
        },
}

f</span>unc init() {
        Cmd.Flags().StringVarP(&amp;remote, "remote", "r", "", "target remote DRS server (default: default_remote)")
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package add

import (
        "fmt"
        "log/slog"

        anvil_client "github.com/calypr/git-drs/client/anvil"
        "github.com/calypr/git-drs/config"
        "github.com/spf13/cobra"
)

var AnvilCmd = &amp;cobra.Command{
        Use: "anvil [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add anvil --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return fmt.Errorf("error: anvil remote is not yet implemented. Use 'git drs remote add gen3' instead. See 'git drs remote add gen3 --help' for more details")
        }</span>,
}

func anvilInit(terraProject string, logger *slog.Logger) error <span class="cov0" title="0">{
        // make sure terra project is provided
        if terraProject != "" </span><span class="cov0" title="0">{
                // populate anvil config
                remoteAnvil := config.RemoteSelect{
                        Anvil: &amp;anvil_client.AnvilRemote{
                                Endpoint: anvil_client.ANVIL_ENDPOINT,
                                Auth: anvil_client.AnvilAuth{
                                        TerraProject: terraProject,
                                },
                        },
                }
                // TODO: different than ORIGIN?
                remoteName := config.Remote(config.AnvilServerType)
                _, err := config.UpdateRemote(remoteName, remoteAnvil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error: unable to update config file: %v\n", err)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package add

import (
        "fmt"
        "log/slog"

        "github.com/calypr/data-client/conf"
        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/utils"
        "github.com/spf13/cobra"
)

var Gen3Cmd = &amp;cobra.Command{
        Use: "gen3 [remote-name]",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts at most 1 argument (remote name), received %d\n\nUsage: %s\n\nSee 'git drs remote add gen3 --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                logg := drslog.GetLogger()

                // make sure at least one of the credentials params is provided
                if credFile == "" &amp;&amp; fenceToken == "" &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a credentials file or accessToken to setup project locally. Please provide either a --cred or --token flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                // When adding a new remote, bucket field is required.
                <span class="cov10" title="4">if bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: Gen3 requires a bucket name to be specified when adding a new remote. Please specify a bucket with --bucket flag. See 'git drs remote add gen3 --help' for more details")
                }</span>

                <span class="cov10" title="4">remoteName := config.ORIGIN
                if len(args) &gt; 0 </span><span class="cov10" title="4">{
                        remoteName = args[0]
                }</span>

                <span class="cov10" title="4">err := gen3Init(remoteName, credFile, fenceToken, project, bucket, logg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error configuring gen3 server: %v", err)
                }</span>
                <span class="cov10" title="4">return nil</span>
        },
}

func gen3Init(remoteName, credFile, fenceToken, project, bucket string, logg *slog.Logger) error <span class="cov10" title="4">{
        if remoteName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote name is required")
        }</span>
        <span class="cov10" title="4">if project == "" || bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("project and bucket are required for Gen3 remote")
        }</span>

        <span class="cov10" title="4">var accessToken, apiKey, keyID, apiEndpoint string
        configure := conf.NewConfigure(logg)
        switch </span>{
        case fenceToken != "":<span class="cov0" title="0">
                accessToken = fenceToken
                var err error
                apiEndpoint, err = utils.ParseAPIEndpointFromToken(accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from provided access token: %w", err)
                }</span>

        case credFile != "":<span class="cov10" title="4">
                cred, err := configure.Import(credFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read credentials file %s: %w", credFile, err)
                }</span>
                <span class="cov10" title="4">accessToken = cred.AccessToken
                apiKey = cred.APIKey
                keyID = cred.KeyID

                apiEndpoint, err = utils.ParseAPIEndpointFromToken(cred.APIKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse API endpoint from API key in credentials file: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                existing, err := configure.Load(remoteName)
                if err == nil </span><span class="cov0" title="0">{
                        accessToken = existing.AccessToken
                        apiKey = existing.APIKey
                        keyID = existing.KeyID
                        apiEndpoint = existing.APIEndpoint
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("must provide either --cred or --token (or have existing profile %s)", remoteName)
                }</span>
        }

        <span class="cov10" title="4">if apiEndpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not determine Gen3 API endpoint")
        }</span>

        <span class="cov10" title="4">remoteGen3 := config.RemoteSelect{
                Gen3: &amp;indexd_client.Gen3Remote{
                        Endpoint:  apiEndpoint,
                        ProjectID: project,
                        Bucket:    bucket,
                },
        }

        remote := config.Remote(remoteName)
        if _, err := config.UpdateRemote(remote, remoteGen3); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update remote config: %w", err)
        }</span>
        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Remote added/updated: %s  %s (project: %s, bucket: %s)", remoteName, apiEndpoint, project, bucket))

        // Step 3: Ensure credential profile is up-to-date (refreshes token if needed)
        cred := &amp;conf.Credential{
                Profile:            remoteName,
                APIEndpoint:        apiEndpoint,
                APIKey:             apiKey,
                KeyID:              keyID,
                AccessToken:        accessToken, // may be stale
                UseShepherd:        "false",     // or preserve from existing?
                MinShepherdVersion: "",
        }

        if err := configure.Save(cred); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure/update Gen3 profile: %w", err)
        }</span>

        <span class="cov10" title="4">logg.Debug(fmt.Sprintf("Gen3 profile '%s' configured and token refreshed successfully", remoteName))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package add

import "github.com/spf13/cobra"

var (
        server       string
        apiEndpoint  string
        bucket       string
        credFile     string
        fenceToken   string
        project      string
        terraProject string
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "add",
        Short: "add server access for git-drs",
}

func init() <span class="cov10" title="44">{
        Gen3Cmd.Flags().StringVar(&amp;server, "server", "gen3", "Options for DRS server: gen3 or anvil")
        Gen3Cmd.Flags().StringVar(&amp;apiEndpoint, "url", "", "[gen3] Specify the API endpoint of the data commons")
        Gen3Cmd.Flags().StringVar(&amp;bucket, "bucket", "", "[gen3] Specify the bucket name")
        Gen3Cmd.Flags().StringVar(&amp;credFile, "cred", "", "[gen3] Specify the gen3 credential file that you want to use")
        Gen3Cmd.Flags().StringVar(&amp;fenceToken, "token", "", "[gen3] Specify the token to be used as a replacement for a credential file for temporary access")
        Gen3Cmd.Flags().StringVar(&amp;project, "project", "", "[gen3] Specify the gen3 project ID in the format &lt;program&gt;-&lt;project&gt;")
        AnvilCmd.Flags().StringVar(&amp;terraProject, "terraProject", "", "[AnVIL] Specify the Terra project ID")

        Cmd.AddCommand(Gen3Cmd)
        Cmd.AddCommand(AnvilCmd)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List DRS repos",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 0 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: accepts no arguments, received %d\n\nUsage: %s\n\nSee 'git drs remote list --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logg := drslog.GetLogger()
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logg.Debug(fmt.Sprintf("Error loading config: %s", err))
                        return err
                }</span>

                <span class="cov0" title="0">for name, remoteSelect := range cfg.Remotes </span><span class="cov0" title="0">{
                        // Determine if this is the default
                        isDefault := name == cfg.DefaultRemote
                        marker := " "
                        if isDefault </span><span class="cov0" title="0">{
                                marker = "*"
                        }</span>

                        // Determine remote type and endpoint
                        <span class="cov0" title="0">var remoteType string
                        var remote config.DRSRemote
                        if remoteSelect.Gen3 != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.Gen3ServerType)
                                remote = remoteSelect.Gen3
                        }</span> else<span class="cov0" title="0"> if remoteSelect.Anvil != nil </span><span class="cov0" title="0">{
                                remoteType = string(config.AnvilServerType)
                                remote = remoteSelect.Anvil
                        }</span> else<span class="cov0" title="0"> {
                                remoteType = "unknown"
                        }</span>

                        <span class="cov0" title="0">endpoint := "N/A"
                        if remote != nil </span><span class="cov0" title="0">{
                                endpoint = remote.GetEndpoint()
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("%s %-10s %-8s %s\n", marker, name, remoteType, endpoint)</span>
                }
                <span class="cov0" title="0">return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package remote

import (
        "github.com/calypr/git-drs/cmd/remote/add"
        "github.com/spf13/cobra"
)

// Cmd line declaration
var Cmd = &amp;cobra.Command{
        Use:   "remote",
        Short: "Manage remote DRS server configs",
}

func init() <span class="cov10" title="44">{
        Cmd.AddCommand(add.Cmd)
        Cmd.AddCommand(ListCmd)
        Cmd.AddCommand(SetCmd)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package remote

import (
        "fmt"

        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/spf13/cobra"
)

var SetCmd = &amp;cobra.Command{
        Use:   "set &lt;remote-name&gt;",
        Short: "Set the default DRS remote",
        Long:  "Set which DRS remote to use by default for all operations",
        Args: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) != 1 </span><span class="cov0" title="0">{
                        cmd.SilenceUsage = false
                        return fmt.Errorf("error: requires exactly 1 argument (remote name), received %d\n\nUsage: %s\n\nRun 'git drs remote list' to see available remotes or 'git drs remote set --help' for more details", len(args), cmd.UseLine())
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                remoteName := args[0]
                logger := drslog.GetLogger()

                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load config: %w", err)
                }</span>

                // validate remote exists
                <span class="cov0" title="0">remote := config.Remote(remoteName)
                if _, ok := cfg.Remotes[remote]; !ok </span><span class="cov0" title="0">{
                        availableRemotes := make([]string, 0, len(cfg.Remotes))
                        for name := range cfg.Remotes </span><span class="cov0" title="0">{
                                availableRemotes = append(availableRemotes, string(name))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf(
                                "remote '%s' not found.\nAvailable remotes: %v",
                                remoteName,
                                availableRemotes,
                        )</span>
                }

                // save new default
                <span class="cov0" title="0">cfg.DefaultRemote = remote

                if err := config.SaveConfig(cfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save config: %w", err)
                }</span>

                <span class="cov0" title="0">logger.Debug(fmt.Sprintf("Default remote set to: %s", remoteName))
                return nil</span>
        },
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package cmd

import (
        "github.com/calypr/git-drs/cmd/addref"
        "github.com/calypr/git-drs/cmd/addurl"
        "github.com/calypr/git-drs/cmd/cache"
        "github.com/calypr/git-drs/cmd/delete"
        "github.com/calypr/git-drs/cmd/deleteproject"
        "github.com/calypr/git-drs/cmd/download"
        "github.com/calypr/git-drs/cmd/fetch"
        "github.com/calypr/git-drs/cmd/initialize"
        "github.com/calypr/git-drs/cmd/list"
        "github.com/calypr/git-drs/cmd/listconfig"
        "github.com/calypr/git-drs/cmd/prepush"
        "github.com/calypr/git-drs/cmd/push"
        "github.com/calypr/git-drs/cmd/query"
        "github.com/calypr/git-drs/cmd/register"
        "github.com/calypr/git-drs/cmd/remote"
        "github.com/calypr/git-drs/cmd/transfer"
        "github.com/calypr/git-drs/cmd/transferref"
        "github.com/calypr/git-drs/cmd/version"
        "github.com/spf13/cobra"
)

// RootCmd represents the root command
var RootCmd = &amp;cobra.Command{
        Use:   "git-drs",
        Short: "Git DRS - Git-LFS file management for DRS servers",
        Long:  "Git DRS provides the benefits of Git-LFS file management using DRS for seamless integration with Gen3 servers",
        PersistentPreRun: func(cmd *cobra.Command, args []string) {<span class="cov10" title="44">
                //pre-run code can go here
        }</span>,
}

func init() <span class="cov10" title="44">{
        RootCmd.AddCommand(addref.Cmd)
        RootCmd.AddCommand(cache.Cmd)
        RootCmd.AddCommand(delete.Cmd)
        RootCmd.AddCommand(deleteproject.Cmd)
        RootCmd.AddCommand(register.Cmd)
        RootCmd.AddCommand(download.Cmd)
        RootCmd.AddCommand(initialize.Cmd)
        RootCmd.AddCommand(list.Cmd)
        RootCmd.AddCommand(list.ListProjectCmd)
        RootCmd.AddCommand(listconfig.Cmd)
        RootCmd.AddCommand(prepush.Cmd)
        RootCmd.AddCommand(query.Cmd)
        RootCmd.AddCommand(transfer.Cmd)
        RootCmd.AddCommand(transferref.Cmd)
        RootCmd.AddCommand(version.Cmd)
        RootCmd.AddCommand(addurl.AddURLCmd)
        RootCmd.AddCommand(remote.Cmd)
        RootCmd.AddCommand(fetch.Cmd)
        RootCmd.AddCommand(push.Cmd)

        RootCmd.CompletionOptions.HiddenDefaultCmd = true
        RootCmd.SilenceUsage = true
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package transfer

import (
        "bufio"
        "context"
        "fmt"
        "os"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/data-client/common"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/s3_utils"
        "github.com/spf13/cobra"
)

// TransferJob carries the raw JSON data and shared client
type TransferJob struct {
        data      []byte
        drsClient client.DRSClient
}

// TransferResult sent back to the single writer
type TransferResult struct {
        data    any
        isError bool
}

var (
        // Set once after init  determines which path all workers take
        transferOperation string    // "upload" or "download"
        sConfig           sonic.API = sonic.ConfigFastest
)

const (
        OPERATION_UPLOAD   = "upload"
        OPERATION_DOWNLOAD = "download"
)

var Cmd = &amp;cobra.Command{
        Use:   "transfer",
        Short: "[RUN VIA GIT LFS] register LFS files into gen3 during git push",
        Long:  `[RUN VIA GIT LFS] git-lfs transfer mechanism<span class="cov9" title="32"> to register LFS files up to gen3 during git push. For new files, creates an indexd record and uploads to the bucket`,
        RunE: func(cmd *cobra.Command, args []string) error {
                logger := drslog.GetLogger()
                logger.Info("~~~~~~~~~~~~~ START: drs transfer ~~~~~~~~~~~~~")

                // Gotta go fast  big buffer
                scanner := bufio.NewScanner(os.Stdin)
                const maxCapacity = 10 * 1024 * 1024 // 10 MB
                buf := make([]byte, 0, 64*1024)
                scanner.Buffer(buf, maxCapacity)
                streamEncoder := encoder.NewStreamEncoder(os.Stdout)

                // Read init messag</span>e
                if !scanner.Scan() </span>{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                }</span>

                initBytes := make([]byte, len(scanner.Bytes()))
                copy(initBytes, scanner.Bytes())
                var initMsg lfs.InitMessage
</span>                if err := sConfig.Unmarshal(initBytes, &amp;initMsg); err != nil </span>{
                        logger.Error(fmt.Sprintf("Error decoding initial JSON message: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                }</span>

</span>                if initMsg.Event != "init" {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%s'", initMsg.Event)
                        logger.Error(fmt.Sprintf("Error: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                }

                var drsClient client.DRSClient

                // Load config first
                cfg, err := co</span><span class="cov0" title="0">nfig.LoadConfig()
                if err != nil {
                        logger.Error(fmt.Sprintf("Error loading config: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                }

                <span class="cov9" title="32">// Determine remote
                remote, err :=</span><span class="cov0" title="0"> cfg.GetDefaultRemote()
                if err != nil {
                        logger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                }

                drsClient, err</span><span class="cov0" title="0"> = cfg.GetRemoteClient(remote, logger)
                if err != nil {
                        logger.Error(fmt.Sprintf("Error creating DRS client: %v", err))
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                }

                <span class="cov9" title="32">// Determine if upload or download
</span>                if initMsg.Operation == OPERATION_UPLOAD || initMsg.Operation == OPERATION_DOWNLOAD {
                        transferOperation = initMsg.Operation
                        </span>logge<span class="cov0" title="0">r.Debug(fmt.Sprintf("Transfer operation: %s", transferOperation))
                } else {
                        err := fmt.Errorf("invalid or missing operation in init message: %s", initMsg.Operation)
                        logger.Error(err.Error())
                        lfs.WriteInitErrorMessage(streamEncoder, 400, err.Error())
                        </span>return err
                <span class="cov9" title="32">}
</span>                if err := streamEncoder.Encode(map[string]any{}); err != nil {
                        logger.Error(fmt.Sprintf("Error sending init acknowledgment: %v", err))
                        </span>return err
                }

</span>                for scanner.Scan() {
                        var msg map[string]any
                        err := sConfig</span><span class="cov0" title="0">.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil {
                                logger.E</span>rror(fmt.Sprintf("error decoding JSON: %s", err))
                                continue
                        }

</span>                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" {
                                // Handle download event
                                logger.Debug("Download requested")

                                // get download message
                                var downloadMsg lfs.DownloadMessage
</span>                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil {
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, "", 400, errMsg)
                                        continue
                                <span class="cov4" title="4">}
                                logger.Info(fmt.Sprintf("Downloading file OID %s", downloadMsg.Oid))

                                // get signed url
                                accessUrl, err</span><span class="cov0" title="0"> := drsClient.GetDownloadURL(context.Background(), downloadMsg.Oid)
                                if err != nil {
                                        errMsg := fmt.Sprintf("Error getting signed URL for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue
                                <span class="cov4" title="4">}
</span>                                if accessUrl.URL == "" {
                                        errMsg := fmt.Sprintf("Unable to get access URL for OID %s", downloadMsg.Oid)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        continue
                                }

                                <span class="cov4" title="4">// download signed url
                                dstPath, err :</span><span class="cov0" title="0">= drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, downloadMsg.Oid)
                                if err != nil {
                                        errMsg := fmt.Sprintf("Error getting destination path for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, downloadMsg.Oid, 400, errMsg)
                                        continue
                                <span class="cov4" title="4">}
                                err = s3_utils</span><span class="cov0" title="0">.DownloadSignedUrl(accessUrl.URL, dstPath)
                                if err != nil {
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v", downloadMsg.Oid, err)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, downloadMsg.Oid, 502, errMsg)
                                        continue
                                }

                                lfs.WriteProgressMessage(streamEncoder, downloadMsg.Oid, downloadMsg.Size, downloadMsg.Size)

                                // send success message back
                                logger.Info(fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))

</span>                                lfs.WriteCompleteMessage(streamEncoder, downloadMsg.Oid, dstPath)

</span>                        } else if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" {
                                // Handle upload event
                                logger.Debug("Upload requested")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
</span>                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil {
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v", err)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, uploadMsg.Oid, 400, errMsg)
                                        continue
                                <span class="cov4" title="4">}
                                logger.Info(fmt.Sprintf("Uploading file OID %s", uploadMsg.Oid))
                                drsObj, err :=</span><span class="cov0" title="0"> drsClient.RegisterFile(uploadMsg.Oid, GitLFSProgressCallback(streamEncoder))
                                if err != nil {
                                        errMsg := fmt.Sprintf("Error registering file: %v\n", err)
                                        logger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(streamEncoder, uploadMsg.Oid, 502, errMsg)
                                        continue
                                }
                                <span class="cov4" title="4">// send success message back
                                lfs.WriteCompleteMessage(streamEncoder, uploadMsg.Oid, drsObj.Name)
</span>                                logger.Info(fmt.Sprintf("Upload for OID %s complete", uploadMsg.Oid))

</span>                        } else if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" {
                                </span>logger.Info("LFS transfer terminate received.")
                        }
                }

</span>                if err := scanner.Err(); err != nil {
                        </span>logger.Error(fmt.Sprintf("stdin error: %s", err))
                }

                logger.Inf</span>o("~~~~~~~~~~~~~ COMPLETED: custom transfer ~~~~~~~~~~~~~")
                return nil

        },
}

// GitLFSProgressCallback returns a ProgressCallback that sends progress events
// to git-lfs via the streamEncoder
func GitLFSProgressCallback(streamEncoder *</span><span class="cov2" title="2">encoder.StreamEncoder) common.ProgressCallback {
        return func(event common.ProgressEvent) error {
                lfs.WriteProgressMessage(streamEncoder, event.Oid, event.BytesSoFar, event.BytesSinceLast)
                </span>return nil
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package transferref

import (
        "context"
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        "github.com/bytedance/sonic/encoder"
        "github.com/calypr/git-drs/client"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/drslog"
        "github.com/calypr/git-drs/drsmap"
        "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/spf13/cobra"
)

var (
        drsClient client.DRSClient
        sConfig   sonic.API = sonic.ConfigFastest
)

// TODO: used for AnvIL use case, requires implementation
var Cmd = &amp;cobra.Command{
        Use:   "transfer-ref",
        Short: "[RUN VIA GIT LFS] handle transfers of existing DRS object into git during git push",
        Long:  "[RUN VIA GIT LFS] custom transfer mechanism <span class="cov0" title="0">to pull LFS files during git lfs pull. Does nothing on push.",
        RunE: func(cmd *cobra.Command, args []string) error {
                //setup logging to file for debugging
                myLogger := drslog.GetLogger()

                myLogger.Info("~~~~~~~~~~~~~ START: custom anvil transfer ~~~~~~~~~~~~~")

                scanner := bufio.NewScanner(os.Stdin)
                encoder := encoder.NewStreamEncoder(os.Stdout)

                cfg, err := co</span>nfig.LoadConfig()
                if err != nil </span>{
                        myLogger.Error(fmt.Sprintf("Error loading config: %v", err))
                        </span>return err
                }</span>

                var remoteName string

                // Read the first (</span>init) message outside the main loop
                if !scanner.Scan() </span>{
                        err := fmt.Errorf("failed to read initial message from stdin")
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        // No OID yet, so pass empty string
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        </span>return err
                }</span>

                var initMsg map[string]any
</span>                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;initMsg); err != nil </span>{
                        myLogger.Error(fmt.Sprintf("error decoding initial JSON message: %s", err))
                        </span>return err
                }</span>

                <span class="cov0" title="0">// Handle "init" event and extract remote
</span>                if evt, ok := initMsg["event"]; ok &amp;&amp; evt == "init" {
                        // if no remote name specified, use default remote
                        defaultRemote,</span><span class="cov0" title="0"> err := cfg.GetDefaultRemote()
                        if err != nil {
                                myLogger.Error(fmt.Sprintf("Error getting default remote: %v", err))
                                lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                                </span>return err
                        <span class="cov0" title="0">}
                        remoteName = string(defaultRemote)
                        myLogger.Debug(fmt.Sprintf("Initializing connection, remote not specified  using default: %s", remoteName))

                        // Respond with an empty j</span>son object via stdout
                        encod<span class="cov0" title="0">er.Encode(struct{}{})
                } else {
                        err := fmt.Errorf("protocol error: expected 'init' message, got '%v'", initMsg["event"])
                        myLogger.Error(fmt.Sprintf("Error: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        </span>return err
                }

                drsClient, err</span><span class="cov0" title="0"> = cfg.GetRemoteClient(config.Remote(remoteName), myLogger)
                if err != nil {
                        myLogger.Error(fmt.Sprintf("Error creating indexd client: %s", err))
                        lfs.WriteErrorMessage(encoder, "", 400, err.Error())
                        </span>return err
                }

</span>                for scanner.Scan() {
                        var msg map[string]any
                        err := sConfig</span><span class="cov0" title="0">.Unmarshal(scanner.Bytes(), &amp;msg)
                        if err != nil {
                                myLogger</span>.Debug(fmt.Sprintf("error decoding JSON: %s", err))
                                continue
                        <span class="cov0" title="0">}
                        myLogger.Debug(fmt.Sprintf("Received message: %s", msg))

                        // Example: handle only "init" event
</span>                        if evt, ok := msg["event"]; ok &amp;&amp; evt == "init" {
                                // Log for debugging
                                myLogger.Debug(fmt.Sprintf("Handling init: %s", msg))

                                // Respond with an empty json object via stdout
                                encoder.Encode(struct{}{})
                                </span>myLog<span class="cov0" title="0">ger.Debug("Responding to init with empty object")
</span>                        } else if evt, ok := msg["event"]; ok &amp;&amp; evt == "download" {
                                // Handle download event
                                myLogger.Debug(fmt.Sprintf("Handling download event: %s", msg))

                                // get download message
                                var downloadMsg lfs.DownloadMessage
</span>                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;downloadMsg); err != nil {
                                        errMsg := fmt.Sprintf("Error parsing downloadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(encoder, downloadMsg.Oid, 400, errMsg)
                                        continue
                                }

                                <span class="cov0" title="0">// call DRS Downloader via downloadFile
                                dstPath, err :</span><span class="cov0" title="0">= downloadFile(config.Remote(remoteName), downloadMsg.Oid)
                                if err != nil {
                                        errMsg := fmt.Sprintf("Error downloading file for OID %s: %v\n", downloadMsg.Oid, err)
                                        myLogger.Error(errMsg)
                                        lfs.Writ</span>eErrorMessage(encoder, downloadMsg.Oid, 500, errMsg)
                                        continue
                                }

                                myLogger.Debug(fmt.Sprintf("Downloaded file for OID %s", downloadMsg.Oid))

                                // send success message back
                                myLogger.Debug(fmt.Sprintf("Download for OID %s complete", downloadMsg.Oid))
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   downloadMsg.Oid,
                                        Path:  dstPath,
                                }
</span>                                encod<span class="cov0" title="0">er.Encode(completeMsg)
</span>                        } else if evt, ok := msg["event"]; ok &amp;&amp; evt == "upload" {
                                // Handle upload event
                                myLogger.Info(fmt.Sprintf("Handling upload event: %s", msg))
                                myLogger.Info("skipping upload, just registering existing DRS object")

                                // create UploadMessage from the received message
                                var uploadMsg lfs.UploadMessage
</span>                                if err := sConfig.Unmarshal(scanner.Bytes(), &amp;uploadMsg); err != nil {
                                        errMsg := fmt.Sprintf("Error parsing UploadMessage: %v\n", err)
                                        myLogger.Error(errMsg)
                                        </span>lfs.WriteErrorMessage(encoder, uploadMsg.Oid, 400, errMsg)
                                <span class="cov0" title="0">}
                                myLogger.Debug(fmt.Sprintf("Got UploadMessage: %+v", uploadMsg))

                                // send success message back
                                completeMsg := lfs.CompleteMessage{
                                        Event: "complete",
                                        Oid:   uploadMsg.Oid,
                                }
                                myLogger.Info(fmt.Sprintf("</span>Complete message: %+v", completeMsg))
                                encod<span class="cov0" title="0">er.Encode(completeMsg)
</span>                        } else if evt, ok := msg["event"]; ok &amp;&amp; evt == "terminate" {
                                // Handle terminate event
                                </span>myLogger.Debug(fmt.Sprintf("terminate event received: %s", msg))
                        }
                }

</span>                if err := scanner.Err(); err != nil {
                        </span>myLogger.Debug(fmt.Sprintf("stdin error: %s", err))
                }

                myLogger.Info("~~~~~~~~~~~~~ COMPLETED: custom anvil transfer ~~~~~~~~~~~~~")

</span>                return nil
        },
}

func downloadFile(remote config.Remote, sha string) (string, error) {
        myLogger := drslog.GetLogger()

        myLogger.Debug(fmt.Sprintf("Downloading file for sha %s", sha))

        // get terra project
        cfg, err := co</span><span class="cov0" title="0">nfig.LoadConfig() // should this be handled only via indexd client?
        if err != nil {
                </span>return "", fmt.Errorf("error loading config: %v", err)
        }

        cli, err := cf</span><span class="cov0" title="0">g.GetRemoteClient(remote, myLogger)
        if err != nil {
                </span>return "", err
        }

        terraProject := cli.GetProjectId()

        filePath, err </span><span class="cov0" title="0">:= drsmap.GetObjectPath(projectdir.DRS_REF_DIR, sha)
        if err != nil {
                </span>return "", fmt.Errorf("error getting object path for sha %s: %v", sha, err)
        <span class="cov0" title="0">}
        myLogger.Debug(fmt.Sprintf("File path for sha %s: %s", sha, filePath))

        // get DRS URI in the second line of the file
        file, err := o</span><span class="cov0" title="0">s.Open(filePath)
        if err != nil {
                </span>return "", fmt.Errorf("error opening file %s: %v", filePath, err)
        <span class="cov0" title="0">}
        defer file.Close()
        myLogger.Debug(fmt.Sprintf("Opened file %s for reading", filePath))

        scanner := bufio.NewScanner(file)
        var drsUri string
        lineNum := 0
</span>        for scanner.Scan() {
                lineNum++
                line := scanner.Text()
                myLogger.Debug(f</span><span class="cov0" title="0">mt.Sprintf("Reading line %d: %s", lineNum, line))
                if lineNum == 2 {
                        // second line should be the DRS URI
                        drsUri = strings.TrimSpace(line)
                        myLog</span>ger.Debug(fmt.Sprintf("DRS URI found: %s", drsUri))
                        break
                }
        }

        myLogger.Debug(f</span><span class="cov0" title="0">mt.Sprintf("DRS URI found: %s", drsUri))
        if drsUri == "" {
                </span>return "", fmt.Errorf("error: file %s does not contain a valid DRS URI in the second line", filePath)
        <span class="cov0" title="0">}
        drsObj, err :=</span><span class="cov0" title="0"> drsClient.GetObject(context.Background(), drsUri)
        if err != nil {
                </span>return "", fmt.Errorf("error fetching DRS object for URI %s: %v", drsUri, err)
        <span class="cov0" title="0">}
</span>        if drsObj == nil {
                </span>return "", fmt.Errorf("no DRS object found for URI %s", drsUri)
        }

        myLogger.Debug(fmt.Sprintf("DRS Object fetched: %+v", drsObj))

        // call DRS downloader as a binary, redirect output to log file
        logFile, err :</span><span class="cov0" title="0">= os.OpenFile(projectdir.DRS_LOG_FILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil {
                </span>return "", fmt.Errorf("error opening log file: %v", err)
        <span class="cov0" title="0">}
        defer logFile.Close()

        //TODO: This should be done in the DRSClient code
        // download file, make sure its name is the sha
        dstPath, err := drsmap.GetObjectPath(projectdir.LFS_OBJS_PATH, sha)
        dstDir := filepath.Dir(dstPath)
        cmd := exec.Command("drs_downloader", "terra", "--user-project", terraProject, "--manifest-path", filePath, "--destination-dir", dstDir)

        // write command to log file
        logFile.WriteString(fmt.Sprintf("Running command: %s\n", cmd.String()))

        cmd.Stdout = logFile
        cmd.Stderr = logFile
        cmdOut, err :=</span><span class="cov0" title="0"> cmd.CombinedOutput()
        if err != nil {
                </span>return "", fmt.Errorf("error running drs_downloader for sha %s: %s", sha, cmdOut)
        }

        <span class="cov0" title="0">//rename file to sha
        tmpPath := filepath.Join(dstDir, drsObj.Name)
        err = os.Renam</span><span class="cov0" title="0">e(tmpPath, dstPath)
        if err != nil {
                </span>return "", fmt.Errorf("error renaming downloaded file from %s to %s: %v", tmpPath, dstPath, err)
        }

</span>        return dstPath, nil
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package version

import (
        "fmt"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Cmd represents the "version" command
var Cmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Get version",
        Long:  ``,
        Run: func(cmd *cobra.Command, args []string) <span class="cov4" title="5">{
                fmt.Println("git-drs", buildVersion())
        }</span>,
}

func buildVersion() string <span class="cov4" title="6">{
        tag := ""
        commit := ""
        if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov4" title="6">{
                if info.Main.Version != "" &amp;&amp; info.Main.Version != "(devel)" </span><span class="cov0" title="0">{
                        tag = info.Main.Version
                }</span>
                <span class="cov4" title="6">for _, setting := range info.Settings </span><span class="cov10" title="66">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                commit = setting.Value</span>
                        case "vcs.tag":<span class="cov0" title="0">
                                if tag == "" </span><span class="cov0" title="0">{
                                        tag = setting.Value
                                }</span>
                        }
                }
        }

        <span class="cov4" title="6">commitShort := commit
        if len(commitShort) &gt; 7 </span><span class="cov0" title="0">{
                commitShort = commitShort[:7]
        }</span>

        <span class="cov4" title="6">switch </span>{
        case tag != "" &amp;&amp; commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("%s-%s", tag, commitShort)</span>
        case tag != "":<span class="cov0" title="0">
                return tag</span>
        case commitShort != "":<span class="cov0" title="0">
                return fmt.Sprintf("dev-%s", commitShort)</span>
        default:<span class="cov4" title="6">
                return "dev-unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package config

import (
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        "github.com/calypr/git-drs/client"
        anvil_client "github.com/calypr/git-drs/client/anvil"
        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "gopkg.in/yaml.v3"
)

// RemoteType represents the type of server being initialized
type RemoteType string
type Remote string

const (
        ORIGIN = "origin"

        Gen3ServerType  RemoteType = "gen3"
        AnvilServerType RemoteType = "anvil"
)

func AllRemoteTypes() []RemoteType <span class="cov5" title="8">{
        return []RemoteType{Gen3ServerType, AnvilServerType}
}</span>

func IsValidRemoteType(mode string) error <span class="cov4" title="4">{
        modeOptions := make([]string, len(AllRemoteTypes()))
        for i, m := range AllRemoteTypes() </span><span class="cov5" title="8">{
                modeOptions[i] = string(m)
        }</span>

        <span class="cov4" title="4">for _, validMode := range modeOptions </span><span class="cov5" title="7">{
                if mode == string(validMode) </span><span class="cov2" title="2">{
                        return nil
                }</span>
        }

        <span class="cov2" title="2">return fmt.Errorf("invalid mode '%s'. Valid options are: %s", mode, strings.Join(modeOptions, ", "))</span>
}

// DRSRemote holds pointers to remote types
type DRSRemote interface {
        GetProjectId() string
        GetEndpoint() string
        GetBucketName() string
        GetClient(params map[string]string, logger *slog.Logger) (client.DRSClient, error)
}

type RemoteSelect struct {
        Gen3  *indexd_client.Gen3Remote `yaml:"gen3,omitempty"`
        Anvil *anvil_client.AnvilRemote `yaml:"anvil,omitempty"`
}

// Config holds the overall config structure
type Config struct {
        DefaultRemote Remote                  `yaml:"default_remote,omitempty"`
        Remotes       map[Remote]RemoteSelect `yaml:"remotes"`
}

func (c Config) GetRemoteClient(remote Remote, logger *slog.Logger) (client.DRSClient, error) <span class="cov9" title="38">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GetRemoteClient no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov9" title="38">if x.Gen3 != nil </span><span class="cov9" title="38">{
                configText, _ := yaml.Marshal(x.Gen3)
                configParams := make(map[string]string)
                yaml.Unmarshal(configText, configParams)
                configParams["remote_name"] = string(remote)
                return x.Gen3.GetClient(configParams, logger)
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil.GetClient(nil, logger)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("no valid remote configuration found for current remote: %s", remote)</span>
}

func (c Config) GetRemote(remote Remote) DRSRemote <span class="cov0" title="0">{
        x, ok := c.Remotes[remote]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if x.Gen3 != nil </span><span class="cov0" title="0">{
                return x.Gen3
        }</span> else<span class="cov0" title="0"> if x.Anvil != nil </span><span class="cov0" title="0">{
                return x.Anvil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDefaultRemote returns the configured default remote with validation
func (c Config) GetDefaultRemote() (Remote, error) <span class="cov9" title="39">{
        if c.DefaultRemote == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "no default remote configured.\n"+
                                "Set one with: git drs remote set &lt;name&gt;\n"+
                                "Available remotes: %v",
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov9" title="39">if _, ok := c.Remotes[c.DefaultRemote]; !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf(
                        "default remote '%s' not found in configuration.\n"+
                                "Available remotes: %v",
                        c.DefaultRemote,
                        c.listRemoteNames(),
                )
        }</span>

        <span class="cov9" title="39">return c.DefaultRemote, nil</span>
}

// GetRemoteOrDefault returns the specified remote if provided, otherwise returns the default remote
// This is a common pattern used across many commands that accept an optional --remote flag
func (c Config) GetRemoteOrDefault(remote string) (Remote, error) <span class="cov2" title="2">{
        if remote != "" </span><span class="cov1" title="1">{
                return Remote(remote), nil
        }</span>
        <span class="cov1" title="1">return c.GetDefaultRemote()</span>
}

// listRemoteNames returns a slice of all remote names for error messages
func (c Config) listRemoteNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(c.Remotes))
        for name := range c.Remotes </span><span class="cov0" title="0">{
                names = append(names, string(name))
        }</span>
        <span class="cov0" title="0">return names</span>
}

func getConfigPath() (string, error) <span class="cov10" title="58">{
        topLevel, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="58">configPath := filepath.Join(topLevel, projectdir.DRS_DIR, projectdir.CONFIG_YAML)
        return configPath, nil</span>
}

// updates and git adds a Git DRS config file
// this should handle three cases:
// 1. create a new config file if it does not exist / is empty
// 2. return an error if the config file is invalid
// 3. update the existing config file, making sure to combine the new serversMap with the existing one
func UpdateRemote(name Remote, remote RemoteSelect) (*Config, error) <span class="cov4" title="5">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check if file exists, if not create parent directory
        <span class="cov4" title="5">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // if file doesn't exist, create file. Otherwise, open the file for writing
        <span class="cov4" title="5">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="5">defer file.Close()

        // if file is not empty, unmarshal into Config
        var cfg Config
        if err := yaml.NewDecoder(file).Decode(&amp;cfg); err != nil </span><span class="cov4" title="5">{
                // if the file is empty, we can just create a new config
                cfg = Config{
                        Remotes: map[Remote]RemoteSelect{},
                }
        }</span>

        <span class="cov4" title="5">if cfg.Remotes == nil </span><span class="cov0" title="0">{
                cfg.Remotes = make(map[Remote]RemoteSelect)
        }</span>

        // Set as default if this is the first remote
        <span class="cov4" title="5">if len(cfg.Remotes) == 0 &amp;&amp; cfg.DefaultRemote == "" </span><span class="cov4" title="5">{
                cfg.DefaultRemote = name
        }</span>

        <span class="cov4" title="5">cfg.Remotes[name] = remote

        // overwrite the file using config
        file.Seek(0, 0)
        file.Truncate(0)
        if err := yaml.NewEncoder(file).Encode(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write config file: %w", err)
        }</span>
        <span class="cov4" title="5">return &amp;cfg, nil</span>
}

// load an existing config
func LoadConfig() (*Config, error) <span class="cov9" title="47">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="47">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config file does not exist. Please run 'git drs init', see 'git drs init --help' for more details")
        }</span>

        <span class="cov9" title="46">reader, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open config file at %s", configPath)
        }</span>
        <span class="cov9" title="46">defer reader.Close()

        b, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read config file at %s", configPath)
        }</span>

        <span class="cov9" title="46">conf := Config{}
        err = yaml.Unmarshal(b, &amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config file at %s is invalid: %w", configPath, err)
        }</span>

        // Validate: if remotes exist but no default, error with migration instructions
        // FIXME: can be deleted after internal dev team ports over
        <span class="cov9" title="46">if len(conf.Remotes) &gt; 0 &amp;&amp; conf.DefaultRemote == "" </span><span class="cov1" title="1">{
                remoteNames := make([]string, 0, len(conf.Remotes))
                for name := range conf.Remotes </span><span class="cov1" title="1">{
                        remoteNames = append(remoteNames, string(name))
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf(
                        "configuration migration required.\n\n" +
                                "Your config has remotes but no default_remote field.\n" +
                                "Add this line to .git/drs/config.yaml:\n\n" +
                                "  default_remote: &lt;remote-name&gt;\n\n" +
                                "or delete and recreate the config file by re-running\n\n" +
                                "  git drs remote add \n\n",
                )</span>
        }

        <span class="cov9" title="45">return &amp;conf, nil</span>
}

func CreateEmptyConfig() error <span class="cov4" title="5">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov4" title="5">{
                if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // create empty config file
        <span class="cov4" title="5">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">defer file.Close()

        return nil</span>
}

func GetProjectId(remote Remote) (string, error) <span class="cov0" title="0">{
        cfg, err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading config: %v", err)
        }</span>
        <span class="cov0" title="0">rmt := cfg.GetRemote(remote)
        if rmt == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no remote configuration found for current remote: %s", remote)
        }</span>
        <span class="cov0" title="0">return rmt.GetProjectId(), nil</span>
}

// SaveConfig writes the configuration to disk
func SaveConfig(cfg *Config) error <span class="cov1" title="1">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">file, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        if err := yaml.NewEncoder(file).Encode(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package drslog

import (
        "log"
        "log/slog"
        "strings"
)

// AsStdLogger adapts a slog.Logger to the standard library log.Logger interface.
func AsStdLogger(logger *slog.Logger) *log.Logger <span class="cov10" title="81">{
        return log.New(slogWriter{logger: logger}, "", 0)
}</span>

type slogWriter struct {
        logger *slog.Logger
}

// Write implements io.Writer and is invoked by the standard library log functions
// (for example, the logger returned by AsStdLogger). Documented calls inside:
//
//   - `string(p)`
//     Converts the incoming byte slice to a string for processing.
//
//   - `strings.TrimSpace(...)`
//     Removes leading/trailing whitespace (including trailing newlines) so that
//     empty or whitespace-only log lines are dropped.
//
//   - `w.logger.Info(...)`
//     Emits the trimmed message to the wrapped `slog.Logger` at Info level.
//
//   - `len(p)`
//     Returned to satisfy the io.Writer contract; indicates the number of bytes
//     "written". This implementation never returns an error.
//
// Note: This implementation deliberately ignores write errors and drops messages
// that are empty after trimming.
func (w slogWriter) Write(p []byte) (int, error) <span class="cov7" title="28">{
        message := strings.TrimSpace(string(p))
        if message != "" </span><span class="cov7" title="28">{
                w.logger.Info(message)
        }</span>
        <span class="cov7" title="28">return len(p), nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// go
package drslog

import (
        "io"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"

        "github.com/calypr/git-drs/projectdir"
)

var globalLogger *slog.Logger
var globalLogFile io.Closer
var globalLoggerOnce sync.Once
var globalLoggerMu sync.RWMutex
var GIT_TRANSFER_TRACE int
var modulePathSuffixOnce sync.Once
var modulePathSuffixValue string
var repoRootOnce sync.Once
var repoRootValue string

// init initializes package-level settings from the environment.
//
// Documented calls inside:
//   - os.Getenv("GIT_TRANSFER_TRACE")
//     Reads environment variable to optionally enable trace logging.
//   - strconv.Atoi(envValue)
//     Parses the numeric env value.
//
// Side-effects:
// - sets package variable GIT_TRANSFER_TRACE.
// Typical callers:
// - runtime automatically invokes init(); no external callers needed.
func init() <span class="cov5" title="21">{
        GIT_TRANSFER_TRACE = 0
        if envValue := os.Getenv("GIT_TRANSFER_TRACE"); envValue != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(envValue); err == nil </span><span class="cov0" title="0">{
                        GIT_TRANSFER_TRACE = parsed
                }</span>
        }
}

// TraceEnabled returns whether transfer trace logging is enabled.
//
</span>// Documented calls inside:
</span>// - reads package variable GIT_TRANSFER_TRACE.
// </span>Typical callers:
// - logging setup and callsites that want to be verbose only when trace is enabled.
func TraceEnabled() bool <span class="cov1" title="2">{
        return GIT_TRANSFER_TRACE == 1
}</span>

// NewLogger creates and installs a global slog.Logger that writes to the specified file
// and optionally to stderr. It is safe to call multiple times; the first successful call
// establishes the global logger.
//
// Documented calls insid<span class="cov6" title="48">e:
//   - projectdir.DRS_DIR usage
/</span>/     Uses projectdir.DRS_DIR to create log directory.
//   - os.MkdirAll(projectdir.DRS_DIR, 0755)
//     Ensures the directory exists; returns error on failure.
//   - filepath.Join(projectdir.DRS_DIR, "git-drs.log")
//     Constructs default filename when none provided.
//   - os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
//     Opens/creates the log file (returns *os.File).
//   - io.MultiWriter(writers...)
//     Combines file and optionally os.Stderr into a single Writer.
//   - slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{...})
//     Creates the text handler for slog that writes to the combined writer.
//   - slog.New(handler).With("pid", os.Getpid())
//     Builds the logger and attaches pid attribute.
//   - globalLoggerMu.Lock()/Unlock()
//     Protects globalLogFile and globalLogger assignment.
//
// Side-effects:
// - sets package-level globalLogger and globalLogFile.
// Typical callers:
// - application startup code that wants to initialize logging (e.g. main).
func NewLogger(filename string, logToStderr bool) (*slog.Logger, error) <span class="cov1" title="2">{
        var writers []io.Writer

        if filename == "" </span><span class="cov1" title="1">{
                // create drs dir if it doesn't exist
                if err := os.MkdirAll(projectdir.DRS_DIR, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                filename = filepath.Join(projectdir.DRS_DIR, "git-drs.log")
        }

</span>        file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil {
</span>                return nil, err
        }
</span>        writers = append(writers, file)

</span>        if logToStderr {
                writers = append(writers, os.Stderr)
        <span class="cov6" title="48">}

</span>        multiWriter := io.MultiWriter(writers...)

</span>        <span class="cov6" title="48">handler := slog.NewTextHandler(multiWriter, &amp;slog.HandlerOptions{
                AddSource:   true,
                Level:       r</span><span class="cov6" title="44">esolveLogLevel(),
                ReplaceAttr: replaceSourceAttr,
        }</span>)
        core := slog.New(handler).With("pid", os.Getpid())

        globalLoggerMu.Lock()
        globalLogFile = file
        globalLogger = core
        globalLoggerMu.Unlock()

        return globalLogger, nil
}

// GetLogger returns the global logger, initializing a no-op logger on first access.
//
// Documented calls inside:
//   - globalLoggerOnce.Do(func() { ... })
//     Ensures initialization runs only once.
//   - NewNoOpLogger()
</span>//     Creates a logger that discards output if no global logger was set.
//
// Typical callers:
// - any package code that needs access to the package-level logger.
func GetLogger() *slog.Logger {
        globalLoggerOnce.Do(func() {
                if globalLogger == nil {
                        globalLogger = NewNoOpLogger()
                }
        })
        return globalLogger
}

// Close closes the active l</span><span class="cov6" title="40">og file if one was opened.
//
</span>// Documented calls inside:
// </span>  - globalLoggerMu.Lock()/Unlock()
//     Protects access to globalLogFile.
/<span class="cov6" title="40">/   - globalLogFile</span>.Close()
//     Closes the underlying file and returns any error.
//
// Side-effects:
// - sets globalLogFile to nil.
// Typical callers:
// - application shutdown code or tests that want to release file handles.
func Close() error {
        globalLoggerMu.Lock()
        defer globalLoggerMu.Unlock()
        if globalLogFile != nil {
                err := globalLogFile.Close()

                globalLogFile = nil
                return err
        }
        return nil
}

</span>// NewNoOpLogger returns a logger that discards all output.
//
// Documented calls inside:
//   - slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{Level: slog.LevelDebug})
//</span>     Creates a text handler writing to io.Discard.
/<span class="cov0" title="0">/   - slog</span>.New(handler)
//     Builds the logger.
//
// Typical callers:
// - GetLogger on first access when no global logger was configured.
// - tests that need a deterministic logger that produces no output.
func NewNoOpLogger() *slog.Logger {
        handler := slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        return slog.New(handler)
}

// resolveLogLevel determines the effective log level.
//
// Documented calls inside:
//   - TraceEnabled()
//     If trace is enabled, returns Debug level immediately.
//   - readLogLevelFromGitConfig()
/</span>/     Attempts to read configured level from git config; returns level and ok.
//   - defaults to slog.LevelInfo when nothing else matches.
//
// Typical callers:
// - NewLogger -&gt; used when creating slog.HandlerOptions.Level.
func resolveLogLevel() slog.Level {
        if TraceEnabled() {
                return slog.LevelDebug
        }

        level, ok := readLogLevelFromGitConfig()
        if ok {
                return level
        }

</span>        return slog.LevelInfo
}
</span>
/<span class="cov6" title="48">/ readLogLevelFromGitConfig queries git configuration for a custom log level.
//
</span>// Documented calls inside:
//</span>   - exec.Command("git", "config", "--get", "lfs.customtransfer.drs.loglevel")
//     Constructs the command to query git config.
/<span class="cov6" title="48">/   - cmd.Output()
</span>//     Executes the command and returns raw output or an error.
//   - strings.TrimSpace(string(output))
//     Trims whitespace/newlines from git output.
//   - parseLogLevel(value)
//     Parses the trimmed value into a slog.Level.
//
// Behavior:
// - On any error or empty output, returns (slog.LevelInfo, false) to indicate no valid config was found.
// Typical callers:
// - resolveLogLevel when initializing a logger.
func readLogLevelFromGitConfig() (slog.Level, bool) {
        cmd := exec.Command("git", "config", "--get", "lfs.customtransfer.drs.loglevel")
        output, err := cmd.Output()
        if err != nil {
                return slog.LevelInfo, false
        }

        value := strings.TrimSpace(string(output))
        if value == "" {
                return slog.LevelInfo, false
        }

</span>        parsed, ok := parseLogLevel(value)
        i</span>f !ok {
                return slog.LevelInfo, false
        <span class="cov0" title="0">}
        return parsed, </span><span class="cov0" title="0">true
}

</span>// parseLogLevel maps textual level names to slog.Level.
/<span class="cov0" title="0">/
// Docum</span><span class="cov0" title="0">ented calls inside:
//   - strings.ToUpper(strings.TrimSpace(value))
//</span>     Normalizes the input for comparison.
/<span class="cov0" title="0">/   - switch on nor</span>malized value to return corresponding slog.Level constants.
//
// Typical callers:
// - readLogLevelFromGitConfig
// - resolveLogLevel indirectly.
func parseLogLevel(value string) (slog.Level, bool) {
        switch strings.ToUpper(strings.TrimSpace(value)) {
        case "DEBUG":
                return slog.LevelDebug, true
        case "INFO":
                return slog.LevelInfo, true
        case "WARN", "WARNING":
                return slog.LevelWarn, true
        case "ERROR":
                return slog.LevelError, true
        default:
</span>                return slog.LevelD<span class="cov0" title="0">ebug, false
        }
</span>}

</span>// replaceSourceAttr rewrites the sl<span class="cov0" title="0">og.Source attr to a shorter path suitable for logs.
//
</span>// Documented calls <span class="cov0" title="0">inside:
//   - attr.Key comparison wit</span>h slog.SourceKey
//     De<span class="cov0" title="0">termines whether the attribute is the source attribute.
//   - attr.Value.Any().(*slog.</span>Source)
//     Retrieves and type-asserts the attribute value to *slog.Source.
//   - formatSourcePath(source.File)
//     Formats the file path according to module or repo root heuristics.
//   - attr.Value = slog.AnyValue(source)
//     Replaces attribute value with modified source.
//
// Typical callers:
// - passed as ReplaceAttr to slog.HandlerOptions in NewLogger.
func replaceSourceAttr(_ []string, attr slog.Attr) slog.Attr {
        if attr.Key != slog.SourceKey {
                return attr
        }
        source, ok := attr.Value.Any().(*slog.Source)
        if !ok || source == nil {
                return attr
        }
        source.File = formatSourcePath(source.File)
        attr.Value = slog.AnyValue(source)
        return attr
</span>}

</span>/<span class="cov7" title="140">/ formatSourcePath shortens file paths using module suffix or repo root heuristics.
//
</span>// Documented calls inside:
//</span>   - filepath.ToSlash(path)
/<span class="cov7" title="140">/     Normalizes OS-specific separators to forward slashes.
//   - modulePathSuffix()
//     Gets </span>the module path suffix (derived from build info).
//   - strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
//     Normalizes module suffix.
//   - strings.Index(pathSlash, "/"+moduleSuffixSlash+"/")
//     Searches for module suffix within the path to trim leading segments.
//   - strings.HasPrefix(pathSlash, moduleSuffixSlash+"/")
//     Handles case where path already starts with module suffix.
//   - repoRootPath()
//     Attempts to resolve the repository root (by locating go.mod).
//   - strings.HasPrefix(pathSlash, repoRootSlash+"/")
//     Trims repository-root prefix to produce a relative path.
//   - filepath.ToSlash(filepath.Join(moduleSuffix, rel))
//     Reconstructs path when combining module suffix and relative path.
//
// Typical callers:
// - replaceSourceAttr when rewriting source file paths for log output.
func formatSourcePath(path string) string {
        pathSlash := filepath.ToSlash(path)
        moduleSuffix := modulePathSuffix()
        if moduleSuffix != "" {
                moduleSuffixSlash := strings.TrimPrefix(filepath.ToSlash(moduleSuffix), "/")
                if idx := strings.Index(pathSlash, "/"+moduleSuffixSlash+"/"); idx &gt;= 0 {
                        return pathSlash[idx+1:]
                }
                if strings.HasPrefix(pathSlash, moduleSuffixSlash+"/") {
                        return pathSlash
                }
        }
        repoRoot := repoRootPa</span><span class="cov7" title="140">th()
        if repoRoot != "" {
                repoRootSlash := filepath.ToSlash(repoRoot)
</span>                if strings.HasPrefix(pathSlash, repoRootSlash+"/") {
                        </span>rel := strings.TrimPrefix(pathSlash, repoRootSlash+"/")
                <span class="cov0" title="0">        if moduleSuffix != "" {
</span>                                return filepath.ToSlash(filepath.Join(moduleSuffix, rel))
                        </span>}
                        return rel
        <span class="cov0" title="0">        }
        }
</span>        return pathSlash
}
</span>
// modulePathSuffix retur</span><span class="cov0" title="0">ns the module path suffix derived from build info.
//
// D</span>ocumented calls inside:
// <span class="cov0" title="0">  - runtim</span>e/debug.ReadBuildInfo()
//     Reads build info at runtime; used to extract Main.Path.
//   - strings.Split(info.Main.Path, "/")
/<span class="cov0" title="0">/     Splits mod</span>ule path to drop the first element (typically hostname).
//
// Side-effects:
// - caches computed value via modulePathSuffixOnce.
// Typical callers:
// - formatSourcePath to help shorten file paths.
func modulePathSuffix() string {
        modulePathSuffixOnce.Do(func() {
                if info, ok := debug.ReadBuildInfo(); ok &amp;&amp; info.Main.Path != "" {
                        parts := strings.Split(info.Main.Path, "/")
                        if len(parts) &gt; 1 {
                                modulePathSuffixValue = strings.Join(parts[1:], "/")
                        }
                }
        })
        return modulePathSuffixValue
}
</span>
</span>// repoRootPath attempts to locate the repository root by searching for go.mod upward.
//
</span>// Documented calls inside:
//  </span> - os.Getwd()
//     Retrieves current working directory as a starting point.
//   - os.Stat(filepath.Join(dir, "go.mod"))
/<span class="cov7" title="140">/     Checks for presence of</span> go.mod in each directory while walking up.
//   - filepath.Dir(dir)
//     Moves up one directory level on each iteration.
//
// Side-effects:
// - caches resolved repo root via repoRootOnce.
// Typical callers:
// - formatSourcePath when computing shorter file paths for logs.
func repoRootPath() string {
        repoRootOnce.Do(func() {
                cwd, err := os.Getwd()
                if err != nil {
                        return
                }
                dir := cwd
                for {
                        if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
                                repoRootValue = dir
                                return
</span>                        }
                        parent := fil</span><span class="cov0" title="0">epath.Dir(dir)
                        if parent == dir {
                        </span>        return
                <span class="cov0" title="0">        }
                        dir</span><span class="cov0" title="0"> = parent
                }
</span>        })
        return repoRootValue
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package drsmap

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/bytedance/sonic"
        dataClient "github.com/calypr/data-client/g3client"
        drs "github.com/calypr/data-client/indexd/drs"
        hash "github.com/calypr/data-client/indexd/hash"
        "github.com/calypr/data-client/upload"
        "github.com/calypr/git-drs/client"
        localLfs "github.com/calypr/git-drs/lfs"
        "github.com/calypr/git-drs/projectdir"
        "github.com/calypr/git-drs/utils"
        "github.com/google/uuid"
)

// execCommand is a variable to allow mocking in tests
var execCommand = exec.Command
var execCommandContext = exec.CommandContext

var NAMESPACE = uuid.NewMD5(uuid.NameSpaceURL, []byte("calypr.org"))

type LfsDryRunSpec struct {
        Remote string // e.g. "origin"
        Ref    string // e.g. "refs/heads/main" or "HEAD"
}
</span>
//</span> RunLfsPushDryRun executes: git lfs push --dry-run &lt;remote&gt; &lt;ref&gt;
func RunLfsPushDryRun(ctx context.Context, repoDir string, spec LfsDryRunSpec, logger *slog.Logger) (string, error) <span class="cov1" title="1">{
        if spec.Remote == "" || spec.Ref == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing remote or ref")
        }</span>

        // Debug-print the command to stderr
        fullCmd := []string{"git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref}
        logger.Debug(fmt.Sprintf("running command: %v", fullCmd))

        cmd := execCommandContext(ctx, "git", "lfs", "push", "--dry-run", spec.Remote, spec.Ref)
        cmd.Dir = repoDir

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;</span>stderr

        err := cmd.Run()
        out := stdout.String()
        if err != nil </span></span>{
</span>                msg := strings.TrimSpace(stderr.String())
                if msg == "" </span></span><span class="cov0" title="0">{
                        msg = err.Error()
                }</span></span>
                <span class="cov0" title="0">return out, fmt.Errorf("git lfs push --dry-run failed: %s", msg)</span>
        }
        <span class="cov1" title="1">return out, nil</span>
}

// output of git lfs ls-files
type LfsLsOutput struct {
        Files []LfsFileInfo `json:"files"`
}

// LfsFileInfo represents the information about an LFS file
type LfsFileInfo struct {
        Name       string `json:"name"`
        Size       int64  `json:"size"`
        Checkout   bool   `json:"checkout"`
        Downloaded bool   `json:"downloaded"`
        OidType    string `json:"oid_type"`
        Oid        string `json:"oid"`
        Version    string `json:"version"`
}

</span>func PushLocalDrsObjects(drsClient client.DRSClient, gen3Client dataClient.Gen3Interface, bucketName string, upsert bool, myLogger *slog.Logger) error {
        /</span>/ Gather all objects in .git/drs/lfs/objects store
        drsLfsObjs, err := localLfs.GetDrsLfsObjects(myLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
</span>
</span>        // Make this a map if it does not exist when hitt</span><span class="cov0" title="0">ing the server
        sums := make([]*hash.Checksum, 0)
        for _, obj := range drsLfsObjs {
                for sumType, sum := range hash.ConvertHashInfoToMap(obj.Checksums) {
                        if sumType == hash.ChecksumTypeSHA256.String() {
                                </span>sums = append(sums, &amp;hash.Checksum{
                                        Checksum: sum,
                                        Type:     hash.ChecksumTypeSHA256,
                                })
        <span class="cov0" title="0">                }
                }
</span>        }

</span>        outobjs := map[string]*drs.DRSObject{}
        fo</span>r _, sum := range sums {
                records, err := drsClient.GetObjectByHash(context.Background(), sum)
                <span class="cov0" title="0">if err != nil {
</span>                        return err
                }
</span>
                <span class="cov0" title="0">if len(records) == 0 {
                        outobjs[sum.Checksum] = nil
                        continue
                }
</span>                found := false
</span>                // Warning: The loop overwrites map entries if multiple records have the same SHA256 hash.
                // If there are multiple records with SHA256 checksums, only the last one will be stored in the map
                fo</span>r i, rec := range records {
                        if rec.Checksums.SHA256 != "" {
                <span class="cov0" title="0">                found = </span><span class="cov0" title="0">true
                                outobjs[rec.Checksums.SHA256] = &amp;records[i]
                        </span>}
                }
                if !found {
        <span class="cov0" title="0">                outobjs[sum.Checksum] = nil
</span>                }
        }
</span>
        fo</span>r drsObjKey := range outobjs {
                <span class="cov0" title="0">val, ok := drsLfsObjs[drsObjKey]
</span>                if !ok {
                        myLogger.Debug(fmt.Sprintf("Drs record not found in sha256 map %s", drsObjKey))
                }
</span>                if _, statErr := os.Stat(val.Name); os.IsNotExist(statErr) {
                        m</span>yLogger.Debug(fmt.Sprintf("Error: Object record found locally, but file does not exist locally. Registering Record %s", val.Name))
                        _, err = drsClient.RegisterRecord(context.Background(), val)
                        if er<span class="cov0" title="0">r != nil {
                                return err
                        }
</span>
                } </span>else {
                        filePath, err := GetObjectPath(projectdir.LFS_OBJS_PATH, drsObjKey)
                        if err != nil {
        <span class="cov0" title="0">                        return </span>err
                        }

                        _, err = upload.RegisterAndUploadFile(
                                context.Background(),
                                gen3Client,</span><span class="cov0" title="0">
                                val,
                </span>                filePath,
        <span class="cov0" title="0">                        bucketName,
                                upsert,
</span>                        )
</span>                        if err != nil {
                                return </span>err
                        }
                <span class="cov0" title="0">}
        }
</span>        return nil
}
</span>
func PullRemoteDrsObjects(drsClient</span><span class="cov0" title="0"> client.DRSClient, logger *slog.Logger) error {
        objChan, err := drsClient.ListObjectsByProject(co</span><span class="cov0" title="0">ntext.Background(), drsClient.GetProjectId())
        if err != nil {
                return err
        }
</span>        writtenObjs := 0
        for </span>drsObj := range objChan {
                if drsObj.Object == nil {
                        logger.Debug(fmt.Sprintf("OBJ is nil: %#v, continuing...", drsObj))
                        continue
                <span class="cov0" title="0">}
</span>                sumMap := hash.ConvertHashInfoToMap(drsObj.Object.Checksums)
                if len(sumMap) == 0 {
                        return fmt.Errorf("error: drs Object '%s' does not contain a checksum", drsObj.Object.Id)
                }
</span>                var drsObjPath, oid string = "", ""
                fo</span>r sumType, sum := range sumMap {
                        if sumType == hash.ChecksumTypeSHA256.String() {
                                oid = sum
        <span class="cov0" title="0">                        drsObjPath, err = GetObjectPath(projectdir.DRS_OBJS_PATH, oid)
                                if err </span>!= nil {
                                        return fmt.Errorf("error getting object path for oid %s: %v", oid, err)
                                }
                        }
                }
                // Only write a record if there exists a proper checksum to use. Checksums besides sha256 are not used
                if drsObjPath != "" &amp;&amp; oid != "" {
                        writtenObjs++
                        // write drs objects to DRS_OBJS_PATH
                        err = WriteD</span><span class="cov0" title="0">rsObj(drsObj.Object, oid, drsObjPath)
                        if err != nil {
                </span>                return fmt.Errorf("error writing DRS object for oid %s: %v", oid, err)
                        }
                }
        <span class="cov5" title="4">}
        logger.Debug(fmt.Sp</span><span class="cov0" title="0">rintf("Wrote %d new objs to object store", writtenObjs))
        return nil
}
</span>
func UpdateDrsObjects(drsClient client.DRSClient, gitRemoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) error {

        <span class="cov5" title="4">logger.Debug("Update to DRS ob</span><span class="cov5" title="4">jects started")

        // get all lfs files
        lfsFiles, err :</span><span class="cov0" title="0">= GetAllLfsFiles(gitRemoteName, gitRemoteLocation, branches, logger)
        if err != nil {
                r</span>eturn fmt.Errorf("error getting all LFS files: %v", err)
        }<span class="cov5" title="4">
</span>
        // get pro</span>ject
        projectId := drsClient.GetProjectId()
        if projectId == "" {
                return fmt.Errorf("no project configured: %v", err)
        }

        /<span class="cov5" title="4">/ create a DRS object for each LFS file
        // which will be used at push-time
        for _, file := range lfsFiles {
                // check if indexd object already prepared, skip if so
                drsObjPath, err := GetObjectPath(projectdir.DRS_OBJS_PATH, file.Oid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
                }</span>
                <span class="cov5" title="4">if _, err := os.Stat(drsObjPath); err == nil {
</span>                        logger.Debug(fmt.Sprintf("Skipping record creation, file %s with OID %s already exists in DRS objects path %s", file.Name, file.Oid, drsObjPath))
                        </span>continue
                }

                // if file is </span><span class="cov0" title="0">in cache, hasn't been committed to git or pushed to indexd
                // create a local DRS object for it
                /</span>/ TODO: determine git to gen3 project hierarchy mapping (eg repo name to project ID)
                drsId := DrsUUID(projectId, file.Oid)
                // logger.Printf("File: %s, OID: %s, DRS ID: %s\n", file.Name, file.Oid, drsId)

                // get file in</span><span class="cov0" title="0">fo needed to create indexd record
                path, err := GetObjectPath(projectdir.LFS_OBJS_PATH, file.Oid)
                i</span>f err != nil {
                <span class="cov5" title="4">        return fmt.Errorf("error getting object path for oid %s: %v", file.Oid, err)
</span>                }
                if _, err := os.Stat(path); os.IsNotExist(err) {
        <span class="cov5" title="4">                return f</span>mt.Errorf("error: File %s does not exist in LFS objects path %s. Aborting", file.Name, path)
                }

                drsObj, err := drsClient.BuildDrsObj(file.Name, file.Oid, file.Size, drsId)<span class="cov5" title="4">
                if err != nil {
                        return fmt.Errorf("error building DRS object for oid %s: %v", file.Oid, err)
                }
</span>
                </span>// write drs objects to DRS_OBJS_PATH
        <span class="cov5" title="4">        err = WriteDrsObj(drsObj, file.Oid, drsObjPath)
</span>                if err != nil {
                </span>        return fmt.Errorf("error writing DRS object for oid %s: %v", file.Oid, err)
                }
                logger.Debug(fmt.Sprintf("Prepared File %s OID %s with DRS ID %s for commit", file.Name, file.Oid, drsObj.Id))
        <span class="cov5" title="4">}

</span>        return nil
}
</span>
</span>func WriteDrsObj(drsObj *drs.DRSObject, oid string, drsObjPath string) error {
        // get object bytes
        indexdObjBytes, err := sonic.ConfigFastest.Marshal<span class="cov5" title="4">(drsObj)
        if err != nil {
                return fmt.Errorf("error marshalling indexd object for oid %s: %v", oid, err)
        }
        </span>if err := os.MkdirAll(filepath.Dir(drsObjPath), 0755); err != nil {
                return fmt.Errorf("error creating directory for %s: %v", drsObjPath, err)
        }

        // write indexd obj to file as json
        err = os.WriteFile(drsObjPath, indexdObjBytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing %s: %v", drsObjPath, err)
        }</span>
        return nil
}<span class="cov5" title="4">

</span>func DrsUUID(projectId string, hash string) string {
        /</span>/ create UUID based on project ID and hash
        hashStr := fmt.Sprintf("%s:%s", projectId, hash)
        <span class="cov5" title="4">return uuid.NewSHA1(NAMESPACE, []byte(hashStr)).String()
}

</span>// creates drsObject record from file
fu</span>nc DrsInfoFromOid(oid string) (*drs.DRSObject, error) {
        // unmarshal the DRS object
        <span class="cov5" title="4">path, err := GetObject</span>Path(projectdir.DRS_OBJS_PATH, oid)
        if err != nil {
                return nil, fmt.Errorf("error getting object path for oid %s: %v", oid, err)
        }

        drsObjBytes, err :</span><span class="cov0" title="0">= os.ReadFile(path)
        if err != nil {
                </span>return nil, fmt.Errorf("error reading DRS object for oid %s: %v", oid, err)
        }

</span>        var drsObject drs.DRSObject
        err = sonic.ConfigFastest.Unmarshal(drsObjBytes, &amp;drsObject)
        if err != nil {
                return nil, fmt.Errorf("error unmarshaling DRS object for oid %s: %v", oid, err)
        }

        return &amp;drsObject, nil
}

func GetObjectPath(basePath string, oid string) (string, error) {
        // check that oid is a valid sha256 hash
        if len(oid) != 64 {
                return "", fm</span><span class="cov0" title="0">t.Errorf("error: %s is not a valid sha256 hash", oid)
        }

        r</span>eturn filepath.Join(basePath, oid[:2], oid[2:4], oid), nil
}

/<span class="cov0" title="0">///////////////
</span>// LFS HELPERS /
//</span>//////////////

// checkIfLfsFile checks if a given file is tracked by Git LFS
/<span class="cov0" title="0">/ Returns true and file info if it's an LFS file, false otherwise
func CheckIfLfsFile(fileName string) (bool, *LfsFileInfo, error) {
        // Use git lfs</span><span class="cov0" title="0"> ls-files -I to check if specific file is LFS tracked
        cmd := execCommand("git", "lfs", "ls-files", "-I", fileName, "--json")
        o</span>ut, err := cmd.Output()
        if err != nil {
                // If git lfs ls-files returns error, the file is not LFS tracked
        <span class="cov0" title="0">        return false, nil, nil
</span>        }

</span>        // If output is empty, file is not LFS tracked
        if len(strings.TrimSpace(string(out))) == 0 {
        <span class="cov0" title="0">        return false, nil, nil
        }

        // Parse the JSON output
        var lfsOutput LfsLsOutput
        err = sonic.ConfigFastest.Unmarshal(out, &amp;lfsOutput)
        if err != nil {
                return false, nil, fmt.Errorf("error unmarshaling git lfs ls-files output for %s: %v", fileName, err)
        }

        // If no files in output, not LFS tracked
        if len(lfsOutput.Files) =</span>= 0 {
                return false, nil, nil
        }

        // Convert to our LfsFileInfo struct
        file := lfsOutput.Files[0]
        lfsInfo := &amp;LfsFileInfo{
                Name:       file.Name,
                Size:       file.Size,
                Checkout:   f</span><span class="cov0" title="0">ile.Checkout,
                Downloaded: file.Downloaded,
                </span>OidType:    file.OidType,
        <span class="cov0" title="0">        Oid:        file.Oid,
                Version:    file.Versi</span>on,
        }

        return true, lfsInfo, nil
}

func getStagedFiles() ([]string, error) {
        // chose exec </span><span class="cov0" title="0">here for performance over using go-git
        // tradeoff is very rare concurrency problems which currently aren't relevant to the pre-commit
        /</span>/ FIXME: filter out files that have been deleted? Bug: if git rm, the DRS object still created
        cmd := exec.Command("git", "diff", "--name-only", "--cached")
        <span class="cov0" title="0">cmdOut, err := cmd.Output()
        if err != nil {
                return nil, fmt.Err</span>orf("error running git command: %w: out: '%s'", err, string(cmdOut))
        }
        stagedFiles := strings.Split(strings.TrimSpace(string(cmdOut)), "\n")
        return stagedFiles, nil
}
</span>
fu</span>nc GetRepoNameFromGit(remote string) (string, error) {
        <span class="cov5" title="4">// prefer simple os.Exec over using go-git
        cmd := exec.Co</span><span class="cov0" title="0">mmand("git", "config", "--get", fmt.Sprintf("remote.%s.url", remote))
        out, err := cmd.Output()
        i</span>f err != nil {
                return "", err
        }

        remoteURL := strings.TrimSpace(string(out))
        repoName := strings.TrimSuffix(filepath.Base(remoteURL), ".git")
        return repoName, nil
}

func GetAllLfsFiles(gitR</span><span class="cov0" title="0">emoteName, gitRemoteLocation string, branches []string, logger *slog.Logger) (map[string]LfsFileInfo, error) {
        if logger == nil {
                </span>return nil, fmt.Errorf("logger is required")
        <span class="cov5" title="4">}
</span>        repoDir, err := os.Getwd()
        i</span>f err<span class="cov0" title="0"> != nil {
                return nil, err
        }</span>

        <span class="cov5" title="4">// no timeout for now
        ctx := context.Background()
        // If needed, can re-enab</span><span class="cov5" title="4">le timeout
        // Set a timeout context for git commands, 3 minutes should be enough
        //ctx, cancel := context.WithTimeout(context.Background(), 180*time.Second)
        //defer cancel()

        if gitRemoteName == "" {
                gitRemoteName </span><span class="cov0" title="0">= "origin"
        }
        if</span> gitRemoteLocation != "" {
                logger.Debug(fmt.Sprintf("Using git remote %s at %s for LFS dry-run", gitRemoteName, gitRemoteLocation))
        }<span class="cov5" title="4"> else {
</span>                logger.Debug(fmt.Sprintf("Using git remote %s for LFS dry-run", gitRemoteName))
        }
</span>
        refs := buildLfsRefs(branches)
        <span class="cov5" title="4">lfsFileMap := make(map</span>[string]LfsFileInfo)
        for _, ref := range refs {
                spec := LfsDryRunSpec{
                        Remote: gitRemoteName,
                        Ref:    ref,
</span>                }
                </span>out, err := RunLfsPushDryRun(ctx, repoDir, spec, logger)
        <span class="cov5" title="4">        if err != nil {
                        return nil, err
                }
</span>
                if err := addLfs</span><span class="cov0" title="0">FilesFromDryRun(out, repoDir, logger, lfsFileMap); err != nil {
                        return n</span>il, err
                }
        }<span class="cov5" title="4">

</span>        return lfsFileMap, nil
}
</span>
</span>func buildL</span>fsRefs(branches []string) []string {
        if len(branches) == 0 {
                <span class="cov5" title="4">return []string{"HEAD"}
        }
</span>        refs := make([]string, 0, len(branches))
        <span class="cov5" title="4">seen := make(map[s</span><span class="cov0" title="0">tring]struct{})
        for _, branch := range branches {
                </span>branch = strings.TrimSpace(branch)
        <span class="cov5" title="4">        if branch </span>== "" {
                        continue
                }
                ref := branch
                if branch != "HEAD" &amp;&amp; !strings.HasPrefix(branch, "refs/") {
                        ref = fmt.Sprintf("refs/heads/</span><span class="cov0" title="0">%s", branch)
                }
                if _, ok := seen[ref]; ok {
                </span>        continue
                }
                seen[ref] = struct{}{}
        <span class="cov5" title="4">        refs = append(refs, ref)
        }
        if len(refs) == 0 {
</span>                return []string{"HEAD"}
        }
</span>        return ref</span>s
}

func addLfsFilesFrom</span><span class="cov0" title="0">DryRun(out, repoDir string, logger *slog.Logger, lfsFileMap map[string]LfsFileInfo) error {
        // Log whe</span>n dry-run returns no output to help with debugging
        if strings.TrimSpace(out) == "" {
                <span class="cov6" title="6">logger.Debug("No LFS files to push (dry-run returned no output)")
                return nil
        }

        // accept lowercase or uppercas</span><span class="cov0" title="0">e hex
        sha256Re := regexp.MustCompile(`(?i)^[a-f0-9]{64}$`)

</span>        for _, line := range strings.Split(strings.TrimSpace(string(out)), "\n") {
                line = strings.TrimSpace(line)
                if line == "" {
                <span class="cov6" title="6">        continue
</span>                }
                parts := </span>strings.Fields(line)
                if len(parts) &lt; 2 {
                        continue
                }
                <span class="cov5" title="4">oid := parts[1]
</span>                path := parts[len(parts)-1]

</span>                <span class="cov5" title="4">// Validate OID looks like a SHA256 hex string.
                if !sha256Re.MatchString(oid) {
                        logger.Debug(fmt.Sprintf("skipping LFS li</span><span class="cov5" title="4">ne with invalid oid %q: %q", oid, line))
                        continue
                }</span>

</span>                // see https://github.com/calypr/git-drs/issues/124#issuecomment-3721837089
                i</span>f oid<span class="cov0" title="0"> == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" &amp;&amp; strings.Contains(path, ".gitattributes") {
                        logger.Debug(fmt.Sprintf("skipping empty LFS pointer for %s", path))
                        continue</span>
                }
                // Remove a trailing parenthetical suffix from p, e.g.:
                // "path/to/file.dat (100 KB)" -&gt; "path/to/file.dat"
                if idx := strings.LastIndex(path, " ("); idx != -1 &amp;&amp; strings.HasSuffix(path, ")") {
                <span class="cov5" title="4">        path = strings.TrimSpace(p</span><span class="cov3" title="2">ath[:idx])
                }
</span>                size := int64(0)
                absPath := path
</span>                if repoDir != "" &amp;&amp; !filepath.IsAbs(path) {
                        absPath = </span>filepath.Join(repoDir, path)
                }
                if stat, err := os.Stat(absPath); err == nil {
                        size = stat.Size()
                } else {
                <span class="cov5" title="4">        logger.Error(fmt.Sprintf("could not stat file %s: %v", path, err))
                        continue
                }

                // If the file is small, read it and detect LFS pointer signature.
                // Pointer files are textual and include the LFS spec version + an oid line.
                i</span>f size &gt; 0 &amp;&amp; size &lt; 2048 {
                        if data, readErr := os.ReadFile(absPath); readErr == nil {
                                s := strings.TrimSpace(string(data))
                                if strings.Contains(s, "version https://git-lfs.github.com/spec/v1") &amp;&amp; strings.Contains(s, "oid sha256:") {
        <span class="cov5" title="4">                                logger</span>.Warn(fmt.Sprintf("WARNING: Detected upload of lfs pointer file %s skipping", path))
                                        continue
                                }
                        }
                }

                lfsFileMap[path] = LfsFileInfo{
                        Name:    path,
                        Size:    size,
</span>                        OidType: "sha256",
                </span>        Oid:     oid,
        <span class="cov0" title="0">                Version: "https://git-lfs.github.com/spec/v1",
                }
                //logger.Printf("GetAllLfsFiles added LFS file %s", path)
        }

</span>        return nil
</span>}

</span>// CreateCustomPath creates a custom path based on the DRS URI
// For example, DRS URI drs://&lt;namespace&gt;:&lt;drs_id&gt;
/<span class="cov0" title="0">/ create custom pa</span><span class="cov0" title="0">th &lt;baseDir&gt;/&lt;namespace&gt;/&lt;drs_id&gt;
func CreateCustomPath(baseDir, drsURI string) (string, error) {
        c</span>onst prefix = "drs://"
        <span class="cov0" title="0">if len(drsURI) &lt;= len(prefix) || drsURI[:len(prefix)] != prefix {
                return "", fmt.Errorf("invalid DRS URI: %s", drsURI)
        }
</span>        rest := drsURI[len(prefix):]

        // Split by first colon
        colonIdx := -1
        for i, c := range rest {
                if c == ':' {
</span>                        colonIdx = i
                </span>        break
                }
        }
        <span class="cov5" title="4">if colonIdx == -1 {
                return "", fm</span><span class="cov0" title="0">t.Errorf("DRS URI missing colon: %s", drsURI)
        }
        n</span>amespace := rest[:colonIdx]
        drsId := rest[colonIdx+1:]
        return filepath.Join(baseDir, namespace, drsId), nil
}

</span>// FindMatchingRecord finds a record from the </span><span class="cov5" title="4">list that matches the given project ID authz
// If no matching record is found return nil
func FindMatchingRecord(records []d</span><span class="cov0" title="0">rs.DRSObject, projectId string) (*drs.DRSObject, error) {
        if len(records) == 0 {
                re</span>turn nil, nil
        }
</span>
        // </span>Convert project ID to resource path format for comparison
        expectedAuthz, err := utils.ProjectToResource(projectId)
        if err != nil {
                return nil, fmt.Errorf("error converting project ID to resource format: %v", err)
        <span class="cov0" title="0">}
</span>
        // Get the first record with matching authz if exists

        for _, record := range records {
                for _, access := range record.AccessMethods {
                        // assert access has Authorizations
                        if access.Authorizations == nil {
                                return nil, fmt.Errorf("access method for record %v missing authorizations", record)
                        }
                        if access.Authorizations.Value == expectedAuthz {
                                return &amp;record, nil
                        }
                }
        }

        return nil, nil
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/calypr/git-drs/cmd"
        "github.com/calypr/git-drs/drslog"
)

func main() <span class="cov10" title="44">{

        _, err := drslog.NewLogger("", true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open log file: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov10" title="44">if err := cmd.RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                drslog.Close() // closes log file if there was one
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package testutils

import (
        "os"
        "testing"
)

// TestCmdMain is a generic test for cmd main packages
// It verifies the package compiles and can handle basic argument scenarios
func TestCmdMain(t *testing.T, cmdName string) <span class="cov6" title="8">{
        t.Helper()

        // Save original args
        oldArgs := os.Args
        defer func() </span><span class="cov6" title="8">{ os.Args = oldArgs }</span>()

        // Test with no arguments
        <span class="cov6" title="8">os.Args = []string{cmdName}

        t.Logf("%s main function test", cmdName)</span>
}

// TestCmdArgs is a generic test for validating command arguments
func TestCmdArgs(t *testing.T) <span class="cov6" title="8">{
        t.Helper()

        tests := []struct {
                name string
                args []string
        }{
                {"no args", []string{}},
                {"one arg", []string{"arg1"}},
                {"multiple args", []string{"arg1", "arg2"}},
        }

        for _, tt := range tests </span><span class="cov10" title="24">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov10" title="24">{
                        if len(tt.args) &gt;= 0 </span><span class="cov10" title="24">{
                                t.Logf("Args count: %d", len(tt.args))
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package testutils

import (
        "os"
        "os/exec"
        "path/filepath"
        "testing"

        indexd_client "github.com/calypr/git-drs/client/indexd"
        "github.com/calypr/git-drs/config"
        "github.com/calypr/git-drs/projectdir"
        "github.com/stretchr/testify/require"
        "gopkg.in/yaml.v3"
)

// SetupTestGitRepo creates a temp directory mocking a real git repo
func SetupTestGitRepo(t *testing.T) string <span class="cov10" title="3">{
        t.Helper()

        tmpDir, err := os.MkdirTemp("", "git-drs-test-*")
        require.NoError(t, err)

        originalDir, err := os.Getwd()
        require.NoError(t, err)

        err = os.Chdir(tmpDir)
        require.NoError(t, err)

        cmd := exec.Command("git", "init")
        cmd.Dir = tmpDir
        err = cmd.Run()
        require.NoError(t, err)

        cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        cmd = exec.Command("git", "config", "user.name", "Test User")
        cmd.Dir = tmpDir
        _ = cmd.Run()

        t.Cleanup(func() </span><span class="cov10" title="3">{
                os.Chdir(originalDir)
                os.RemoveAll(tmpDir)
        }</span>)

        <span class="cov10" title="3">return tmpDir</span>
}

// CreateTestConfig creates a test Git DRS config file with the given content
func CreateTestConfig(t *testing.T, tmpDir string, cfg *config.Config) string <span class="cov0" title="0">{
        t.Helper()

        configDir := filepath.Join(tmpDir, projectdir.DRS_DIR)
        err := os.MkdirAll(configDir, 0755)
        require.NoError(t, err)

        configPath := filepath.Join(configDir, projectdir.CONFIG_YAML)
        file, err := os.Create(configPath)
        require.NoError(t, err)
        defer file.Close()

        encoder := yaml.NewEncoder(file)
        err = encoder.Encode(cfg)
        require.NoError(t, err)

        return configPath
}</span>

// CreateDefaultTestConfig creates a standard test configuration
func CreateDefaultTestConfig(t *testing.T, tmpDir string) *config.Config <span class="cov0" title="0">{
        t.Helper()

        testConfig := &amp;config.Config{
                Remotes: map[config.Remote]config.RemoteSelect{
                        config.Remote(config.ORIGIN): {
                                Gen3: &amp;indexd_client.Gen3Remote{
                                        Endpoint:  "https://test.gen3.org",
                                        ProjectID: "test-project",
                                        Bucket:    "test",
                                },
                        },
                },
        }

        CreateTestConfig(t, tmpDir, testConfig)
        return testConfig
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package testutils

import (
        "bytes"
        "io"
        "os"
        "testing"

        "github.com/stretchr/testify/require"
)

// CaptureStdout captures stdout during test execution
func CaptureStdout(t *testing.T, f func()) string <span class="cov10" title="5">{
        t.Helper()

        r, w, err := os.Pipe()
        require.NoError(t, err)

        oldStdout := os.Stdout
        os.Stdout = w

        defer func() </span><span class="cov10" title="5">{
                os.Stdout = oldStdout
        }</span>()

        <span class="cov10" title="5">outC := make(chan string)
        go func() </span><span class="cov10" title="5">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, r)
                outC &lt;- buf.String()
        }</span>()

        <span class="cov10" title="5">f()

        w.Close()
        output := &lt;-outC

        return output</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package lfs

import (
        "github.com/bytedance/sonic/encoder"
)

// InitMessage represents the structure of the initiation data
type InitMessage struct {
        Event               string `json:"event"`               // Always "init" to identify this message
        Operation           string `json:"operation"`           // "upload" or "download" depending on transfer direction
        Remote              string `json:"remote"`              // Git remote name or URL
        Concurrent          bool   `json:"concurrent"`          // Reflects lfs.customtransfer.&lt;name&gt;.concurrent
        ConcurrentTransfers int    `json:"concurrenttransfers"` // Reflects lfs.concurrenttransfers value
}

// CompleteMessage is a minimal response to signal transfer is "complete"
type CompleteMessage struct {
        Event string `json:"event"`
        Oid   string `json:"oid"`
        Path  string `json:"path,omitempty"`
}

// UploadMessage represents a request to upload an object.
type UploadMessage struct {
        Event  string  `json:"event"`  // "upload"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Path   string  `json:"path"`   // Local path to file
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
}

// DownloadMessage represents a request to download an object.
type DownloadMessage struct {
        Event  string  `json:"event"`  // "download"
        Oid    string  `json:"oid"`    // Object ID (SHA-256 hash)
        Size   int64   `json:"size"`   // Size in bytes
        Action *Action `json:"action"` // Transfer action details (optional, may be omitted)
        Path   string  `json:"path"`   // Where to store the downloaded file
}

// TerminateMessage is sent when the agent should terminate.
type TerminateMessage struct {
        Event string `json:"event"` // "terminate"
}

// ErrorMessage is sent when an error occurs during a transfer.
type ErrorMessage struct {
        Event string `json:"event"` // "error"
        Oid   string `json:"oid"`   // Object ID involved in the error
        Error Error  `json:"error"` // Error details
}

type InitErrorMessage struct {
        Error Error `json:"error"` // Error details
}

type Error struct {
        Code    int    `json:"code"`    // Error code (standard or custom)
        Message string `json:"message"` // Human-readable error message
}

// ProgressResponse provides progress updates for an object transfer.
type ProgressResponse struct {
        Event          string `json:"event"`          // "progress"
        Oid            string `json:"oid"`            // Object ID being transferred
        BytesSoFar     int64  `json:"bytesSoFar"`     // Bytes transferred so far
        BytesSinceLast int64  `json:"bytesSinceLast"` // Bytes transferred since last progress message
}

// TerminateResponse signals the agent has completed termination.
type TerminateResponse struct {
        Event string `json:"event"` // "terminate"
}

// Action is an optional struct representing transfer actions (upload/download URLs, etc.)
type Action struct {
        Href      string            `json:"href"`
        Header    map[string]string `json:"header,omitempty"`
        ExpiresIn int               `json:"expires_in,omitempty"`
}

func WriteInitErrorMessage(encoder *encoder.StreamEncoder, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := InitErrorMessage{
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteErrorMessage(encoder *encoder.StreamEncoder, oid string, code int, errMsg string) <span class="cov1" title="1">{
        // create failure message and send it back
        errorResponse := ErrorMessage{
                Event: "complete",
                Oid:   oid,
                Error: Error{
                        Code:    code,
                        Message: errMsg,
                },
        }
        encoder.Encode(errorResponse)
}</span>

func WriteCompleteMessage(encoder *encoder.StreamEncoder, oid string, path string) <span class="cov10" title="9">{
        // create success message and send it back
        completeResponse := CompleteMessage{
                Event: "complete",
                Oid:   oid,
                Path:  path,
        }
        encoder.Encode(completeResponse)
}</span>

func WriteProgressMessage(encoder *encoder.StreamEncoder, oid string, bytesSoFar int64, bytesSinceLast int64) <span class="cov8" title="7">{
        progressResponse := ProgressResponse{
                Event:          "progress",
                Oid:            oid,
                BytesSoFar:     bytesSoFar,
                BytesSinceLast: bytesSinceLast,
        }
        encoder.Encode(progressResponse)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package lfs

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        "github.com/bytedance/sonic"
        drs "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/git-drs/projectdir"
)

// This file contains functions that pertain to .git/drs/lfs/objects directory walk
type PendingObject struct {
        OID  string
        Path string
}

// getPendingObjects walks .git/drs/lfs/objects/ to find all pending records
func GetPendingObjects(logger *slog.Logger) ([]*PendingObject, error) <span class="cov1" title="1">{
        var objects []*PendingObject
        objectsDir := projectdir.DRS_OBJS_PATH

        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov9" title="5">if info.IsDir() </span><span class="cov6" title="3">{
                        return nil
                }</span>
                <span class="cov4" title="2">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov1" title="1">oid := parts[2] // GetObjectPath stores full OID in the 3rd directory level
                objects = append(objects, &amp;PendingObject{
                        OID: oid,
                })
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found %d pending objects in %s", len(objects), objectsDir))
        return objects, nil</span>
}

func GetDrsLfsObjects(logger *slog.Logger) (map[string]*drs.DRSObject, error) <span class="cov1" title="1">{
        objects := map[string]*drs.DRSObject{}
        objectsDir := projectdir.DRS_OBJS_PATH
        if _, err := os.Stat(objectsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Debug(fmt.Sprintf("DRS objects directory not found: %s", objectsDir))
                return nil, nil
        }</span>

        <span class="cov1" title="1">err := filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error accessing path %s: %v", path, err))
                        return err
                }</span>
                <span class="cov10" title="6">if info.IsDir() </span><span class="cov6" title="3">{
                        return nil
                }</span>
                <span class="cov6" title="3">rel, err := filepath.Rel(objectsDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="3">parts := strings.SplitN(rel, string(os.PathSeparator), 3)
                if len(parts) != 3 </span><span class="cov1" title="1">{
                        logger.Debug(fmt.Sprintf("Skipping malformed path: %s", path))
                        return nil
                }</span>
                <span class="cov4" title="2">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("Error reading file %s: %v", path, err))
                        return err
                }</span>
                <span class="cov4" title="2">var drsObject drs.DRSObject
                if err := sonic.ConfigFastest.Unmarshal(data, &amp;drsObject); err != nil </span><span class="cov1" title="1">{
                        logger.Error(fmt.Sprintf("Error unmarshalling JSON from %s: %v", path, err))
                        return nil
                }</span>

                // This could be problematic
                <span class="cov1" title="1">if drsObject.Checksums.SHA256 != "" </span><span class="cov1" title="1">{
                        objects[drsObject.Checksums.SHA256] = &amp;drsObject
                }</span>

                <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Successfully unmarshaled DRSObject from %s:\n%+v", path, drsObject))
                return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">logger.Debug(fmt.Sprintf("Found and unmarshaled %d DRS objects.", len(objects)))
        return objects, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package lfs

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/bytedance/sonic"
        "github.com/calypr/data-client/indexd/drs"
        "github.com/calypr/git-drs/utils"
)

const DRS_DIR = ".git/drs"

type DrsWalkFunc func(path string, d *drs.DRSObject) error

func BaseDir() (string, error) <span class="cov1" title="1">{
        gitTopLevel, err := utils.GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return filepath.Join(gitTopLevel, DRS_DIR), nil</span>
}

type dirWalker struct {
        baseDir  string
        userFunc DrsWalkFunc
}

func (d *dirWalker) call(path string, dir fs.DirEntry, cErr error) error <span class="cov10" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov6" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">obj := drs.DRSObject{}
        err = sonic.ConfigFastest.Unmarshal(data, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">relPath, err := filepath.Rel(d.baseDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return d.userFunc(relPath, &amp;obj)</span>
}

func ObjectWalk(f DrsWalkFunc) error <span class="cov1" title="1">{
        baseDir, err := BaseDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">ud := dirWalker{baseDir, f}
        return filepath.WalkDir(baseDir, ud.call)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package s3_utils

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
)

// downloads a file to a specified path using a signed URL
func DownloadSignedUrl(signedURL string, dstPath string) error <span class="cov10" title="6">{
        // Download the file using the signed URL
        fileResponse, err := http.Get(signedURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="6">defer fileResponse.Body.Close()

        // Check if the response status is OK
        if fileResponse.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, err := io.ReadAll(fileResponse.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download file using signed URL: %s", fileResponse.Status)
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("failed to download file using signed URL: %s. Full error: %s", fileResponse.Status, string(body))</span>
        }

        // Create the destination directory if it doesn't exist
        <span class="cov9" title="5">err = os.MkdirAll(filepath.Dir(dstPath), os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the destination file
        <span class="cov9" title="5">dstFile, err := os.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="5">defer dstFile.Close()

        // Write the file content to the destination file
        _, err = io.Copy(dstFile, fileResponse.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package s3_utils

import (
        "log/slog"
        "net/http"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

type S3BucketsResponse struct {
        GSBuckets map[string]any       `json:"GS_BUCKETS"`
        S3Buckets map[string]*S3Bucket `json:"S3_BUCKETS"`
}

type S3Bucket struct {
        Region      string   `json:"region,omitempty"`
        EndpointURL string   `json:"endpoint_url,omitempty"`
        Programs    []string `json:"programs,omitempty"`
}

// S3Meta holds S3 object metadata
type S3Meta struct {
        Size         int64
        LastModified string
}

type CustomEndpointResolver struct {
        Endpoint string
}

const (
        AWS_KEY_FLAG_NAME          = "aws-access-key-id"
        AWS_SECRET_FLAG_NAME       = "aws-secret-access-key"
        AWS_KEY_ENV_VAR            = "AWS_ACCESS_KEY_ID"
        AWS_SECRET_ENV_VAR         = "AWS_SECRET_ACCESS_KEY"
        AWS_REGION_FLAG_NAME       = "region"
        AWS_REGION_ENV_VAR         = "AWS_REGION"
        AWS_ENDPOINT_URL_FLAG_NAME = "endpoint-url"
        AWS_ENDPOINT_URL_ENV_VAR   = "AWS_ENDPOINT_URL"
)

// AuthHandler is an interface for adding authentication headers
// This allows us to inject different auth implementations for testing vs production
type AuthHandler interface {
        AddAuthHeader(req *http.Request) error
}

func (r *CustomEndpointResolver) ResolveEndpoint(service, region string) (aws.Endpoint, error) <span class="cov8" title="1">{
        return aws.Endpoint{
                URL: r.Endpoint,
        }, nil
}</span>

// AddURLConfig holds optional clients for dependency injection
type AddURLConfig struct {
        S3Client   *s3.Client
        HttpClient *http.Client
        Logger     *slog.Logger
}

// AddURLOption is a functional option for configuring AddURL
type AddURLOption func(*AddURLConfig)

// WithS3Client provides a custom S3 client to AddURL
func WithS3Client(client *s3.Client) AddURLOption <span class="cov8" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov8" title="1">{
                cfg.S3Client = client
        }</span>
}

// WithHTTPClient provides a custom HTTP client to AddURL
func WithHTTPClient(client *http.Client) AddURLOption <span class="cov8" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov8" title="1">{
                cfg.HttpClient = client
        }</span>
}

// WithLogger provides a custom logger to AddURL
func WithLogger(logger *slog.Logger) AddURLOption <span class="cov8" title="1">{
        return func(cfg *AddURLConfig) </span><span class="cov8" title="1">{
                cfg.Logger = logger
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package s3_utils

import (
        "encoding/hex"
        "errors"
        "strings"
)

func ValidateInputs(s3URL string, sha256 string) error <span class="cov10" title="26">{
        if !strings.HasPrefix(s3URL, "s3://") </span><span class="cov6" title="8">{
                return errors.New("invalid S3 URL format. URL should be of the format 's3://bucket/path/to/file'")
        }</span>

        // Normalize case and validate SHA256
        <span class="cov8" title="18">sha256 = strings.ToLower(sha256)
        if len(sha256) != 64 </span><span class="cov5" title="5">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov8" title="13">if _, err := hex.DecodeString(sha256); err != nil </span><span class="cov2" title="2">{
                return errors.New("invalid SHA256 hash. Ensure it is a valid 64-character hexadecimal string.")
        }</span>

        <span class="cov7" title="11">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Creates directories from stdin lines, each with 16 `sub-directory-N` subfolders, each containing 1001000 files of 1 KiB whose contents are the relative file path. Save as `generate-fixtures.go`.

package main

import (
        "bufio"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

const (
        minSubDirs = 1
        maxSubDirs = 6

        minFilesPerSub = 100
        maxFilesPerSub = 1000

        fileSizeBytes = 1024
)

// main reads directory names from stdin (one per line) and creates a set of
// "fixture" directories and files for each input name. For each top-level
// directory it creates between minSubDirs and maxSubDirs subdirectories
// named "sub-directory-N". Each subdirectory receives between minFilesPerSub
// and maxFilesPerSub files. File contents are written as the relative path
// bytes. The program prints progress and errors to stderr and exits with a
// non-zero code on read errors or when no input is provided.
func main() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())

        // Flags: if &gt;0 they override randomness
        numSubdirsFlag := flag.Int("number-of-subdirectories", 0, "fixed number of subdirectories per top-level directory (overrides random)")
        numFilesFlag := flag.Int("number-of-files", 0, "fixed number of files per subdirectory (overrides random)")
        flag.Parse()

        scanner := bufio.NewScanner(os.Stdin)
        entries := []string{}
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">entries = append(entries, line)</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "reading stdin: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "no input lines; provide one directory name per line on stdin")
                os.Exit(1)
        }</span>

        // Determine digits for file name padding based on configured or default max
        <span class="cov0" title="0">maxFilesConsidered := maxFilesPerSub
        if *numFilesFlag &gt; 0 &amp;&amp; *numFilesFlag &gt; maxFilesConsidered </span><span class="cov0" title="0">{
                maxFilesConsidered = *numFilesFlag
        }</span>
        <span class="cov0" title="0">maxFilesDigits := len(strconv.Itoa(maxFilesConsidered))

        for _, name := range entries </span><span class="cov0" title="0">{
                // Clean the path and disallow absolute paths for safety
                clean := filepath.Clean(name)
                if filepath.IsAbs(clean) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping absolute path: %s\n", name)
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(clean, ".."+string(os.PathSeparator)) || clean == ".." </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "skipping path outside current tree: %s\n", name)
                        continue</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(clean, 0o755); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", clean, err)
                        continue</span>
                }

                // Choose number of subdirectories
                <span class="cov0" title="0">var nSub int
                if *numSubdirsFlag &gt; 0 </span><span class="cov0" title="0">{
                        if *numSubdirsFlag &lt; 1 </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "invalid --number-of-subdirectories: %d (must be &gt;= 1)\n", *numSubdirsFlag)
                                continue</span>
                        }
                        <span class="cov0" title="0">nSub = *numSubdirsFlag</span>
                } else<span class="cov0" title="0"> {
                        nSub = rand.Intn(maxSubDirs-minSubDirs+1) + minSubDirs
                }</span>

                <span class="cov0" title="0">for si := 1; si &lt;= nSub; si++ </span><span class="cov0" title="0">{
                        subdir := filepath.Join(clean, fmt.Sprintf("sub-directory-%d", si))
                        if err := os.MkdirAll(subdir, 0o755); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "mkdir %s: %v\n", subdir, err)
                                continue</span>
                        }

                        // Choose number of files per subdirectory
                        <span class="cov0" title="0">var nFiles int
                        if *numFilesFlag &gt; 0 </span><span class="cov0" title="0">{
                                if *numFilesFlag &lt; 1 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "invalid --number-of-files: %d (must be &gt;= 1)\n", *numFilesFlag)
                                        continue</span>
                                }
                                <span class="cov0" title="0">nFiles = *numFilesFlag</span>
                        } else<span class="cov0" title="0"> {
                                nFiles = rand.Intn(maxFilesPerSub-minFilesPerSub+1) + minFilesPerSub
                        }</span>

                        <span class="cov0" title="0">for fi := 1; fi &lt;= nFiles; fi++ </span><span class="cov0" title="0">{
                                filename := fmt.Sprintf("file-%0*d.dat", maxFilesDigits, fi)
                                path := filepath.Join(subdir, filename)
                                pathBytes := []byte(path)
                                if err := os.WriteFile(path, pathBytes, 0o644); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "write %s: %v\n", path, err)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "created %d files in %s\n", nFiles, subdir)</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "done: %s (%d subdirs)\n", clean, nSub)</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package utils

import (
        "fmt"
        "strings"
)

const (
        DRS_DIR = ".git/drs"
)

func ProjectToResource(project string) (string, error) <span class="cov10" title="17">{
        if !strings.Contains(project, "-") </span><span class="cov3" title="2">{
                return "", fmt.Errorf("error: invalid project ID %s in config file, ID should look like &lt;program&gt;-&lt;project&gt;", project)
        }</span>
        <span class="cov9" title="15">projectIdArr := strings.SplitN(project, "-", 2)
        return "/programs/" + projectIdArr[0] + "/projects/" + projectIdArr[1], nil</span>
}

// AddUnique appends items from 'toAdd' to 'existing' only if they're not already present.
// Returns the updated slice with unique items.
func AddUnique[T comparable](existing []T, toAdd []T) []T <span class="cov1" title="1">{
        // seen map uses struct{} as the value for memory efficiency
        seen := make(map[T]struct{}, len(existing))

        // Populate the set with existing items
        for _, item := range existing </span><span class="cov3" title="2">{
                seen[item] = struct{}{}
        }</span>

        <span class="cov1" title="1">for _, item := range toAdd </span><span class="cov3" title="2">{
                // check if item not yet in the set
                if _, found := seen[item]; !found </span><span class="cov1" title="1">{
                        existing = append(existing, item)
                        // Add the new unique item to the set
                        seen[item] = struct{}{}
                }</span>
        }
        <span class="cov1" title="1">return existing</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
)

const (
        // ConfirmationYes is the string users must type to confirm destructive operations
        ConfirmationYes = "yes"
)

// PromptForConfirmation displays a prompt and reads user input to confirm an operation.
// Returns nil if the response matches expectedResponse, error otherwise.
// If caseSensitive is false, comparison is case-insensitive.
func PromptForConfirmation(w io.Writer, prompt string, expectedResponse string, caseSensitive bool) error <span class="cov10" title="2">{
        fmt.Fprintf(w, "%s: ", prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading confirmation: %v", err)
        }</span>

        <span class="cov10" title="2">response = strings.TrimSpace(response)
        if !caseSensitive </span><span class="cov1" title="1">{
                response = strings.ToLower(response)
                expectedResponse = strings.ToLower(expectedResponse)
        }</span>

        <span class="cov10" title="2">if response != expectedResponse </span><span class="cov1" title="1">{
                return fmt.Errorf("operation cancelled: confirmation did not match")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DisplayWarningHeader writes a formatted warning header to the writer
func DisplayWarningHeader(w io.Writer, operation string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\n  WARNING: You are about to %s\n\n", operation)
}</span>

// DisplayField writes a formatted key-value field to the writer
func DisplayField(w io.Writer, key, value string) <span class="cov1" title="1">{
        fmt.Fprintf(w, "%-11s %s\n", key+":", value)
}</span>

// DisplayFooter writes the standard "cannot be undone" footer to the writer
func DisplayFooter(w io.Writer) <span class="cov1" title="1">{
        fmt.Fprintf(w, "\nThis action CANNOT be undone.\n\n")
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// GitAttribute represents a single line in .gitattributes file
type GitAttribute struct {
        Pattern    string
        Attributes map[string]string
}

// ParseGitAttributes parses the content of a .gitattributes file
func ParseGitAttributes(content string) ([]GitAttribute, error) <span class="cov5" title="26">{
        var attributes []GitAttribute
        scanner := bufio.NewScanner(strings.NewReader(content))

        for scanner.Scan() </span><span class="cov9" title="263">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov7" title="108">{
                        continue</span>
                }

                <span class="cov8" title="155">attr, err := parseLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed lines
                }

                <span class="cov8" title="155">attributes = append(attributes, attr)</span>
        }

        <span class="cov5" title="26">return attributes, scanner.Err()</span>
}

// parseLine parses a single line from .gitattributes
func parseLine(line string) (GitAttribute, error) <span class="cov8" title="155">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return GitAttribute{}, nil
        }</span>

        <span class="cov8" title="155">pattern := parts[0]
        attributes := make(map[string]string)

        for _, attr := range parts[1:] </span><span class="cov10" title="416">{
                if strings.Contains(attr, "=") </span><span class="cov9" title="284">{
                        // Handle key=value attributes
                        kv := strings.SplitN(attr, "=", 2)
                        attributes[kv[0]] = kv[1]
                }</span> else<span class="cov8" title="132"> if strings.HasPrefix(attr, "-") </span><span class="cov7" title="87">{
                        // Handle negated attributes (-attr)
                        attributes[attr[1:]] = "false"
                }</span> else<span class="cov6" title="45"> {
                        // Handle simple attributes (attr)
                        attributes[attr] = "true"
                }</span>
        }

        <span class="cov8" title="155">return GitAttribute{
                Pattern:    pattern,
                Attributes: attributes,
        }, nil</span>
}

func IsLFSTracked(gitattributesFilePath, filePath string) (bool, error) <span class="cov0" title="0">{
        gitattributesContent, err := os.ReadFile(gitattributesFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read .gitattributes file: %w", err)
        }</span>

        <span class="cov0" title="0">return isLFSTracked(string(gitattributesContent), filePath)</span>
}

// isLFSTracked determines if a given file path is tracked by Git LFS
func isLFSTracked(gitattributesContent string, filePath string) (bool, error) <span class="cov5" title="25">{
        attributes, err := ParseGitAttributes(gitattributesContent)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Process attributes in order, later rules override earlier ones
        <span class="cov5" title="25">isLFS := false

        for _, attr := range attributes </span><span class="cov7" title="107">{
                if matchesPattern(attr.Pattern, filePath) </span><span class="cov5" title="15">{
                        // Check for LFS attributes
                        if filter, exists := attr.Attributes["filter"]; exists </span><span class="cov4" title="13">{
                                return filter == "lfs", nil // Return immediately on filter match
                        }</span>
                }
        }

        <span class="cov4" title="12">return isLFS, nil</span>
}

// matchesPattern checks if a file path matches a gitattributes pattern
func matchesPattern(pattern, filePath string) bool <span class="cov8" title="125">{
        // Handle exact matches first
        if pattern == filePath </span><span class="cov2" title="3">{
                return true
        }</span>

        // Handle directory patterns ending with /
        <span class="cov8" title="122">if strings.HasSuffix(pattern, "/") </span><span class="cov2" title="2">{
                return strings.HasPrefix(filePath+"/", pattern)
        }</span>

        // Handle ** patterns (match any number of directories)
        <span class="cov8" title="120">if strings.Contains(pattern, "**") </span><span class="cov5" title="20">{
                return matchesDoubleStarPattern(pattern, filePath)
        }</span>

        // Handle patterns with explicit path separators
        <span class="cov7" title="100">if strings.Contains(pattern, "/") </span><span class="cov5" title="18">{
                // Pattern contains path separator, do full path matching
                matched, err := filepath.Match(pattern, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov5" title="18">return matched</span>
        }

        // For simple glob patterns without path separators (like *.bin),
        // only match against the filename, not the full path
        // filename := filepath.Base(filePath)
        <span class="cov7" title="82">matched, err := filepath.Match(pattern, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="82">return matched</span>
}

// matchesDoubleStarPattern handles ** patterns in gitattributes
func matchesDoubleStarPattern(pattern, filePath string) bool <span class="cov5" title="20">{
        // Handle ** patterns by splitting on ** and matching each part
        parts := strings.Split(pattern, "**")

        // If no ** found, fall back to regular matching
        if len(parts) == 1 </span><span class="cov0" title="0">{
                matched, err := filepath.Match(pattern, filePath)
                return err == nil &amp;&amp; matched
        }</span>

        // For patterns with **, we need to match each part
        // Example: "docs/**/*.pdf" becomes ["docs/", "/*.pdf"]
        // Example: "**/*.bin" becomes ["", "/*.bin"]

        <span class="cov5" title="20">currentPath := filePath

        for i, part := range parts </span><span class="cov5" title="27">{
                if part == "" </span><span class="cov2" title="2">{
                        continue</span> // Skip empty parts
                }

                <span class="cov5" title="25">if i == 0 </span><span class="cov5" title="18">{
                        // First part - must match the beginning
                        if strings.HasSuffix(part, "/") </span><span class="cov5" title="18">{
                                // Directory prefix
                                if !strings.HasPrefix(currentPath, part) </span><span class="cov4" title="13">{
                                        return false
                                }</span>
                                <span class="cov3" title="5">currentPath = currentPath[len(part):]</span>
                        } else<span class="cov0" title="0"> {
                                // File pattern at the beginning
                                matched, err := filepath.Match(part, currentPath)
                                return err == nil &amp;&amp; matched
                        }</span>
                } else<span class="cov3" title="7"> if i == len(parts)-1 </span><span class="cov3" title="7">{
                        // Last part - must match the end or remaining path
                        part = strings.TrimPrefix(part, "/")

                        // For the last part, try to match against the filename or remaining path
                        if strings.Contains(part, "/") </span><span class="cov0" title="0">{
                                // Pattern has path components, match against remaining path
                                matched, err := filepath.Match(part, currentPath)
                                return err == nil &amp;&amp; matched
                        }</span> else<span class="cov3" title="7"> {
                                // Simple filename pattern, match against just the filename
                                filename := filepath.Base(currentPath)
                                matched, err := filepath.Match(part, filename)
                                return err == nil &amp;&amp; matched
                        }</span>
                }
                // Middle parts would be handled here if we had more complex patterns
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package utils

import (
        "fmt"
        "net/http"
        "net/url"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

func GitTopLevel() (string, error) <span class="cov5" title="11">{
        path, err := SimpleRun([]string{"git", "rev-parse", "--show-toplevel"})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="11">return strings.TrimSuffix(path, "\n"), nil</span>
}

func SimpleRun(cmds []string) (string, error) <span class="cov5" title="12">{
        exePath, err := exec.LookPath(cmds[0])
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("command not found: %s: %w", cmds[0], err)
        }</span>
        <span class="cov5" title="11">cmd := exec.Command(exePath, cmds[1:]...)
        cmdOut, err := cmd.Output()
        return string(cmdOut), err</span>
}

func DrsTopLevel() (string, error) <span class="cov0" title="0">{
        base, err := GitTopLevel()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(base, DRS_DIR), nil</span>
}

// CanDownloadFile checks if a file can be downloaded from the given signed URL
// by issuing a ranged GET for a single byte to mimic HEAD behavior.
func CanDownloadFile(signedURL string) error <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", signedURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Range", "bytes=0-0")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while sending the request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusPartialContent || resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("failed to access file, HTTP status: %d", resp.StatusCode)</span>
}

func ParseEmailFromToken(tokenString string) (string, error) <span class="cov3" title="5">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode token in ParseEmailFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov3" title="4">context, ok := claims["context"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context' claim structure")
        }</span>
        <span class="cov3" title="3">user, ok := context["user"].(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user' claim structure")
        }</span>
        <span class="cov2" title="2">name, ok := user["name"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'context.user.name' claim")
        }</span>
        <span class="cov1" title="1">return name, nil</span>
}

func ParseAPIEndpointFromToken(tokenString string) (string, error) <span class="cov3" title="3">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token in ParseAPIEndpointFromToken: '%s': %w", tokenString, err)
        }</span>
        <span class="cov3" title="3">issUrl, ok := claims["iss"].(string)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("missing or invalid 'iss' claim")
        }</span>
        <span class="cov2" title="2">parsedURL, err := url.Parse(issUrl)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host), nil</span>
}

func ParseS3URL(s3url string) (string, string, error) <span class="cov5" title="13">{
        s3Prefix := "s3://"
        if !strings.HasPrefix(s3url, s3Prefix) </span><span class="cov3" title="4">{
                return "", "", fmt.Errorf("S3 URL requires prefix 's3://': %s", s3url)
        }</span>
        <span class="cov5" title="9">trimmed := strings.TrimPrefix(s3url, s3Prefix)
        slashIndex := strings.Index(trimmed, "/")
        if slashIndex == -1 || slashIndex == len(trimmed)-1 </span><span class="cov3" title="4">{
                return "", "", fmt.Errorf("invalid S3 file URL: %s", s3url)
        }</span>
        <span class="cov3" title="5">return trimmed[:slashIndex], trimmed[slashIndex+1:], nil</span>
}

// IsValidSHA256 checks if a string is a valid SHA-256 hash
func IsValidSHA256(s string) bool <span class="cov4" title="6">{
        if len(s) != 64 </span><span class="cov3" title="3">{
                return false
        }</span>
        <span class="cov3" title="3">for _, r := range s </span><span class="cov10" title="129">{
                if (r &lt; '0' || r &gt; '9') &amp;&amp; (r &lt; 'a' || r &gt; 'f') &amp;&amp; (r &lt; 'A' || r &gt; 'F') </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov2" title="2">return true</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package version reports the Git-DRS version.
package version

import "fmt"

// Build and version details
var (
        GitCommit   = ""
        GitBranch   = ""
        GitUpstream = ""
        BuildDate   = ""
        Version     = ""
)

var tpl = `git commit: %s
git branch: %s
git upstream: %s
build date: %s
version: %s`

// String formats a string with version details.
func String() string <span class="cov8" title="1">{
        return fmt.Sprintf(tpl, GitCommit, GitBranch, GitUpstream, BuildDate, Version)
}</span>

// LogFields logs build and version information to the given logger.
func LogFields() []any <span class="cov8" title="1">{
        return []any{
                "GitCommit", GitCommit,
                "GitBranch", GitBranch,
                "GitUpstream", GitUpstream,
                "BuildDate", BuildDate,
                "Version", Version,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
